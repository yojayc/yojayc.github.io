<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>新标日-初级-第24课</title>
    <link href="/2026/02/11/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC24%E8%AF%BE/"/>
    <url>/2026/02/11/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC24%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="第24课我想小李马上就来"><a href="#第24课我想小李马上就来" class="headerlink" title="第24课我想小李马上就来"></a>第24课我想小李马上就来</h1><h2 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h2><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">ます形</th><th align="center">假名</th><th align="center">原形</th><th align="center">假名</th></tr></thead><tbody><tr><td align="center">思います</td><td align="center">おもいます</td><td align="center">思う</td><td align="center">おもう</td></tr><tr><td align="center">言います</td><td align="center">いいます</td><td align="center">言う</td><td align="center">いう</td></tr><tr><td align="center">探します</td><td align="center">さがします</td><td align="center">探す</td><td align="center">さがす</td></tr><tr><td align="center">笑います</td><td align="center">わらいます</td><td align="center">笑う</td><td align="center">わらう</td></tr><tr><td align="center">やめます</td><td align="center">&nbsp;</td><td align="center">やめる</td><td align="center">&nbsp;</td></tr><tr><td align="center">決めます</td><td align="center">きめます</td><td align="center">決める</td><td align="center">きめる</td></tr><tr><td align="center">寝坊します</td><td align="center">ねぼうします</td><td align="center">寝坊する</td><td align="center">ねぼうする</td></tr><tr><td align="center">外出します</td><td align="center">がいしゅつします</td><td align="center">外出する</td><td align="center">がいしゅつする</td></tr><tr><td align="center">研究します</td><td align="center">けんきゅうします</td><td align="center">研究する</td><td align="center">けんきゅうする</td></tr></tbody></table></div><h2 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h2><p>李（り）さんは　もう　すぐ　来（く）ると　思（おも）います<br>我想小李马上就来</p><p>陳（ちん）さんは　パーティーに　行（い）くと　言（い）いました<br>老陈说要去参加晚会</p><p>すみません、頭（あたま）が　痛（いた）いんです<br>对不起，我头疼</p><p>東京（とうきょう）タワーへ　行きたいんですが、どうやって　行きますか<br>我想去东京塔，怎么走好啊？</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="小句（简体形）と-思（おも）います"><a href="#小句（简体形）と-思（おも）います" class="headerlink" title="小句（简体形）と　思（おも）います"></a>小句（简体形）と　思（おも）います</h3><p>表示<strong>说话人的思考内容</strong>，主语是“我”，翻译“<strong>我觉得、我认为</strong>”。简体形结尾和と<strong>连读</strong></p><p>李さんは　もう　すぐ　来ると　思います</p><p>田中（たなか）さんは　来（こ）ないと　思います<br>我想田中先生不会来</p><p>この　本（ほん）は　おもしろいと　思います<br>我觉得这本书有意思</p><p>日本（にほん）は　きれいだと　思います<br>我觉得日本很干净</p><p>明日（あした）は　いい　天気（てんき）だと　思います<br>我觉得明天会是个好天气</p><blockquote><p>　“〜と　思います” 只能表示<strong>说话人</strong>的思考内容</p><p>　“〜と　<span style="color:red">思いました</span>”　“〜と　<span style="color:red">思っています</span>” 可以表示<strong>说话人以外的人</strong>的思考内容</p></blockquote><p>馬さんは　日本が　きれいだと　思って　います<br>小马觉得日本很干净</p><p>馬（ば）さんは　日本（にほん）へ　行きたいと　思って　います<br>小马想去日本</p><ul><li><p>私は　〜と思います　[思考的根据是<strong>现在</strong>]</p></li><li><p>私は　〜と思っています [思考的根据是<strong>过去</strong>]</p></li><li><p>私は　〜と思いました　[曾经觉得，发表感想]</p></li></ul><p>看了这部电影后，我觉得小王很坏<br>この映画を見て、王さんは悪（わる）い人（ひと）だと思いました</p><p>我觉得要下雨<br>雨（あめ）が　降（ふ）ると　思います</p><p>小王从小就很优秀，所以我觉得他可以通过N1<br>王さんは昔（むかし）から　優秀（ゆうしゅう）だから、N1試験（しけん）に合格（ごうかく）すると思っています</p><h3 id="名-人-は-小句（简体形）と-言（い）いました"><a href="#名-人-は-小句（简体形）と-言（い）いました" class="headerlink" title="名[人]は 小句（简体形）と　言（い）いました"></a>名[人]は 小句（简体形）と　言（い）いました</h3><p><strong>向他人转述别人说的话</strong>时，在所说的话后加“～と　言いました”</p><p>陳（ちん）さんは　パーティーに　行くと　言いました</p><p>森さんは　中国語（ちゅうごくご）の　試験（しけん）は　難（むずか）しかったと　言いました<br>森先生说汉语考试很难</p><blockquote><p><strong>明确指出是向谁说的</strong>，在句子中加入“<strong>名词+に</strong>”</p></blockquote><p>小野（おの）さんは　李（り）さんに　ちょっと　休（やす）みたいと　言いました<br>小野女士跟小李说想休息一下</p><p>我对母亲说我饿了<br>私は　母に　お腹（なか）が空（す）いたと　言いました</p><p>路飞对海军说我要成为航海王<br>ルフィーは　海軍（かいぐん）に　俺（おれ）は　海賊王（かいぞくおう）になる　と言った</p><blockquote><p>转述某人<span style="color:red"><strong>反复说起的事情</strong></span>，用“<strong>〜と　言（い）って　います</strong>”表示</p></blockquote><p>来週（らいしゅう）の　ハイキングに　張（ちょう）さんも　行きたいと　言って　います<br>小张说他也想参加下星期的郊游</p><p>小王说日语很难<br>王さんは　日本語が　難しいと　言いました</p><p>（三天两头说一次）蛋蛋说许嵩是她老公<br>エッグちゃんは　Vaeが彼女（かのじょ）の旦那（だんな）だ　と言って　います</p><h3 id="〜のです-んです"><a href="#〜のです-んです" class="headerlink" title="〜のです&#x2F;んです"></a>〜のです&#x2F;んです</h3><p>“〜のです&#x2F;んです” 表示<strong>所讲的内容与前句或前项内容有关联</strong>。用于<strong>说明状况或解释原因、理由</strong>。～のです 更正式</p><ul><li><p>动词 + 〜のです&#x2F;んです</p></li><li><p>一类形容词 + 〜のです&#x2F;んです</p></li><li><p>二类形容词 + ～<strong>な</strong>のです&#x2F;<strong>な</strong>んです</p></li><li><p>名词 + 〜<strong>な</strong>のです&#x2F;<strong>な</strong>んです</p></li></ul><p>すみません、頭が　<span style="color:red">痛い</span><strong>んです</strong></p><p>タバコは　やめた　ほうが　いいですょ<br>烟还是戒了为好<br>ーー　そう<strong>なんです</strong>が、やめる　ことが　<span style="color:red">できない</span>んです<br>—— 是啊，但就是戒不掉</p><p>すごい　人気（にんき）ですね<br>他可真受欢迎啊<br>ーー　ええ、あの　歌手（かしゅ）は　日本（にほん）では　とても　<span style="color:red">有名（ゆうめい）</span><strong>なんです</strong><br>—— 是，那个歌手在日本非常有名</p><p>これ、京都（きょうと）の　<span style="color:red">お土産（みやげ）</span><strong>なんです</strong>。どうぞ<br>这是京都的特产，请收下</p><p><strong>どうして　〜のですか&#x2F;んですか　是询问理由的完美形式，回答此问句时也要用 〜のです&#x2F;んです 的形式</strong></p><p>どうして　<span style="color:red">食（た）べない</span><strong>んですか</strong><br>为什么不吃？<br>ーー　もう　おなかが　いっぱい<strong>なんです</strong><br>—— 已经吃饱了</p><p>昨日（きのう）、どうして　<span style="color:red">休（やす）んだ</span><strong>んですか</strong><br>昨天为什么休息了？<br>ーー　頭（あたま）が　<span style="color:red">痛（いた）かった</span><strong>んです</strong><br>—— 我头疼了</p><p>どうして　<span style="color:red">遅刻（ちこく）した</span><strong>んですか</strong><br>为什么迟到了？<br>ーー　<span style="color:red">寝坊（ねぼう）した</span><strong>んです</strong><br>—— 睡懒觉了</p><h3 id="小句が-小句-铺垫"><a href="#小句が-小句-铺垫" class="headerlink" title="小句が 小句 [铺垫]"></a>小句が 小句 [铺垫]</h3><p>“が”除了表示<a href="https://yojayc.github.io/2026/01/29/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC16%E8%AF%BE/#%E5%B0%8F%E5%8F%A5-%E3%81%8C-%E5%B0%8F%E5%8F%A5-%E8%BD%AC%E6%8A%98"><strong>转折</strong></a>的用法，还可以用来提示接下来要说的内容，表示<strong>铺垫</strong>。与“<a href="https://yojayc.github.io/2026/02/09/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC22%E8%AF%BE/#%E3%81%91%E3%81%A9-%E8%BD%AC%E6%8A%98-%E9%93%BA%E5%9E%AB">けど</a>”相比，“が”多用于<strong>书面语</strong></p><p>東京タワーへ　行きたいんですが、どうやって　行きますか</p><p>李（り）さんを　探（さが）して　いるんですが、どこに　いますか<br>我在找小李，她在哪儿？（<a href="https://yojayc.github.io/2026/01/27/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC15%E8%AF%BE/#%E5%8A%A8%E3%81%A6-%E3%81%84%E3%81%BE%E3%81%99-%E6%AD%A3%E5%9C%A8%E8%BF%9B%E8%A1%8C">探（さが）して　いるんですが 表示正在找</a>）</p><p>明日（あした）から　連休（れんきゅう）ですが、どうするか　決（き）めましたか<br>从明天开始就是长假了，你想好了怎么过吗？</p><p>明日から　連休だけど、どうするか　決めた<br>从明天开始就是长假了，你想好了怎么过吗？</p><h2 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h2><h3 id="〜と-思います"><a href="#〜と-思います" class="headerlink" title="〜と　思います"></a>〜と　思います</h3><p>日本人即使很确信某个观点，向别人陈述时，<strong>尽量避免使用绝对性的说法</strong>，在句子后加上 “〜と　思います” <strong>舒缓语气</strong></p><h3 id="どうやって〜-询问方法"><a href="#どうやって〜-询问方法" class="headerlink" title="どうやって〜　[询问方法]"></a>どうやって〜　[询问方法]</h3><p><strong>どうやって</strong>　由疑问词 “どう” 与动词 “やる” 的て形 “<strong>やって</strong>” 结合而成，用于<strong>询问方法</strong></p><p><strong>どうして</strong>　由疑问词 “どう” 与动词 “する” 的て形 “<strong>して</strong>” 结合而成，用于<strong>询问理由</strong></p><h3 id="〜に-ついて"><a href="#〜に-ついて" class="headerlink" title="〜に　ついて"></a>〜に　ついて</h3><p>表示 “<strong>关于～</strong>”，后接 “考（かんが）えます [思考]” “思（おも）います [想]” “研究（けんきゅう）します [研究]” 等<strong>表示思维活动的词语</strong></p><h3 id="とうとう"><a href="#とうとう" class="headerlink" title="とうとう"></a>とうとう</h3><p>表示 “终于” “结局” “到底”</p><h3 id="分别的寒暄-寒暄语"><a href="#分别的寒暄-寒暄语" class="headerlink" title="分别的寒暄 [寒暄语]"></a>分别的寒暄 [寒暄语]</h3><h4 id="お世話（せわ）に-なりました"><a href="#お世話（せわ）に-なりました" class="headerlink" title="お世話（せわ）に　なりました"></a>お世話（せわ）に　なりました</h4><p>受到别人的<strong>照顾和帮助</strong>，分手时所说的<strong>表示感谢的话</strong></p><p><strong>今后</strong>将要得到别人的帮助或指导时，用 “<strong>お世話（せわ）に　<span style="color:red">なります</span></strong>”</p><h4 id="〜に-よろしく-お伝（つた）え-ください"><a href="#〜に-よろしく-お伝（つた）え-ください" class="headerlink" title="〜に　よろしく　お伝（つた）え　ください"></a>〜に　よろしく　お伝（つた）え　ください</h4><p>表示 “<strong>请向～问好</strong>”。“に” 前接人，“お伝え　ください” 表示 “传递给……”</p><p>进一步<strong>加重语气</strong>在前面加上 “どうぞ”</p><p>双方关系亲密，<strong>不需要特别客套时</strong>只说 “〜に　よろしく”</p><h4 id="“お元気（げんき）で”-“お気を-つけて”"><a href="#“お元気（げんき）で”-“お気を-つけて”" class="headerlink" title="“お元気（げんき）で”　“お気を　つけて”"></a>“お元気（げんき）で”　“お気を　つけて”</h4><p>祝对方一路平安</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第23课</title>
    <link href="/2026/02/10/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC23%E8%AF%BE/"/>
    <url>/2026/02/10/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC23%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="第23课周末或节假日，有时散步，有时买东西"><a href="#第23课周末或节假日，有时散步，有时买东西" class="headerlink" title="第23课周末或节假日，有时散步，有时买东西"></a>第23课周末或节假日，有时散步，有时买东西</h1><h2 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h2><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">ます形</th><th align="center">假名</th><th align="center">原形</th><th align="center">假名</th></tr></thead><tbody><tr><td align="center">違います</td><td align="center">ちがいます</td><td align="center">違う</td><td align="center">ちがう</td></tr><tr><td align="center">込みます</td><td align="center">こみます</td><td align="center">込む</td><td align="center">こむ</td></tr><tr><td align="center">決まります</td><td align="center">きまります</td><td align="center">決まる</td><td align="center">きまる</td></tr><tr><td align="center">知らせます</td><td align="center">しらせます</td><td align="center">知らせる</td><td align="center">しらせる</td></tr><tr><td align="center">確かめます</td><td align="center">たしかめます</td><td align="center">確かめる</td><td align="center">たしかめる</td></tr></tbody></table></div><h2 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h2><p>小野（おの）さんは　休（やす）みの　日（ひ）、散歩（さんぽ）したり　買（か）い物（もの）に　行（い）ったり　します<br>周末或节假日，小野女士有时散步，有时买东西。</p><p>日本語（にほんご）の　先生（せんせい）は　中国人（ちゅうごくじん）だったり　日本人（にほんじん）だったりです<br>日语老师既有中国人，也有日本人</p><p>私（わたし）は　今年（ことし）の　夏（なつ）、北京（ペキン）へ　行（い）くか　どうか　分（わ）かりません<br>我今年夏天去不去北京，还不知道</p><p>かぎが　どこに　あるか　教（おし）えて　ください<br>请告诉我钥匙在哪儿</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="动たり-动たり-します"><a href="#动たり-动たり-します" class="headerlink" title="动たり 动たり　します"></a>动<span style="color:red">た</span>り 动<span style="color:red">た</span>り　<span style="color:red">します</span></h3><p><strong>列举若干种有代表性的动作</strong>，将动词“た形”的“た”变为“<strong>たり</strong>”</p><p>小野さんは　休みの日、<strong>散歩したり</strong>　買い物に　<strong>行ったり　<span style="color:red">します</span></strong></p><p>吉田（よしだ）さんは　日曜日（にちようび）<strong>には</strong>　何（なに）を　しますか<br>吉田先生，你星期天都做什么？（<strong>には</strong>用于强调星期天）<br>ーー　家（いえ）の　<strong>掃除（そうじ）を　したり　洗濯（せんたく）を　したり　<span style="color:red">します</span></strong><br>—— 打扫打扫房间，洗洗衣服</p><p>昨天我在家里听听音乐，看看书<br>昨日、私は　家で　音楽を　聞いたり　本を　読んだり　しました</p><h3 id="一类形、二类形和名词"><a href="#一类形、二类形和名词" class="headerlink" title="一类形、二类形和名词"></a>一类形、二类形和名词</h3><div class=".center"><table><thead><tr><th align="center">&nbsp;</th><th align="center">&nbsp;</th></tr></thead><tbody><tr><td align="center">一类形<span style="color:red"><strong>かった</strong></span><strong>り</strong></td><td align="center">一类形<strong>かったり<span style="color:red">です</span></strong></td></tr><tr><td align="center">二类形<span style="color:red"><strong>だった</strong></span><strong>り</strong></td><td align="center">二类形<strong>だったり<span style="color:red">です</span></strong></td></tr><tr><td align="center">名<span style="color:red"><strong>だった</strong></span><strong>り</strong></td><td align="center">名<strong>だったり<span style="color:red">です</span></strong></td></tr></tbody></table></div><p>将一类形容词、二类形容词和名词<strong>过去简体形 “〜かった” “〜だった” 的 “た” 变成 “<span style="color:red">たり</span>”</strong>，表示<strong>状态或状况有多种可能</strong></p><p>一类形容词、二类形容词成对出现的状态一般是<strong>反义</strong></p><p>飛行機（ひこうき）の　チケットは　<strong>高（たか）かったり　安（やす）かったりです</strong><br>飞机票有时贵，有时便宜</p><p>マンジョンの　部屋（へや）は　<strong>広（ひろ）かったり　狭（せま）かったりです</strong><br>公寓的房间有大有小</p><p>この　公園（こうえん）は　時間（じかん）<strong><span style="color:red">に　よって</span>　静（しず）かだったり　にぎやかだったりです</strong><br>根据时间，这个时间有时寂静，有时热闹（<strong>〜に　よって</strong>表示根据）</p><p>日本語の　先生は　<strong>中国人だったり　日本人だったりです</strong></p><h3 id="小句-か"><a href="#小句-か" class="headerlink" title="小句+か"></a>小句+か</h3><p>表示<strong>某种不确定的内容</strong></p><h4 id="小句-か-どうか"><a href="#小句-か-どうか" class="headerlink" title="小句+か　どうか"></a>小句+か　どうか</h4><p><strong>不包含疑问词的疑问句</strong>作为一个长句中的一部分时，将<strong>动词、一类形容词的敬体形变为简体形</strong>，在其后<strong>加上“か　どうか”</strong></p><p>（わたしは）今年の　夏、北京へ　行きますか。わたしは　分かりません<br>ー　わたしは　今年（ことし）の　夏（なつ）、北京（ペキン）へ　行く<strong>か　どうか</strong>　分（わ）かりません<br>我今年夏天去不去北京，还不知道</p><p>この　料理（りょうり）は　辛（から）いですか。わたしは　知（し）りません<br>ー　わたしは　この　料理<strong>が　辛いか　どうか</strong>　知りません<br>我不知道这道菜辣不辣</p><p>小野（おの）さんに　仕事（しごと）が　<strong>終（お）わったか　どうか</strong>　聞（き）いて　ください<br>小野さんに　仕事が　終わりましたか。聞いて　ください<br>问一下小野女士，工作做完了没有</p><p>我不知道明天会不会下雪<br>私は　明日、雪が　降りるか　どうか　知りません</p><blockquote><p>重复使用动词的“<strong>基本形</strong>”和“<strong>ない形</strong>”，表达相同的含义</p></blockquote><p>わたしは　今年の　夏、北京へ　<strong><span style="color:red">行く</span>か　<span style="color:red">行かない</span>か</strong>　分かりません</p><p>わたしは　この　料理<strong>が　<span style="color:red">辛い</span>か　<span style="color:red">辛くない</span>か</strong>　知りません</p><blockquote><p>“〜か　どうか”前面是<strong>名词或二类形容词</strong>时，中间<strong>不加“だ”</strong></p><p>“〜か　どうか”小句中<strong>主语后必须用“が”</strong>，不能用“は”</p></blockquote><p>キムさんは　中国人（ちゅうごくじん）ですか。わたしは　知（し）りません<br>ー　わたしは　キムさん<strong>が　中国人か　どうか</strong>　知りません<br>我不知道金女士是不是中国人</p><p>わたしは　キムさん<strong>が　中国人か　中国人では　ないか</strong>　知りません</p><p>我不知道今年的冬天去不去东京<br>私は　今年の冬、東京へ　行くか　行かないか　分かりません<br>私は　今年の冬、東京へ　行くか　どうか　分かりません<br>今年の冬、東京へ行きますか。私は分かりません</p><h4 id="疑问词小句-か"><a href="#疑问词小句-か" class="headerlink" title="疑问词小句+か"></a>疑问词小句+か</h4><p>将<strong>包含疑问词[何（なに）、だれ、どこ]的疑问句</strong>，作为一个长句中的一部分使用时，需要<strong>将疑问词小句的动词、一类形容词的敬体形变为简体形，再加“か”</strong></p><p><strong>かぎが　<span style="color:red">どこ</span>に　<span style="color:red">あるか</span></strong>　教（おし）えて　ください<br>かぎがどこにありますか。私は　教えて　ください</p><p><strong>昨日（きのう）　<span style="color:red">何（なに）</span>を　<span style="color:red">食（た）べたか</span></strong>　忘（わ）れました<br>忘记昨天吃什么了</p><p><strong><span style="color:red">ど</span>の　料理（りょうり）が　<span style="color:red">辛（から）いか</span></strong>　知（し）りません<br>不知道哪道菜辣</p><p><strong>この　歌（うた）が　だれの　歌か</strong>　知って　いますか<br>你知道这是谁的歌吗？</p><h2 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h2><h3 id="〜に-よって"><a href="#〜に-よって" class="headerlink" title="〜に　よって"></a>〜に　よって</h3><p>相当于汉语“根据……”</p><h3 id="あっ、そうだ"><a href="#あっ、そうだ" class="headerlink" title="あっ、そうだ"></a>あっ、そうだ</h3><p>表示<strong>突然想到某事，突然想起某事</strong>，相当于“啊，对了” “啊，想起来了”</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第22课</title>
    <link href="/2026/02/09/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC22%E8%AF%BE/"/>
    <url>/2026/02/09/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC22%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="第22课小森每晚都看电视"><a href="#第22课小森每晚都看电视" class="headerlink" title="第22课小森每晚都看电视"></a>第22课小森每晚都看电视</h1><h2 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h2><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">ます形</th><th align="center">假名</th><th align="center">原形</th><th align="center">假名</th></tr></thead><tbody><tr><td align="center">やります</td><td align="center">&nbsp;</td><td align="center">やる</td><td align="center">&nbsp;</td></tr></tbody></table></div><h2 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h2><p>森（もり）さんは　毎晩（まいばん）　テレビを　見（み）る<br>森先生每天晚上看电视</p><p>昨日（きのう）は　とても　忙（いそが）しかった<br>昨天很忙</p><p>コンピュータは　簡単（かんたん）では　ない<br>电脑用起来不简单</p><p>今日（きょう）は　曇（くも）りだ<br>今天是阴天</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="敬体形和简体形"><a href="#敬体形和简体形" class="headerlink" title="敬体形和简体形"></a>敬体形和简体形</h3><p><strong>敬体形</strong>： “<strong>ます</strong>” “<strong>です</strong>”是对<strong>长辈或关系不太亲密的人</strong>使用的形式</p><p><strong>简体</strong>形： 对自己的<strong>同辈或晚辈，或关系较密切</strong>时使用，是不使用“ます” “です”的形式</p><h3 id="动词的简体形"><a href="#动词的简体形" class="headerlink" title="动词的简体形"></a>动词的简体形</h3><table align="center"><tbody align="center" valign="center"><tr><th>&nbsp;</th><th>&nbsp;</th><th>敬体形</th><th>简体形</th><th>敬体形</th><th>简体形</th></tr><tr><th rowspan=2>现在将来形式</th><td><b>肯定</b></td><td>買（か）います（<b>买</b>）</td><td>買う（基本形）</td><td>あります（<b>有</b>）</td><td>ある</td></tr><tr><td><b>否定</b></td><td>買いません</td><td>買わない（ない形）</td><td>ありません</td><td><b>ない</b></td></tr><tr><th rowspan=2>过去形式</th><td><b>肯定</b></td><td>買いました</td><td>買った（た形）</td><td>ありました</td><td>あった</td></tr><tr><td><b>否定</b></td><td>買いませんでした</td><td>買わなかった（なかった形）</td><td>ありませんでした</td><td>なかった</td></tr></tbody></table><p>森さんは　毎晩　テレビを　<strong>見る</strong></p><p>コーヒー、<strong>飲（の）む</strong><br>喝咖啡吗？<br>ーー　ううん、<strong>飲まない</strong><br>—— 不，不喝</p><p>昨日（きのう）　テレビ、<strong>見た</strong><br>昨天看电视了吗？<br>ーー　ううん、<strong>見なかった</strong><br>—— 不，没看</p><blockquote><p>简体的会话中常常省略助词</p></blockquote><h3 id="一类形容词谓语形式的简体形"><a href="#一类形容词谓语形式的简体形" class="headerlink" title="一类形容词谓语形式的简体形"></a>一类形容词谓语形式的简体形</h3><table align="center"><tbody align="center" valign="center"><tr><th>&nbsp;</th><th>&nbsp;</th><th>敬体形</th><th>简体形</th></tr><tr><th rowspan=2>现在将来形式</th><td><b>肯定</b></td><td>忙（いそが）しいです（忙）</td><td>忙しい</td></tr><tr><td><b>否定</b></td><td>忙しく　ないです</td><td>忙しく　ない</td></tr><tr><th rowspan=2>过去形式</th><td><b>肯定</b></td><td>忙しかったです</td><td>忙しかった</td></tr><tr><td><b>否定</b></td><td>忙しく　なかったです</td><td>忙しく　なかった</td></tr></tbody></table><p>その　カレー、おいしい<br>那个咖喱饭好吃吗？<br>ーー　ううん、あんまり　おいしく　ないよ<br>—— 不怎么样，味道不太好啊</p><p>昨日（きのう）の　試験（しけん）、どうだった<br>昨天的考试怎么样啊？<br>ーー　ちょっと　難（むずか）しかった<br>—— 稍微有点难</p><blockquote><p>一类形容词简体形后面不能加“た”</p></blockquote><h3 id="二类形容词谓语形式的简体形"><a href="#二类形容词谓语形式的简体形" class="headerlink" title="二类形容词谓语形式的简体形"></a>二类形容词谓语形式的简体形</h3><table align="center"><tbody align="center" valign="center"><tr><th>&nbsp;</th><th>&nbsp;</th><th>敬体形</th><th>简体形</th></tr><tr><th rowspan=2>现在将来形式</th><td><b>肯定</b></td><td>簡単（かんたん）です（简单）</td><td>簡単<b>だ</b></td></tr><tr><td><b>否定</b></td><td>簡単では　ありません</td><td>簡単<b>では　ない</b></td></tr><tr><th rowspan=2>过去形式</th><td><b>肯定</b></td><td>簡単でした</td><td>簡単<b>だった</b></td></tr><tr><td><b>否定</b></td><td>簡単では　ありませんでした</td><td>簡単では　<b>なかった</b></td></tr></tbody></table><blockquote><p><strong>だ</strong> 是 <strong>です</strong> 的简体</p><p><strong>だった</strong> 是 <strong>でした</strong> 的简体</p><p>现在将来形式的<strong>肯定疑问句</strong>去掉简体形中的“だ”</p></blockquote><p>この　ネクタイ、派手（はで）<br>这条领带花哨吗？<br>ーー　ううん、全然（ぜんぜん）　派手じゃ　ない<strong>わ</strong><br>—— 不，一点都不花哨</p><p>森さんの　アパート、静（しず）か<br>森先生居住的公寓安静吗？<br>ーー　うん、静かだよ<br>—— 嗯，很安静</p><blockquote><p>女生说 わ</p></blockquote><h3 id="名词谓语形式的简体形"><a href="#名词谓语形式的简体形" class="headerlink" title="名词谓语形式的简体形"></a>名词谓语形式的简体形</h3><table align="center"><tbody align="center" valign="center"><tr><th>&nbsp;</th><th>&nbsp;</th><th>敬体形</th><th>简体形</th></tr><tr><th rowspan=2>现在将来形式</th><td><b>肯定</b></td><td>晴（は）れです（简单）</td><td>晴れ<b>だ</b></td></tr><tr><td><b>否定</b></td><td>晴れでは　ありません</td><td>晴れでは　<b>ない</b></td></tr><tr><th rowspan=2>过去形式</th><td><b>肯定</b></td><td>晴れでした</td><td>はれ<b>だった</b></td></tr><tr><td><b>否定</b></td><td>晴れでは　ありませんでした</td><td>晴れでは　<b>なかった</b></td></tr></tbody></table><p>今日（きょう）は　曇（くも）りだ</p><p>明日（あした）は　水曜日（すいようび）だ<strong>ね</strong><br>明天是星期三吧<br>ーー　水曜日じゃ　ないよ。木曜日（もくようび）だよ<br>—— 不是星期三，是星期四</p><p>昨日（きのう）、スキー場（じょう）は　雪（ゆき）だった<br>昨天滑雪场下雪了吗？<br>ーー　ううん、雪じゃ　なかったよ。いい　天気（てんき）だった<br>—— 没有下雪啊，天气挺好的</p><h3 id="けど-转折-铺垫"><a href="#けど-转折-铺垫" class="headerlink" title="けど　[转折] [铺垫]"></a>けど　[转折] [铺垫]</h3><p>“けど” 连接两个句子，表示转折，用于口语</p><p>昨日の　試験（しけん）、どうだった<br>昨天的考试怎么样啊？<br>ーー　ちょっと　難（むずか）しかった<strong>けど</strong>、まあまあ　できたよ [转折]<br>—— 有点难，不过都做出来了</p><p>来週（らいしゅう）、送別会（そうべつかい）を　する<strong>けど</strong>、都合（つごう）は　どうかな [铺垫]<br>下星期一要开一个欢送会，你时间方便吗？</p><h2 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h2><h3 id="简体会话"><a href="#简体会话" class="headerlink" title="简体会话"></a>简体会话</h3><h4 id="敬体和简体"><a href="#敬体和简体" class="headerlink" title="敬体和简体"></a>敬体和简体</h4><p><strong>敬体</strong>：</p><ul><li><p>正式场合谈话</p></li><li><p>书信</p></li></ul><p><strong>简体</strong>：</p><ul><li><p>与家人、朋友交谈</p></li><li><p>有关法律的文章、报纸、商业文件</p></li></ul><h4 id="简体助词"><a href="#简体助词" class="headerlink" title="简体助词"></a>简体助词</h4><p>かな（用于<strong>自言自语</strong>），の（要求<strong>说明或确认某事</strong>）　只能接在简体形后面</p><h4 id="って"><a href="#って" class="headerlink" title="って"></a>って</h4><p>结尾加 って 表示<strong>传闻</strong></p><h4 id="〜方（かた）"><a href="#〜方（かた）" class="headerlink" title="〜方（かた）"></a>〜方（かた）</h4><p>动词“ます形”<strong>去掉“ます”加上“方”<strong>表示“</strong>～的做法</strong>”的意思，表示<strong>动作的方式</strong></p><div class="center"><table><thead><tr><th align="center">ます形</th><th align="center">去掉ます</th><th align="center">〜方</th><th align="center">～做法</th></tr></thead><tbody><tr><td align="center">話（はな）します</td><td align="center">話し</td><td align="center">話し方</td><td align="center">说法</td></tr><tr><td align="center">読（よ）みます</td><td align="center">読み</td><td align="center">読み方</td><td align="center">读法</td></tr><tr><td align="center">作（つく）ります</td><td align="center">作り</td><td align="center">作り方</td><td align="center">做法</td></tr><tr><td align="center">やります</td><td align="center">やり</td><td align="center">やり方</td><td align="center">办法</td></tr><tr><td align="center">使（つか）います</td><td align="center">使い</td><td align="center">使い方</td><td align="center">用法</td></tr></tbody></table></div>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第21课</title>
    <link href="/2026/02/08/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC21%E8%AF%BE/"/>
    <url>/2026/02/08/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC21%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第21课我吃过寿喜锅"><a href="#第21课我吃过寿喜锅" class="headerlink" title="第21课我吃过寿喜锅"></a>第21课我吃过寿喜锅</h2><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">ます形</th><th align="center">假名</th><th align="center">原形</th><th align="center">假名</th></tr></thead><tbody><tr><td align="center">渡します</td><td align="center">わたします</td><td align="center">渡す</td><td align="center">わたす</td></tr><tr><td align="center">遅れます</td><td align="center">おくれます</td><td align="center">遅れる</td><td align="center">おくれる</td></tr><tr><td align="center">考えます</td><td align="center">かんがえます</td><td align="center">考える</td><td align="center">かんがえる</td></tr><tr><td align="center">調べます</td><td align="center">しらべます</td><td align="center">調べる</td><td align="center">しらべる</td></tr><tr><td align="center">着ます</td><td align="center">きます</td><td align="center">着る</td><td align="center">きる</td></tr><tr><td align="center">予約します</td><td align="center">よやくします</td><td align="center">予約する</td><td align="center">よやくする</td></tr><tr><td align="center">感謝します</td><td align="center">かんしゃします</td><td align="center">感謝する</td><td align="center">かんしゃする</td></tr><tr><td align="center">運動します</td><td align="center">うんどうします</td><td align="center">運動する</td><td align="center">うんどうする</td></tr><tr><td align="center">洗濯します</td><td align="center">せんたくします</td><td align="center">洗濯する</td><td align="center">せんたくする</td></tr><tr><td align="center">報告します</td><td align="center">ほうこくします</td><td align="center">報告する</td><td align="center">ほうこくする</td></tr></tbody></table></div><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>私は　すき焼（や）きを　食（た）べた　ことが　あります<br>我吃过日式牛肉火锅</p><p>李さんは　会社（かいしゃ）が　終わった　後（あと）で、飲（の）みに　行（い）きます<br>公司下班后，小李去喝酒</p><p>もっと　野菜（やさい）を　食べた　ほうが　いいですよ<br>还是多吃点蔬菜好啊</p><p>窓（まど）を　閉（し）めましょうか<br>把窗户关上吧</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="动词的“た形”"><a href="#动词的“た形”" class="headerlink" title="动词的“た形”"></a>动词的“た形”</h4><p>“た形” 的变换方式是把 “<a href="https://yojayc.github.io/2026/01/26/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D%E5%8F%98%E5%BD%A2/#%E4%B8%89%E7%B1%BB%E5%8A%A8%E8%AF%8D%EF%BC%88%E3%82%AB%E5%8F%98%E3%80%81%E3%82%B5%E5%8F%98%EF%BC%89%E2%80%94%E2%80%94-%E4%B8%8D%E8%A7%84%E5%88%99%E5%8A%A8%E8%AF%8D">て形</a>” 的 “<strong>て</strong>” 换成 “<strong>た</strong>”，“<strong>で</strong>” 换成 “<strong>だ</strong>”</p><h4 id="动（た形）-ことが-あります"><a href="#动（た形）-ことが-あります" class="headerlink" title="动（た形）　ことが　あります"></a>动（た形）　ことが　あります</h4><p>表示过去的经历，用于<strong>至少半年以前</strong>发生的事情</p><p><strong>否定</strong>形式：“<strong>动（た形）+ことが　ありません</strong>”</p><p><strong>疑问</strong>形式：“<strong>动（た形）+ことが　ありますか</strong>”</p><p>强调<strong>完全没有某种经历</strong>时，加“<strong>一度（いちど）も</strong>”</p><p>私は　すき焼きを　食べた　ことが　あります</p><p>北京へ　行（い）った　ことが　ありますか<br>你去过北京吗？<br>ーー　いいえ、一度（いちど）も　行った　ことが　ありません<br>—— 没有，一次也没去过<br>ーー　いいえ、ありません<br>—— 不，没有</p><p>陈小姐在京都工作过吗<br>陳（ちん）さんは　京都で　仕事（しごと）を　した　ことが　ありますか</p><h4 id="动（た形）-後（あと）で、〜"><a href="#动（た形）-後（あと）で、〜" class="headerlink" title="动（た形）　後（あと）で、〜"></a>动（た形）　後（あと）で、〜</h4><p>表示<strong>一个动作在另一个动作之后发生</strong></p><p>会社（かいしゃ）が　終（お）わった　後（あと）で、飲（の）みに　行（い）きます</p><p>映画（えいが）を　見（み）た　後（あと）で、食事（しょくじ）を　しました<br>看完电影后吃了饭</p><p>吃完饭后去散步<br>ご飯（ごはん）を　食べた　後で、散歩します</p><p><strong>也可以以“名词+の+後で”的形式使用</strong></p><p>仕事（しごと）の　後（あと）で、映画（えいが）を　見（み）ます<br>工作之后看电影</p><blockquote><p>〜後　后面必须是“<strong>で</strong>”，前面的动词必须是“<strong>た形</strong>”</p></blockquote><h4 id="动（た形）ほうが-いいです"><a href="#动（た形）ほうが-いいです" class="headerlink" title="动（た形）ほうが　いいです"></a>动（た形）ほうが　いいです</h4><p>表示……<strong>比较好</strong>，用于<strong>在两种事物中进行选择</strong>。建议对方做理想的动作、行为时，句尾加“<strong>よ</strong>”</p><p><strong>否定</strong>形式：“<strong>动词ない形+ほうが　いいです</strong>”</p><p>もっと　野菜（やさい）を　食（た）べた　ほうが　いいですよ</p><p>そんなに　慌（あわ）てない　ほうが　いいですよ<br>别那么慌张啊</p><p>ホテルを　予約（よやく）した　ほうが　いいですか<br>饭店还是先预约为好吗？</p><h4 id="动ましょうか-提议"><a href="#动ましょうか-提议" class="headerlink" title="动ましょうか [提议]"></a>动ましょうか [提议]</h4><p>表示<strong>提议</strong>，翻译时在其后加“好吗？”</p><p>回答时，<strong>同意</strong>用 “お願（ねが）いします”　“はい、そうしましょう”　“いいですね”<br><strong>反对或拒绝</strong>用 “〜ないで　ください”　“いいえ、ちょっと…”</p><p>何（なに）か　食（た）べましょうか<br>吃点什么吗？</p><p>荷物（にもつ）を　持（も）ちましょうか<br>我来帮你拿行李吧？<br>ーー　はい、お願いします<br>—— 好的，拜托你了</p><p>窓（まど）を　閉（し）めましょうか<br>关上窗子好吗？<br>ーー　いいえ、閉（し）めないでください<br>—— 不，请别关</p><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><h4 id="その-ほうが-いいです"><a href="#その-ほうが-いいです" class="headerlink" title="その　ほうが　いいです"></a>その　ほうが　いいです</h4><p>名词及指示事物的词后也可以加 “ほうが　いいです”，表示<strong>比较、选择</strong>的意思</p><p><strong>名词&#x2F;これ&#x2F;それ&#x2F;あれ+の+ほうが　いいです</strong></p><p><strong>この&#x2F;その&#x2F;あの+ほうが　いいです</strong></p><p>口语中<strong>谈到对方的事情</strong>时，用 “<strong>その　ほうが　いいです</strong>” 表示接受对方的建议</p><h4 id="何度（なんど）か"><a href="#何度（なんど）か" class="headerlink" title="何度（なんど）か"></a>何度（なんど）か</h4><p>在<strong>疑问词</strong>“何度（几次）”后加“<strong>か</strong>”，表示“<strong>几次</strong>”，“何人（なんにん）か”　“何冊（なんさつ）か” 类似。</p><p>表示<strong>不定数量</strong>时，日语疑问词后必须加“か”</p><h4 id="九時過（くじす）ぎ"><a href="#九時過（くじす）ぎ" class="headerlink" title="九時過（くじす）ぎ"></a>九時過（くじす）ぎ</h4><p>在时间或年龄词后加 “〜過（す）ぎ” 表示<strong>超过了该时间或年龄</strong></p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第20课</title>
    <link href="/2026/02/07/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC20%E8%AF%BE/"/>
    <url>/2026/02/07/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC20%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第20课史密斯会弹钢琴"><a href="#第20课史密斯会弹钢琴" class="headerlink" title="第20课史密斯会弹钢琴"></a>第20课史密斯会弹钢琴</h2><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">ます形</th><th align="center">假名</th><th align="center">原形</th><th align="center">假名</th></tr></thead><tbody><tr><td align="center">弾きます</td><td align="center">ひきます</td><td align="center">弾く</td><td align="center">ひく</td></tr><tr><td align="center">すきます</td><td align="center">&nbsp;</td><td align="center">すく</td><td align="center">&nbsp;</td></tr><tr><td align="center">登ります</td><td align="center">のぼります</td><td align="center">登る</td><td align="center">のぼる</td></tr><tr><td align="center">集めます</td><td align="center">あつめます</td><td align="center">集める</td><td align="center">あつめる</td></tr><tr><td align="center">浴びます</td><td align="center">あびます</td><td align="center">浴びる</td><td align="center">あびる</td></tr><tr><td align="center">ごちそうします</td><td align="center">&nbsp;</td><td align="center">ごちそうする</td><td align="center">&nbsp;</td></tr><tr><td align="center">帰国します</td><td align="center">きこくします</td><td align="center">帰国する</td><td align="center">きこくする</td></tr></tbody></table></div><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>スミスさんは　ピアノを　弾（ひ）く　ことが　できます<br>史密斯先生会弹钢琴</p><p>私の　趣味（しゅみ）は　切手（きって）を　集（あつ）める　ことです<br>我的爱好是集邮</p><p>こちらへ　来（く）る　前（まえ）に、電話（でんわ）を　かけて　ください<br>你来之前请打个电话</p><p>冬休（ふゆやす）み、どこかへ　行（い）きたいです<br>寒假想去个什么地方。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="动词的基本型"><a href="#动词的基本型" class="headerlink" title="动词的基本型"></a>动词的基本型</h4><p>“基本型&#x2F;原形”是动词的基本形式。词典中的词条都使用这一形式，也叫辞书形</p><h4 id="名-人-は-动（基本形）-ことが-できます"><a href="#名-人-は-动（基本形）-ことが-できます" class="headerlink" title="名[人]は 动（基本形） ことが　できます"></a>名[人]は 动（基本形） ことが　できます</h4><p>“<strong>动（基本形）+ ことが　できます</strong>” 表示<strong>能力</strong>。回答别人的询问时，肯定用“できます”，否定用“できません”</p><p>スミスさんは　ピアノを　弾く　ことが　できます</p><p>森（もり）さんは　中華料理（ちゅうかりょうり）を　作（つく）る　ことが　できますか<br>森先生会做中国菜吗？<br>ーー　はい、できます<br>—— 是的，会做</p><p>小王会写小说<br>王さんは　小説（しょうせつ）を　書く　ことが　できます</p><h4 id="名は-动（基本形）-ことです"><a href="#名は-动（基本形）-ことです" class="headerlink" title="名は 动（基本形）　ことです"></a>名は 动（基本形）　ことです</h4><p>当<strong>谓语部分的内容是一种动作、行为</strong>时使用这个句型</p><blockquote><p>ことです：这件事情</p></blockquote><p>私の　趣味は　切手を　集める　こと　です</p><p>王さんの　特技（とくぎ）は　胡弓（こきゅう）を　弾（ひ）く　こと　です<br>小王的特长是拉胡琴</p><p>森さんの　夢（ゆめ）は　外国（がいこく）で　働（はたら）く　こと　です<br>森先生的理想是在外国工作</p><p>我的梦想是成为老师<br>私の夢は 先生<strong>に なる</strong>　ことです</p><p><strong>动词基本形+こと 可以起到和名词同样的作用</strong></p><p>小野（おの）さんは　車（くるま）<span style="color:red"><strong>を</strong></span>　運転（うんてん）する　こと　が　できません<br>小野不会开车</p><p>小野さんは　車<span style="color:red"><strong>の</strong></span>運転　が　できません<br>小野不会开车</p><h4 id="动（基本形）前（まえ）に、〜"><a href="#动（基本形）前（まえ）に、〜" class="headerlink" title="动（基本形）前（まえ）に、〜"></a>动（基本形）前（まえ）に、〜</h4><p>表示一个动作在另一个动作之前发生</p><p>こちらへ　来る　前に　電話を　かけて　ください</p><p>毎日（まいにち）　寝（ね）る　前に　シャワーを　浴（あ）びます<br>每天睡觉前淋浴</p><p>从公司出发之前，和我说一声<br>会社を　出（で）る　前に、　私<span style="color:red"><strong>に</span>　言って</strong>　ください</p><p><strong>这个句型也可以以“名词+の+前に”的形式使用</strong></p><p>会議（かいぎ）の　前に、資料（しりょう）を　コピーします<br>开会前复印资料</p><h4 id="疑问词-か"><a href="#疑问词-か" class="headerlink" title="疑问词+か"></a>疑问词+か</h4><p>いつ、どこ、だれ　等词后加 <strong>か</strong>，表示“某时”、“某地”、“某人”等意思</p><p>部屋に　だれ<strong>か</strong>　いますか<br>房间里有人吗？</p><p>部屋に　だれ<strong>が</strong>　いますか<br>房间里有谁？</p><p><strong>いつか、どこか、だれか、何（なに）か 等本身并不表示疑问的意思，可用于<span style="color:red">陈述句</span></strong></p><p>冬休み、どこかへ　行きたいです</p><p>おなかが　すきましたね。何（なに）か　食（た）べましょう<br>肚子饿了吧。吃点东西吧</p><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><h4 id="写真（しゃしん）を-撮（と）る-ことが-できます-可能和允许"><a href="#写真（しゃしん）を-撮（と）る-ことが-できます-可能和允许" class="headerlink" title="写真（しゃしん）を　撮（と）る　ことが　できます[可能和允许]"></a>写真（しゃしん）を　撮（と）る　ことが　できます[可能和允许]</h4><p>“<strong>动（基本形）+ ことが　できます</strong>” 基本功能是表示<strong>可能</strong>，根据上下文也表示<strong>允许</strong></p><h4 id="趣味（しゅみ）-和-興味（きょうみ）"><a href="#趣味（しゅみ）-和-興味（きょうみ）" class="headerlink" title="趣味（しゅみ） 和 興味（きょうみ）"></a>趣味（しゅみ） 和 興味（きょうみ）</h4><p>日语 “趣味” 表示 “爱好、喜好”，不是 “兴趣”</p><p>日语 “興味” 表示 “兴趣”</p><h4 id="ごちそうします"><a href="#ごちそうします" class="headerlink" title="ごちそうします"></a>ごちそうします</h4><p>“ごちそう”　表示奢华而高级的菜肴，“ごちそうします” 表示请别人吃饭</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第19课</title>
    <link href="/2026/02/01/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC19%E8%AF%BE/"/>
    <url>/2026/02/01/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC19%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第19课请不要忘记房间的钥匙"><a href="#第19课请不要忘记房间的钥匙" class="headerlink" title="第19课请不要忘记房间的钥匙"></a>第19课请不要忘记房间的钥匙</h2><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">ます形</th><th align="center">假名</th><th align="center">原形</th><th align="center">假名</th></tr></thead><tbody><tr><td align="center">触ります</td><td align="center">さわります</td><td align="center">触る</td><td align="center">さわる</td></tr><tr><td align="center">脱ぎます</td><td align="center">ぬぎます</td><td align="center">脱ぐ</td><td align="center">ぬぐ</td></tr><tr><td align="center">転びます</td><td align="center">ころびます</td><td align="center">転ぶ</td><td align="center">ころぶ</td></tr><tr><td align="center">渇きます</td><td align="center">かわきます</td><td align="center">渇く</td><td align="center">かわく</td></tr><tr><td align="center">治ります</td><td align="center">なおります</td><td align="center">治る</td><td align="center">なおる</td></tr><tr><td align="center">滑ります</td><td align="center">すべります</td><td align="center">滑る</td><td align="center">すべる</td></tr><tr><td align="center">呼びます</td><td align="center">よびます</td><td align="center">呼ぶ</td><td align="center">よぶ</td></tr><tr><td align="center">返します</td><td align="center">かえします</td><td align="center">返す</td><td align="center">かえす</td></tr><tr><td align="center">手伝います</td><td align="center">てつだいます</td><td align="center">手伝う</td><td align="center">てつだう</td></tr><tr><td align="center">運びます</td><td align="center">はこびます</td><td align="center">運ぶ</td><td align="center">はこぶ</td></tr><tr><td align="center">なくします</td><td align="center">&nbsp;</td><td align="center">なくす</td><td align="center">&nbsp;</td></tr><tr><td align="center">落とします</td><td align="center">おとします</td><td align="center">落とす</td><td align="center">おとす</td></tr><tr><td align="center">置きます</td><td align="center">おきます</td><td align="center">置く</td><td align="center">おく</td></tr><tr><td align="center">払います</td><td align="center">はらいます</td><td align="center">払う</td><td align="center">はらう</td></tr><tr><td align="center">立ちます</td><td align="center">たちます</td><td align="center">立つ</td><td align="center">たつ</td></tr><tr><td align="center">忘れます</td><td align="center">わすれます</td><td align="center">忘れる</td><td align="center">わすれる</td></tr><tr><td align="center">慌てます</td><td align="center">あわてます</td><td align="center">慌てる</td><td align="center">あわてる</td></tr><tr><td align="center">捨てます</td><td align="center">すてます</td><td align="center">捨てる</td><td align="center">すてる</td></tr><tr><td align="center">残業します</td><td align="center">ざんぎょうします</td><td align="center">残業する</td><td align="center">ざんぎょうする</td></tr><tr><td align="center">心配します</td><td align="center">しんぱいします</td><td align="center">心配する</td><td align="center">しんぱいする</td></tr></tbody></table></div><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>部屋（へや）の　かぎを　忘（わす）れないで　ください<br>请别忘了房间钥匙</p><p>李（り）さんは　今日（きょう）　早（はや）く　帰（かえ）らなければ　なりません<br>小李今天必须早点回家</p><p>明日（あした）は　残業（ざんぎょう）しなくても　いいですよ<br>明天不加班也行</p><p>あの　人（ひと）が　吉田課長（よしだかちょう）ですよ<br>他就是吉田科长</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="动词的“ない形”"><a href="#动词的“ない形”" class="headerlink" title="动词的“ない形”"></a>动词的“ない形”</h4><p>由<strong>动词原形</strong>变为<strong>未然形</strong>，再变为<strong>ない形</strong></p><p><strong>未然形规则</strong>：</p><ul><li><p>一类动词 <strong>同行的う段</strong>变为<strong>同行的あ段</strong>，特例　<strong><span style="color:red">うーわ</span></strong></p></li><li><p>二类动词 <strong>去掉る</strong></p></li><li><p>三类动词 <strong>来（く）るーこ、するー<span style="color:red">し、せ、さ</span></strong></p></li></ul><table align="center"><tbody align="center" valign="center"><tr><th>类别</th><th colspan=2>原形</th><th>ます形</th><th>たい形</th></tr><tr><th rowspan=9>一类动词</th><td>書く</td><td>か<span style="color:red">く</span></td><td>かきます</td><td>か<span style="color:red">か</span>ない</td></tr><tr><td>急ぐ</td><td>いそ<span style="color:red">ぐ</span></td><td>いそぎます</td><td>いそ<span style="color:red">が</span>ない</td></tr><tr><td>飛ぶ</td><td>と<span style="color:red">ぶ</span></td><td>とびます</td><td>と<span style="color:red">ば</span>ない</td></tr><tr><td>読む</td><td>よ<span style="color:red">む</span></td><td>よみます</td><td>よ<span style="color:red">ま</span>ない</td></tr><tr><td>死ぬ</td><td>し<span style="color:red">ぬ</span></td><td>しにます</td><td>し<span style="color:red">な</span>ない</td></tr><tr><td>待つ</td><td>ま<span style="color:red">つ</span></td><td>まちます</td><td>ま<span style="color:red">た</span>ない</td></tr><tr><td>売る</td><td>う<span style="color:red">る</span></td><td>うります</td><td>う<span style="color:red">ら</span>ない</td></tr><tr><td>買う</td><td>か<span style="color:red">う</span></td><td>かいます</td><td>か<span style="color:red">わ</span>ない</td></tr><tr><td>話す</td><td>はな<span style="color:red">す</span></td><td>はなします</td><td>はな<span style="color:red">さ</span>ない</td></tr><tr><th rowspan=2>二类动词</th><td>食べる</td><td>たべる</td><td>たべます</td><td>たべない</td></tr><tr><td>見る</td><td>みる</td><td>みます</td><td>みない</td></tr><tr><th rowspan=2>三类动词</th><td>来る</td><td><span style="color:red">くる</span></td><td>きます</td><td><span style="color:red">こ</span>ない</td></tr><tr><td>する</td><td><span style="color:red">する</span></td><td>します</td><td><span style="color:red">し</span>ない</td></tr></tbody></table><h4 id="动ないで-ください"><a href="#动ないで-ください" class="headerlink" title="动ないで　ください"></a>动ないで　ください</h4><p>表示<strong>否定的命令</strong>，使用“〜て　ください”的否定形式“<strong>ない形（未然形+ない）でください</strong>”</p><p>部屋の　かぎを　忘れないで　ください　（忘れる　ー　忘れ　ないでください）</p><p>この　部屋（へや）には　入（はい）らないで　ください（入る　ー　入ら　ないでください）<br>请不要进入这个房间</p><p>無理（むり）を　し　ないで　ください（する　ー　し　ないでください）<br>请不要勉强　</p><p>请不要在房间里吃饭<br>部屋で　食事（しょくじ）を　しないでください<br>部屋の中（なか）で、ご飯（はん）を　食べないでください</p><h4 id="动词未然形-なければ-なりません"><a href="#动词未然形-なければ-なりません" class="headerlink" title="动词未然形+なければ　なりません"></a>动词未然形+なければ　なりません</h4><p>表示<span style="color:red"><strong>必须</strong></span>，可以用“<strong>ないと　いけません</strong>”代替“<strong>なければ　なりません</strong>”</p><p>李さんは　今日　早く　帰ら　なければ　なりません</p><p>この　薬（くすり）は　毎日（まいにち）　飲（の）ま　なければ　なりません<br>这个药必须每天吃</p><p>すぐに　書類（しょるい）を　送（おく）ら　ないと　いけません<br>得马上把文件寄出去</p><p>我必须写作业<br>私は　宿題（しゅくだい）を　書か　なければ　なりません（書く　ー　かか）</p><h4 id="未然形-なくても-いいです"><a href="#未然形-なくても-いいです" class="headerlink" title="未然形+なくても　いいです"></a>未然形+なくても　いいです</h4><p>表示<strong>不做某事也可以</strong>，相当于“～なければ　なりません”的否定</p><p>明日は　残業し　なくても　いいです</p><p>慌（あわ）て　なくても　いいですよ<br>不要慌慌张张的！</p><p>靴（くつ）を　脱（ぬ）がなくても　いいですか（脱ぐ　ー　脱が）<br>不脱鞋也可以吗？</p><p>明天不用运动<br>明日、運動（うんどう）　しなくても　いいです</p><h4 id="名1が-名2です"><a href="#名1が-名2です" class="headerlink" title="名1が 名2です"></a>名1が 名2です</h4><p>用 “<strong>[名词2]は [名词1]です</strong>” 表示 <strong>[名词2] 是什么</strong>。其中，[名词2] 是旧信息，[名词1] 是新信息</p><p>也可以用“<strong>[名词1]が [名词2]です</strong>”来表示，新信息做主语时用“<strong>が</strong>”来表示</p><p>山田（やまだ）先生（せんせい）は　どの　方（かた）ですか<br>山田老师是哪位？<br>ーー　山田先生は　あの　方です<br>—— 山田老师是那位<br>ーー　あの　方<strong>が</strong>　山田先生です<br>—— 那位是山田老师</p><p>吉田課長（よしだかちょう）は　いますか<br>吉田科长在吗？<br>ーー　私が　吉田ですが（吉田は　私です）<br>—— 我就是吉田</p><p>あなたの　かばんは　どれですか<br>你的包是哪一个？<br>ーー　これが　私の　かばんです<br>—— 这个是我的包</p><p><strong>叙述直接观察到的事物（眼前看到的现象），使用[名词]<span style="color:red">が</span>[动词]的形式</strong></p><p>子供（こども）が　公園（こうえん）で　遊（あそ）んで　います<br>孩子在公园里玩儿</p><p>バスが　来（き）ました<br>公共汽车来了</p><p>母：バスは　まだ来（き）ませんか（バス 只是一个话题）<br>娘（むすめ）：あっ、バス<span style="color:red"><strong>が</strong></span>　来ました（眼前看到了バス）</p><p><strong>何（なに）、だれ、どこ、いつ等<span style="color:red">表示疑问的词做主语</span>时不能用“は”，只能用“が”</strong></p><p>だれが　いますか<br>有谁呀？</p><p>どこが　痛（いた）いですか<br>哪儿疼啊？</p><p>何（なに）が　好（す）きですか<br>喜欢什么？</p><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><h4 id="“〜なければ-なりません”-和-“〜ないと-いけません”"><a href="#“〜なければ-なりません”-和-“〜ないと-いけません”" class="headerlink" title="“〜なければ　なりません”　和 “〜ないと　いけません”"></a>“〜なければ　なりません”　和 “〜ないと　いけません”</h4><p>两者都表示<strong>义务、必要性</strong>的说法。“〜なければ　なりません” 更正式，多用于<strong>书面语</strong>，“〜ないと　いけません”及其省略形式“〜ないと”主要用于<strong>口语</strong></p><p>子供（こども）は　六歳（ろくさい）から　学校（がっこう）へ　行（い）かなければ　なりません<br>从6岁起，孩子必须上学</p><p>あっ、８時（はちじ）ですね。もう　駅（えき）へ　行（い）かないと<br>啊，8点了，我得去车站了</p><h4 id="初心者（しょしんしゃ）上級者（じょうきゅうしゃ）"><a href="#初心者（しょしんしゃ）上級者（じょうきゅうしゃ）" class="headerlink" title="初心者（しょしんしゃ）上級者（じょうきゅうしゃ）"></a>初心者（しょしんしゃ）上級者（じょうきゅうしゃ）</h4><p>表示<strong>技能的等级</strong>时，日语中不说“高級（こうきゅう）”而说“上級（じょうきゅう）”</p><p>“高級”只表示<strong>高质量的物品</strong></p><p>森（もり）さん、英会話（えいかいわ）の　勉強（べんきょう）は　どうですか<br>森先生，英语会话学得怎么样了？<br>ーー　やっと　先月（せんげつ）　上級（じょうきゅう）クラスに　入（はい）りました<br>—— 上个月，好不容易进了高级班</p><h4 id="何度（なんど）も"><a href="#何度（なんど）も" class="headerlink" title="何度（なんど）も"></a>何度（なんど）も</h4><p><strong>“何（なん）+量词+も+肯定形式”表示数量多</strong></p><p>何度も　転（ころ）びましたが、とても　おもしろいです<br>我摔了好几次，不过挺有意思的</p><p>のどが　渇（かわ）きましたから、水（みず）を　何杯（なんばい）も　飲（の）みました<br>口渴了，喝了好几杯水</p><h4 id="だいぶ"><a href="#だいぶ" class="headerlink" title="だいぶ"></a>だいぶ</h4><p>だいぶ 表示<strong>程度高</strong></p><p>昨日（きのう）は　だいぶ　お酒（さけ）を　飲（の）みました<br>昨天喝了不少酒</p><p>風邪（かぜ）は　よく　なりましたか<br>感冒好了吗？<br>ーー　だいぶ　よく　なりました<br>—— 好多了</p><h4 id="大丈夫（だいじょうぶ）です"><a href="#大丈夫（だいじょうぶ）です" class="headerlink" title="大丈夫（だいじょうぶ）です"></a>大丈夫（だいじょうぶ）です</h4><p>大丈夫　表示“<strong>没问题、可以</strong>”</p><p>上級者（じょうきゅうしゃ）の　コースには　入（はい）らないで　ください<br>注意别滑进熟练者滑道里去<br>ーー　大丈夫です。心配（しんぱい）しないで　ください<br>—— 我保证不进去，请别担心</p><p>田中（たなか）さん、病気（びょうき）は　もう　治（なお）りましたか<br>田中先生，病好了吗？<br>ーー　はい、もう　大丈夫です<br>—— 嗯，已经不要紧了</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第18课</title>
    <link href="/2026/01/31/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC18%E8%AF%BE/"/>
    <url>/2026/01/31/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC18%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第18课手机变小了"><a href="#第18课手机变小了" class="headerlink" title="第18课手机变小了"></a>第18课手机变小了</h2><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">ます形</th><th align="center">假名</th><th align="center">原形</th><th align="center">假名</th></tr></thead><tbody><tr><td align="center">なります</td><td align="center">&nbsp;</td><td align="center">なる</td><td align="center">&nbsp;</td></tr><tr><td align="center">開きます</td><td align="center">あきます</td><td align="center">開く</td><td align="center">あく</td></tr><tr><td align="center">似合います</td><td align="center">にあいます</td><td align="center">似合う</td><td align="center">にあう</td></tr></tbody></table></div><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>携帯電話（けいたいでんわ）は　とても　小（ちい）さく　なりました<br>手机变小了</p><p>テレビの　音（おと）を　大（おお）きく　します<br>把电视机的声音开大一点儿</p><p>息子（むすこ）は　医者（いしゃ）に　なりました<br>儿子当医生了</p><p>部屋（へや）を　きれいに　して　ください<br>请把房间打扫干净</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="一类形-なります"><a href="#一类形-なります" class="headerlink" title="一类形 なります"></a>一类形 なります</h4><p>なります 表示<strong>自然地成为……、变得……</strong>[自动词　<strong>が</strong>]</p><p>一类形容词+なります 表示<strong>性质或状态的变化</strong>，把一类形容词词尾“<strong>い”变为“く”，再加“なります”</strong></p><div class="center"><table><thead><tr><th align="center">一类形容词</th><th align="center">〜く　なります</th></tr></thead><tbody><tr><td align="center">暖（あたた）かい</td><td align="center">暖かく　なります</td></tr><tr><td align="center">小（ちい）さい</td><td align="center">小さく　なります</td></tr><tr><td align="center">安（やす）い</td><td align="center">安く　なります</td></tr></tbody></table></div><p>だんだん　暖かく　なります<br>天气渐渐转暖（だんだん：渐渐）</p><p>携帯電話は　小さく　なりました</p><p>パソコンは　安く　なりました<br>个人电脑便宜了</p><p>天变暗了<br>暗（くら）く　なりました</p><p>暗（くら）い</p><blockquote><p>ました 表示<strong>变……了</strong></p><p>ます 表示<strong>还没有变</strong>，现在的状态</p></blockquote><h4 id="一类形-します"><a href="#一类形-します" class="headerlink" title="一类形 します"></a>一类形 します</h4><p>します 表示<strong>人为的</strong>[他动词　<strong>を</strong>]</p><p>一类形容词+します 表示<strong>因主语的意志性动作、作用而引起事物发生变化的场合</strong></p><div class="center"><table><thead><tr><th align="center">一类形容词</th><th align="center">〜く　します</th></tr></thead><tbody><tr><td align="center">大（おお）きい</td><td align="center">大きく　します</td></tr><tr><td align="center">冷（つめ）たい</td><td align="center">冷たく　します</td></tr></tbody></table></div><p>テレビの　音を　大きく　します</p><p>ジュースを　冷たくします<br>把果汁冰镇一下</p><p>小王把电视机声音开大了<br>王さんは　テレビの　音を　大きくしました</p><h4 id="二类形-名-に-なります"><a href="#二类形-名-に-なります" class="headerlink" title="二类形&#x2F;名 に　なります"></a>二类形&#x2F;名 に　なります</h4><p>二类形容词&#x2F;名词+<strong>に</strong>　なります 也表示<strong>性质或状态的变化</strong></p><div class="center"><table><thead><tr><th align="center">二类形容词&#x2F;名词</th><th align="center">〜に　なります</th></tr></thead><tbody><tr><td align="center">元気（げんき）</td><td align="center">元気に　なります</td></tr><tr><td align="center">医者（いしゃ）</td><td align="center">医者に　なります</td></tr></tbody></table></div><p>もう　元気　に　なりました<br>已经恢复健康了</p><p>息子は　医者　に　なりました</p><p>来年（らいねん）　社会人（しゃかいじん）　に　なります<br>明年将成为社会的一员</p><h4 id="二类形容词-名-に-します"><a href="#二类形容词-名-に-します" class="headerlink" title="二类形容词&#x2F;名 に します"></a>二类形容词&#x2F;名 に します</h4><p>二类形容词&#x2F;名词+<strong>に</strong>　します 也表示<strong>因主语的意志性的动作、作用等引起事物发生变化</strong></p><div class="center"><table><thead><tr><th align="center">二类形容词&#x2F;名词</th><th align="center">〜に　します</th></tr></thead><tbody><tr><td align="center">きれい</td><td align="center">きれいに　します</td></tr><tr><td align="center">禁煙（きんえん）</td><td align="center">禁煙に　します</td></tr></tbody></table></div><p>部屋を　きれい　に　して　ください</p><p>会議室（かいぎしつ）を　禁煙　に　します<br>会议室里禁烟</p><p>在<strong>餐馆点餐</strong>也可以用“〜に　します”，表示把自己决定的事情告诉对方</p><p>かれーに　します<br>我要咖喱饭</p><p>コーヒーに　します<br>我要咖啡</p><blockquote><p>暑い暑くなる（表示<strong>自然</strong>的变化）暑くする（表示<strong>人为</strong>的变化）</p><p>最近、暑くなりましたね 最近，天气变热了</p><p>部屋を　暑くしました　房间变热了（开空调）</p></blockquote><h4 id="一类形-二类形-ほうが-いいです"><a href="#一类形-二类形-ほうが-いいです" class="headerlink" title="一类形&#x2F;二类形 ほうが　いいです"></a>一类形&#x2F;二类形 ほうが　いいです</h4><p>一类形容词+ほうが　いいです</p><p>二类形容词+<strong>な</strong>+ほうが　いいです</p><p><strong>比较两个以上事物的性质，认为其中一个比较好</strong>，表示自己的选择或向别人提议</p><p>旅行（りょこう）の　荷物（にもつ）は　軽（かる）い　ほうが　いいです<br>旅行行李还是轻点儿好</p><p>部屋は　広（ひろ）い　ほうが　いいです<br>房间还是宽敞一点儿好</p><p>子供（こども）は　元気（げんき）　な　ほうが　いいです<br>孩子还是精神一点儿好</p><p>公園（こうえん）は　静（しず）か　な　ほうが　いいです<br>公园还是安静一点儿好</p><p>川菜还是辣点好<br>四川料理（しせんりょうり）は　辛い　ほうが　いいです</p><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><h4 id="音（おと）和声（こえ）"><a href="#音（おと）和声（こえ）" class="headerlink" title="音（おと）和声（こえ）"></a>音（おと）和声（こえ）</h4><p>音指<strong>物体</strong>的声音</p><p>声指<strong>人和动物</strong>的声音</p><h4 id="まとめて"><a href="#まとめて" class="headerlink" title="まとめて"></a>まとめて</h4><p>まとめます（汇总）表示把若干个汇总在一起</p><h4 id="３割引（さんわりびき）"><a href="#３割引（さんわりびき）" class="headerlink" title="３割引（さんわりびき）"></a>３割引（さんわりびき）</h4><p>３割引相当于汉语“七折”</p><p>15%引（じゅうごバーセントびき）　表示“八五折”</p><p>半額（はんがく）表示“五折”</p><h4 id="似合（にあ）います"><a href="#似合（にあ）います" class="headerlink" title="似合（にあ）います"></a>似合（にあ）います</h4><p>似合います 表示“相称、适合”</p><p><strong>[人]は　[物]が　似合います</strong></p><p><strong>[物]は　[人]に　似合います</strong></p><ul><li><p>赤（あか）い　ほうが　いいですね。よく　似合います　よ 红的好吧，很适合你</p></li><li><p>李さん<strong>は</strong>　赤いの<strong>が</strong>　よく　似合います 对小李来说红的相称</p></li></ul><p>小野（おの）さん<strong>は</strong>　浴衣（ゆかた）<strong>が</strong>　似合います<br>小野女士穿浴衣很相称</p><p>この　シャツ<strong>は</strong>　父（ちち）<strong>に</strong>　似合いません。派手（はで）ですよ<br>这件衬衫不适合爸爸穿，太花哨</p><h4 id="間（ま）もなく-和-もう-すく"><a href="#間（ま）もなく-和-もう-すく" class="headerlink" title="間（ま）もなく　和　もう　すく"></a>間（ま）もなく　和　もう　すく</h4><p>間もなく　和　もう　すく 都表示“一会儿、不久”。“間もなく” 用于<strong>书面</strong>，语气生硬。“もう　すく” 多用于<strong>口语</strong></p><h4 id="さらに-和-もっと"><a href="#さらに-和-もっと" class="headerlink" title="さらに 和 もっと"></a>さらに 和 もっと</h4><p>さらに 和 もっと 都表示“<strong>更加</strong>”。“さらに” 较郑重， “もっと” 较随便</p><h4 id="さあ"><a href="#さあ" class="headerlink" title="さあ"></a>さあ</h4><p>用于向对方提出建议或促使对方做某事，<strong>只用于口语</strong></p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第17课</title>
    <link href="/2026/01/30/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC17%E8%AF%BE/"/>
    <url>/2026/01/30/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC17%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第17课我想有套新西服"><a href="#第17课我想有套新西服" class="headerlink" title="第17课我想有套新西服"></a>第17课我想有套新西服</h2><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">ます形</th><th align="center">假名</th><th align="center">原形</th><th align="center">假名</th></tr></thead><tbody><tr><td align="center">始めます</td><td align="center">はじめます</td><td align="center">始める</td><td align="center">はじめる</td></tr><tr><td align="center">連絡します</td><td align="center">れんらくします</td><td align="center">連絡する</td><td align="center">れんらくする</td></tr></tbody></table></div><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>私は　新（あたら）しい　洋服（ようふく）が　欲（ほ）しいです<br>我想有套新西服</p><p>私は　映画（えいが）を　見（み）たいです<br>我想看电影</p><p>いっしょに　お茶（ちゃ）を　飲（の）みませんが<br>一起喝茶好吗？</p><p>ちょっと　休（やす）みましょう<br>休息一下吧！</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="名が-欲しいです"><a href="#名が-欲しいです" class="headerlink" title="名が　欲しいです"></a>名<span style="color:red">が</span>　欲しいです</h4><p><strong>[名1]は [名2]が　欲しいです</strong> 表示<strong>想得到什么</strong>，[名1]是愿望的主体，[名2]是愿望的对象</p><p>私は　新しい　洋服　が　欲しいです</p><p>（あなたは）　何（なに）　が　欲しいですか你想要什么？<br>ーー　新しい　パソコン　が　欲しいです想要新的电脑</p><p>何（なに）　が　欲しいですか 不能对长辈使用</p><blockquote><p>欲しい　前面的助词只能是 <strong>が</strong></p></blockquote><h4 id="名を-动たいです-（动词ます形去掉ます再加たい）"><a href="#名を-动たいです-（动词ます形去掉ます再加たい）" class="headerlink" title="名を　动たいです （动词ます形去掉ます再加たい）"></a>名を　<span style="color:red">动たい</span>です （动词ます形去掉ます再加たい）</h4><p><strong>[名1]は [名2]を　〜たいです</strong> 表示“想～”，[名1]是愿望的主体，[名2]是愿望的对象</p><p>（私は）　映画を　見たいです</p><p>今日（きょう）は　お酒（さけ）を　飲（の）みたくないです<br>今天不想喝酒</p><p>（あなたは）　何（なに）を　したいですか你想做什么？<br>ーー　何（なに）　も　したく　ありません什么都不想做</p><p>我想去公园　行く　ー　行きます　ー　行きたい<br>私は　公園（こうえん）へ　行きたいです</p><p>飲む　ー　飲みます　ー　飲みたい　飲みたくない</p><p>見る　ー　見ます　ー　見たい　見たくない</p><p>する　ー　します　ー　したい　したくない</p><blockquote><p>たい　主语一般都是自己 私，不能是别人</p><p>疑问句 “何を　したいですか” 主语是你</p><p>第三人称不能用 たい</p><p>たい　的对象能用“を”和“が”　表示</p></blockquote><p>だれ<strong>に</strong>　会（あ）いたいですか你想见谁？<br>ーー　<strong>だれにも</strong>　会い<strong>たくない</strong>です谁也不想见</p><p>会う　ー　会います　ー　会いたい　会いたくない</p><p>だれと　食べたいですか你想和谁吃饭？<br>ーー　だれ<strong>とも</strong>　食べたくないです谁都不想</p><p>どこから　行きたいですか　你想从哪出发？<br>ーー　どこからも　行きたくないです哪儿都不想去</p><blockquote><p>用 “名词+に、から、と＋动词” 提问<br><strong>全盘否定</strong>回答 “にも、からも、とも＋动词否定”</p></blockquote><p>どこ<strong>へ</strong>　行きたいですか你想去哪儿？<br>ーー　<strong>どこへも&#x2F;どこも</strong>　行き<strong>たくない</strong>です哪儿也不想去</p><blockquote><p>用 “名词+へ+动词” 提问<br>全盘否定回答 “へも、も+动词否定”</p></blockquote><h4 id="动ませんか"><a href="#动ませんか" class="headerlink" title="动ませんか"></a>动ませんか</h4><p>表示<strong>提议</strong>，比较礼貌</p><p>いっしょに　お茶を　飲みませんか</p><p>少（すこ）し　休（やす）みませんか<br>休息一下怎么样？</p><p>明日（あした）　こきゅう（故宫）へ　行きませんか<br>明天去故宫怎么样？</p><p>我们在家休息怎么样？<br>家で　休みませんか（名[场所]で　动，表示在某地做某事）</p><h4 id="动ましょう"><a href="#动ましょう" class="headerlink" title="动ましょう"></a>动ましょう</h4><p>也表示<strong>提议</strong>，偏口语</p><p>ちょっと　休みましょう</p><p>そろそろ　行きましょう<br>咱们快走吧</p><p>いっしょに　お茶を　飲みましょう<br>一起喝茶吧</p><p>我们看电视吧<br>いっしょに　テレビを　見ましょう</p><h4 id="疑问词-でも"><a href="#疑问词-でも" class="headerlink" title="疑问词+でも"></a>疑问词+でも</h4><p>表示在任何情况下<strong>事态都相同</strong></p><p>李さん　何（なに）を　食べたいですか小李，你想吃什么<br>ーー　<strong>何（なん）でも</strong>　いいです什么都行</p><p><strong>いつでも</strong>　電話（でんわ）を　して　ください<br>请你随时打电话</p><p><strong>だれでも</strong>　分（わ）かります<br>谁都明白</p><p>这道题谁都可以写出来<br>この　問題（もんだい）は　だれでも　書（か）けます&#x2F;できます</p><h4 id="ね"><a href="#ね" class="headerlink" title="ね"></a>ね</h4><p>ね　除了表示确认，也有<strong>舒缓自己的心情或想法并将之传达给对方</strong>的用法</p><p>日本料理（にほんりょうり）で　何（なに）が　いちばん　好（す）きですか<br>你最喜欢吃什么日本菜？<br>ーー　そうですね。やっぱり　お寿司（すし）です<strong>ね</strong><br>—— 嗯……还是最喜欢寿司</p><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><h4 id="欲しいです-和-飲みませんか"><a href="#欲しいです-和-飲みませんか" class="headerlink" title="欲しいです　和　飲みませんか"></a>欲しいです　和　飲みませんか</h4><p>“何（なに）が　欲（ほ）しいですか” “何を　食（た）べたいですか”　可用于<strong>朋友之间、父母对孩子、学校的教师对学生等</strong>。对<strong>长辈、上级及不太熟的人</strong>说话时，应使用“<strong>どうですか</strong>”　“<strong>〜ませんか</strong>”等</p><p>デパートへ　買（か）い物（もの）に　行（い）きます。李さんも　いっしょに　<strong>どうですか</strong><br>我去百货商店买东西，小李也一起去怎么样？<br>ーー　はい、<strong>行きたいですか</strong><br>—— 好的，我也想去</p><p>コンサートへ　<strong>行きませんか</strong><br>去听音乐会好吗？<br>ーー　いいですね。<strong>行きましょう</strong><br>—— 好啊，去吧</p><blockquote><p>〜ましょう　有<strong>一起、共同做某事</strong>的含义，即可用于提议，也可用于对别人提议的回答</p></blockquote><h4 id="今年中（ことしじゅう）に"><a href="#今年中（ことしじゅう）に" class="headerlink" title="今年中（ことしじゅう）に"></a>今年中（ことしじゅう）に</h4><p>“〜中（じゅう&#x2F;ちゅう）に”　表示<strong>该期间结束之前</strong></p><ul><li><p>今日（きょう）、明日（あした）、今年（ことし）后接 “〜中（<strong>じゅう</strong>）に”</p></li><li><p>週、月（がつ&#x2F;げつ）后接 “〜中（<strong>ちゅう</strong>）に”</p></li></ul><p>今年中（ことし<strong>じゅう</strong>）に　結婚（けっこん）したいです<br>我想今年结婚</p><p>この　仕事（しごと）は　今日中（きょう<strong>じゅう</strong>）に　終（お）わります<br>这项工作在今天之内做完</p><p>来週中（らいしゅう<strong>ちゅう</strong>）に　もう　一度（いちど）　連絡（れんらく）します<br>下星期再联系</p><h4 id="ぜひ"><a href="#ぜひ" class="headerlink" title="ぜひ"></a>ぜひ</h4><p>表示“<strong>一定、必定</strong>”，后接 “〜たい” “〜てください” “〜ましょう” 等，表达<strong>强烈愿望、意志、提议</strong></p><p>お汁粉（しるこ）　ぜひ　食（た）べたいです<br>年糕小豆汤？真想尝一尝</p><p>今度（こんど）　ぜひ　家（いえ）へ　遊（あそ）びに　来（き）て　ください<br>下次请一定来我家玩</p><h4 id="初詣（はつもうで）"><a href="#初詣（はつもうで）" class="headerlink" title="初詣（はつもうで）"></a>初詣（はつもうで）</h4><p>日本阳历新年。1月1日至3日称为“三（さん）が日（にち）”，有去神社、寺庙参拜的习俗</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第16课</title>
    <link href="/2026/01/29/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC16%E8%AF%BE/"/>
    <url>/2026/01/29/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC16%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第16课宾馆的房间又宽敞又明亮"><a href="#第16课宾馆的房间又宽敞又明亮" class="headerlink" title="第16课宾馆的房间又宽敞又明亮"></a>第16课宾馆的房间又宽敞又明亮</h2><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">ます形</th><th align="center">假名</th><th align="center">原形</th><th align="center">假名</th></tr></thead><tbody><tr><td align="center">持ちます</td><td align="center">もちます</td><td align="center">持つ</td><td align="center">もつ</td></tr><tr><td align="center">住みます</td><td align="center">すみます</td><td align="center">住む</td><td align="center">すむ</td></tr><tr><td align="center">知ります</td><td align="center">しります</td><td align="center">知る</td><td align="center">しる</td></tr><tr><td align="center">直します</td><td align="center">なおします</td><td align="center">直す</td><td align="center">なおす</td></tr><tr><td align="center">片づけます</td><td align="center">かたずけます</td><td align="center">片づける</td><td align="center">かたずける</td></tr><tr><td align="center">練習します</td><td align="center">れんしゅうします</td><td align="center">練習する</td><td align="center">れんしゅうする</td></tr><tr><td align="center">結婚します</td><td align="center">けっこんします</td><td align="center">結婚する</td><td align="center">けっこんする</td></tr><tr><td align="center">安心します</td><td align="center">あんしんします</td><td align="center">安心する</td><td align="center">あんしんする</td></tr></tbody></table></div><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>ホテルの　部屋（へや）は　広（ひろ）くて　明（あか）るいです<br>宾馆的房间又宽敞又明亮</p><p>この　コンピュータの　操作（そうさ）は　簡単（かんたん）で　便利（べんり）です<br>这台电脑用起来既简单又方便</p><p>森（もり）さんは　車（くるま）を　持（も）って　います<br>森先生有辆车</p><p>３（さん）か月（げつ）　パソコンを　練習（れんしゅう）しましたが、まだ　あまり　できません<br>我学了三个月电脑，但还不太会用（<strong>が表示转折</strong>）</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="一类形-て-一类形-并列"><a href="#一类形-て-一类形-并列" class="headerlink" title="一类形 て 一类形[并列]"></a>一类形 て 一类形[并列]</h4><p>两个以上一类形容词并列使用时，使用一类形容词的て形</p><p>一类形容词的“て形”<strong>将词尾<span style="color:red">“い”变为“くて</span>”</strong></p><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">一类形容词</th><th align="center">假名</th><th align="center">て形</th></tr></thead><tbody><tr><td align="center">明るい</td><td align="center">あかるい</td><td align="center">明るくて</td></tr><tr><td align="center">新しい</td><td align="center">あたらしい</td><td align="center">新しくて</td></tr><tr><td align="center"><strong>いい</strong></td><td align="center">&nbsp;</td><td align="center"><span style="color:red"><strong>よくて</strong></span></td></tr></tbody></table></div><p>ホテルの　部屋は　広くて　明るいです</p><p>この　本（ほん）は　安（やす）くて　おもしろいです<br>这本书又便宜又有意思</p><p>この　リンゴは　大（おお）きくて、甘（あま）くて、おいしいです<br>这个苹果又大又甜，很好吃</p><p>这个蛋糕又大又甜<br>このケーキは　大きくて　甘いです</p><h4 id="二类形-で-二类形-并列"><a href="#二类形-で-二类形-并列" class="headerlink" title="二类形 で 二类形[并列]"></a>二类形 で 二类形[并列]</h4><p>两个以上二类形容词并列使用时，使用二类形容词的て形</p><p>二类形容词的“て形”是<strong>二类形容词+<span style="color:red">で</span>”</strong></p><div class="center"><table><thead><tr><th align="center">二类形容词</th><th align="center">假名</th><th align="center">て形</th></tr></thead><tbody><tr><td align="center">簡単</td><td align="center">かんたん</td><td align="center">簡単で</td></tr><tr><td align="center">親切</td><td align="center">しんせつ</td><td align="center">親切で</td></tr><tr><td align="center">にぎやが</td><td align="center">&nbsp;</td><td align="center">にぎやがで</td></tr></tbody></table></div><p>この　コンピュータの　操作は　簡単　で　便利です</p><p>森さんは　親切（しんせつ）　で　優（やさ）しいです<br>森先生为人热情而和蔼</p><p>この　公園（こうえん）は　静（しず）か　で　広（ひろ）いです<br>这个公园安静而宽敞</p><p>这里又方便又热闹<br>ここは　便利（べんり）　で　にぎやがです</p><h4 id="名1-で-名2-并列"><a href="#名1-で-名2-并列" class="headerlink" title="名1 で 名2[并列]"></a>名1 <span style="color:red">で</span> 名2[并列]</h4><p>两个以上的名词并列使用格式</p><p>スミスさんは　旅行会社（りょこうがいしゃ）の　社員（しゃいん）　で　営業部（えいぎょうぶ）の　部長（ぶちょう）です<br>史密斯先生是旅行社的职员，营业部部长</p><p>この　機械（きかい）は　日中電気（にっちゅうでんき）の　製品（せいひん）　で　中国製（ちゅごくせい）です<br>这台机器是日中电器公司的产品，是中国制造的</p><p>小李是中国人，是北京大学的学生<br>李さんは　中国人（ちゅうごくじん）　で　北京大学（ペキンだいがく）の　学生（がくせい）です</p><h4 id="动て-います-结果状态"><a href="#动て-います-结果状态" class="headerlink" title="动て　います　[结果状态]"></a>动て　います　[结果状态]</h4><p>动て　います 除了表示<strong>正在进行</strong>之外，还能表示<span style="color:red"><strong>动作结束后留下的结果状态</strong></span></p><p>森さんは　車を　持って　います</p><p>私は　北京（ペキン）に　住（す）んで　います<br>我住在北京</p><p>田中（たなか）さんを　知（し）って　いますか<br>认识田中先生吗？</p><p>車を　持って　いますか有车吗？<br>ーー　いいえ、持って　いません不，没有</p><p>田中さんを　知って　いますか<br>ーー　いいえ、<strong>知りません</strong> 不，不认识</p><blockquote><p>不能回答 “知って　いません”</p></blockquote><h4 id="小句-が-小句-转折"><a href="#小句-が-小句-转折" class="headerlink" title="小句 が 小句[转折]"></a>小句 が 小句[转折]</h4><p><strong>が</strong> 表示两个小句的<strong>转折</strong>关系，相当于“但是、可是”</p><p>３か月　パソコンを　勉強（べんきょう）しました　が、まだ　あまり　できません</p><p>この　レストランを　おいしいです　が、ちょっと　高（たか）いです<br>这家餐厅的饭菜好吃，但是有点贵</p><p>佐藤很漂亮，但是性格不好<br>佐藤（さとう）さんは　きれいです　が　性格（せいかく）は　悪（わる）いです</p><h4 id="まだ-动词（否定）"><a href="#まだ-动词（否定）" class="headerlink" title="まだ　动词（否定）"></a>まだ　动词（<span style="color:red">否定</span>）</h4><p>表示还没达到所询问的内容的程度，相当于“<strong>还没有</strong>”</p><p>何年（なんねん）ぐらい　日本語（にほんご）を　勉強（べんきょう）しましたか 学了几年日语？<br>ーー　二年（にねん）　勉強（べんきょう）しました。でも、<strong>まだ</strong>　あまり　でき<strong>ません</strong>学了两年，但还不太会</p><p>小野（おの）さんは　<strong>もう</strong>　結婚（けっこん）して　いますか 小野女士，你已经结婚了吗？<br>ーー　いいえ、<strong>まだ</strong>　結婚し<strong>て　いません</strong> 不，还没结</p><p>我还没有吃饭<br>私は　まだ　ご飯（ごはん）を　食べて　いません</p><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><h4 id="身体部位名词和相应的形容词"><a href="#身体部位名词和相应的形容词" class="headerlink" title="身体部位名词和相应的形容词"></a>身体部位名词和相应的形容词</h4><div class="center"><table><thead><tr><th align="center">身体部位</th><th align="center">形容词</th></tr></thead><tbody><tr><td align="center">脚（あし）&#x2F;指（ゆび）　腿&#x2F;指头</td><td align="center">長（なが）い&#x2F;太（ふと）い 长&#x2F;粗 - 短（みじか）い&#x2F;細（ほそ）い 短&#x2F;细</td></tr><tr><td align="center">足（あし） 脚</td><td align="center">大（おお）きい 大 - 小（ちい）さい 小</td></tr><tr><td align="center">目（め） 眼睛</td><td align="center">大きい 大 - 小さい&#x2F;細い 小</td></tr><tr><td align="center">鼻（はな） 鼻子</td><td align="center">高（たか）い 高 - 低（ひく）い 低</td></tr><tr><td align="center">顔（かお） 脸</td><td align="center">大きい 大 - 小さい 小</td></tr><tr><td align="center">背（せ） 个子</td><td align="center">高い 高 - 低い 矮</td></tr></tbody></table></div><h4 id="日语费用表达"><a href="#日语费用表达" class="headerlink" title="日语费用表达"></a>日语费用表达</h4><div class="center"><table><thead><tr><th align="center">&nbsp;</th><th align="center">&nbsp;</th></tr></thead><tbody><tr><td align="center">〜費（ひ）</td><td align="center">会費（かいひ）会费　光熱費（こうねつひ）照明、供热、供暖费　交通費（こうつうひ）交通费　食費（しょくひ）伙食费</td></tr><tr><td align="center">〜料（りょう）</td><td align="center">入場料（にゅうじょうりょう）门票费　使用料（しようりょう）使用费　送料（そうりょう）运费　手数料（てすうりょう）手续费</td></tr><tr><td align="center">〜代（だい）</td><td align="center">電気代（でんきだい）电费　水道代（すいどうだい）水费　タクシー代 出租车费　食事代（しょくじだい）餐费</td></tr></tbody></table></div><h4 id="IDカードは-ありますか"><a href="#IDカードは-ありますか" class="headerlink" title="IDカードは　ありますか"></a>IDカードは　ありますか</h4><p>あります　除表示<strong>存在和在某处发生某事</strong>外，还表示<strong>所有</strong></p><p>私は　車が　２台（にだい）　あります<br>我有两辆车</p><p>今（いま）、お金（かね）が　全然（ぜんぜん）　ありません<br>现在我一点儿钱也没有</p><p>森さんは　弟（おとうと）が　二人（ふたり）　<strong>います</strong><br>森先生有两个弟弟</p><h4 id="ちゃんと"><a href="#ちゃんと" class="headerlink" title="ちゃんと"></a>ちゃんと</h4><p>表示“没错、好好地”或“处于正常状态”，<strong>只用于口语</strong></p><p>ちゃんと　食べてください<br>请好好吃</p><p>ちゃんと　勉強（べんきょう）して<br>好好学习</p><h4 id="ほら"><a href="#ほら" class="headerlink" title="ほら"></a>ほら</h4><p>表示“你看！”，用于提醒对方</p><h4 id="ずいぶん"><a href="#ずいぶん" class="headerlink" title="ずいぶん"></a>ずいぶん</h4><p>表示程度高，超过说话人的想象，无论内容是好是坏</p><h4 id="派手（はで）"><a href="#派手（はで）" class="headerlink" title="派手（はで）"></a>派手（はで）</h4><p>形容色彩过分鲜艳或形状奇特。反义词是“地味（じみ），朴素、质朴”</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第15课</title>
    <link href="/2026/01/27/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC15%E8%AF%BE/"/>
    <url>/2026/01/27/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC15%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第15课小野女士现在正在看报纸"><a href="#第15课小野女士现在正在看报纸" class="headerlink" title="第15课小野女士现在正在看报纸"></a>第15课小野女士现在正在看报纸</h2><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">ます形</th><th align="center">假名</th><th align="center">原形</th><th align="center">假名</th></tr></thead><tbody><tr><td align="center">乗ります</td><td align="center">のります</td><td align="center">乗る</td><td align="center">のる</td></tr><tr><td align="center">使います</td><td align="center">つかいます</td><td align="center">使う</td><td align="center">つかう</td></tr><tr><td align="center">座ります</td><td align="center">すわります</td><td align="center">座る</td><td align="center">すわる</td></tr><tr><td align="center">入ります</td><td align="center">はいります</td><td align="center">入る</td><td align="center">はいる</td></tr><tr><td align="center">申します</td><td align="center">もします</td><td align="center">申す</td><td align="center">もうす</td></tr><tr><td align="center">とります</td><td align="center">&nbsp;</td><td align="center">とる</td><td align="center">&nbsp;</td></tr><tr><td align="center">歌います</td><td align="center">うたいます</td><td align="center">歌う</td><td align="center">うたう</td></tr><tr><td align="center">伝えます</td><td align="center">つたえます</td><td align="center">伝える</td><td align="center">つたえる</td></tr><tr><td align="center">止めます</td><td align="center">とめます</td><td align="center">止める</td><td align="center">とめる</td></tr></tbody></table></div><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>小野（おの）さんは　今（いま）　新聞（しんぶん）を　読（よ）んで　います<br>小野女士现在正在看报纸</p><p>ここで　写真（しゃしん）を　撮（と）っても　いいですか<br>这儿可以拍照吗？</p><p>飛行機（ひこうき）の　中（なか）で　タバコを　吸（す）っては　いけません<br>飞机上不能吸烟</p><p>日曜日（にちようび）、小野さんは　公園（こうえん）で　ボートに　乗（の）りました<br>星期天，小野女士在公园里<strong>划</strong>了船</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="动て-います-正在进行"><a href="#动て-います-正在进行" class="headerlink" title="动て　います　[正在进行]"></a>动て　います　[正在进行]</h4><p>表示动作或变化<strong>正在进行</strong></p><p>小野さんは　今　新聞を　読んで　います</p><p>森（もり）さんは　今　仕事（しごと）を　して　います<br>森先生正在工作</p><p>太郎（たろう）さんは　コーヒーを　飲（の）んで　います<br>太郎在喝咖啡</p><p>小王正在学日语<br>王さんは　今　日本語を　勉強して　います</p><blockquote><p>食（た）べています<br>正在吃饭</p><p>走（はし）っています<br>正在跑步</p></blockquote><h4 id="动て-も-いいです"><a href="#动て-も-いいです" class="headerlink" title="动て　も　いいです"></a>动て　も　いいです</h4><p>表示<strong>许可，允许</strong>做某事，ても 连读</p><p>~动て　も　いいです<span style="color:red"><strong>か</strong></span> 表示可以做什么事情吗？</p><p>家（いえ）で　仕事（しごと）を　して　も　いいです<br>在家里工作也可以</p><p>ここで　写真を　撮っても　いいですか 这里可以拍照吗？<br>ーー　いいですよ 可以</p><p>家に　帰（かえ）って　も　いいですか 可以回家吗？<br>ーー　はい、帰って　も　いいです 是的，可以回家</p><p>我可以在这吃吗？<br>ここで　食べても　いいですか</p><blockquote><p>这种表达方式一般不用于尊长</p></blockquote><h4 id="动て-は-いけません"><a href="#动て-は-いけません" class="headerlink" title="动て は　いけません"></a>动て は　いけません</h4><p>表示<strong>禁止</strong>做某事，ては 连读</p><p>飛行機の　中で　タバコを　吸っては　いけません</p><p>教室（きょうしつ）で　物（もの）を　食（た）べでは　いけません　&#x2F; 教室で　物を　食べないで　いけません<br>教室里不能吃东西</p><p>この　部屋（へや）に　入（はい）っては　いけませんか不能进这个屋子吗？<br>ーー　はい、入っては　いけません是的，不能<br>ーー　いいえ、入っても　いいです不，可以进</p><p>不可以光脚进来<br>裸足（はだし）で　入っては　いけません</p><blockquote><p>对尊长一般使用“～ないで　ください”</p></blockquote><h4 id="名-附着点-に-动"><a href="#名-附着点-に-动" class="headerlink" title="名[附着点]に 动"></a>名[附着点]に 动</h4><p>表示人或物体的<strong>附着点</strong>，即人或物体停留在交通工具或椅子上等（<strong>骑、坐</strong>），<span style="color:red"><strong>不能用を</strong></span></p><p>小野さんは　公園で　ボート　に　乗りました</p><p>李さんは　電車（でんしゃ）　に　乗りました<br>小李上了电车</p><p>この　いす　に　座（すわ）って　ください<br>请坐在这把椅子上</p><p>李さんは　かばん　に　書類（しょるい）を　入（い）れました<br>小李把文件放在包里了</p><p>骑自行车<br>自転車（じてんしゃ）に　乗ります</p><h4 id="名-目的地-に-动"><a href="#名-目的地-に-动" class="headerlink" title="名[目的地]に　动"></a>名[目的地]に　动</h4><p>移动行为的目的地既可以用“<strong>へ</strong>”表示，也可以用“<strong>に</strong>”表示</p><p>李さんは　病院（びょういん）　に　行（い）きます<br>小李去医院</p><p>李さんは　家（いえ）　に　帰（かえ）りました<br>小李回家了</p><p><strong>に的用法：</strong></p><ul><li><p>公園（こうえん）に ベンチが　あります[存在的场所]</p></li><li><p>五時（ごじ）に　帰ります[时间]</p></li><li><p>友達（ともだち）に　会います[动作的对象]</p></li><li><p>本（ほん）を　買（か）いに　行きます[移动行为的目的]</p></li><li><p>車（くるま）に　乗ります[附着点]</p></li></ul><p>上述用法不能用“へ”替换，只有表示<strong>移动动词（行きます、来ます、帰ります）的目的地</strong>时才可以替换</p><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><h4 id="無理（むり）を-しては-いけませんよ"><a href="#無理（むり）を-しては-いけませんよ" class="headerlink" title="無理（むり）を　しては　いけませんよ"></a>無理（むり）を　しては　いけませんよ</h4><p>表示不能勉强，由“無理を　します[勉强]”转换</p><h4 id="ゆっくり"><a href="#ゆっくり" class="headerlink" title="ゆっくり"></a>ゆっくり</h4><p>表示动作速度慢和“好好地……”</p><h4 id="薬（くすり）を-出（だ）します"><a href="#薬（くすり）を-出（だ）します" class="headerlink" title="薬（くすり）を　出（だ）します"></a>薬（くすり）を　出（だ）します</h4><p>表示医生在医院或诊所给患者开药方</p><h4 id="お大事（だいじ）に"><a href="#お大事（だいじ）に" class="headerlink" title="お大事（だいじ）に"></a>お大事（だいじ）に</h4><p>是 どうぞ　お大事に　して　ください（请多保重）的省略形式，用于对<strong>生病或受伤的人</strong>表示关心</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第14课</title>
    <link href="/2026/01/26/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC14%E8%AF%BE/"/>
    <url>/2026/01/26/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC14%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第14课昨天去商场买东西了"><a href="#第14课昨天去商场买东西了" class="headerlink" title="第14课昨天去商场买东西了"></a>第14课昨天去商场买东西了</h2><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">ます形</th><th align="center">假名</th><th align="center">原形</th><th align="center">假名</th></tr></thead><tbody><tr><td align="center">通ります</td><td align="center">とおります</td><td align="center">通る</td><td align="center">とおる</td></tr><tr><td align="center">急ぎます</td><td align="center">いそぎます</td><td align="center">急ぐ</td><td align="center">いそぐ</td></tr><tr><td align="center">飛びます</td><td align="center">とびます</td><td align="center">飛ぶ</td><td align="center">とぶ</td></tr><tr><td align="center">死にます</td><td align="center">しにます</td><td align="center">死ぬ</td><td align="center">しぬ</td></tr><tr><td align="center">待ちます</td><td align="center">まちます</td><td align="center">待つ</td><td align="center">まつ</td></tr><tr><td align="center">売ります</td><td align="center">うります</td><td align="center">売る</td><td align="center">うる</td></tr><tr><td align="center">話します</td><td align="center">はなします</td><td align="center">話す</td><td align="center">はなす</td></tr><tr><td align="center">渡ります</td><td align="center">わたります</td><td align="center">渡る</td><td align="center">わたる</td></tr><tr><td align="center">下ろします</td><td align="center">おろします</td><td align="center">下ろす</td><td align="center">おろす</td></tr><tr><td align="center">選びます</td><td align="center">えらびます</td><td align="center">選ぶ</td><td align="center">えらぶ</td></tr><tr><td align="center">消します</td><td align="center">けします</td><td align="center">消す</td><td align="center">けす</td></tr><tr><td align="center">歩きます</td><td align="center">あるきます</td><td align="center">歩く</td><td align="center">あるく</td></tr><tr><td align="center">曲がります</td><td align="center">まがります</td><td align="center">曲がる</td><td align="center">まがる</td></tr><tr><td align="center">洗います</td><td align="center">あらいます</td><td align="center">洗う</td><td align="center">あらう</td></tr><tr><td align="center">出ます</td><td align="center">でます</td><td align="center">出る</td><td align="center">でる</td></tr><tr><td align="center">出かけます</td><td align="center">でかけます</td><td align="center">出かける</td><td align="center">でかける</td></tr><tr><td align="center">開けます</td><td align="center">あけます</td><td align="center">開ける</td><td align="center">あける</td></tr><tr><td align="center">過ぎます</td><td align="center">すぎます</td><td align="center">過ぎる</td><td align="center">すぎる</td></tr><tr><td align="center">見せます</td><td align="center">みせます</td><td align="center">見せる</td><td align="center">みせる</td></tr><tr><td align="center">つけます</td><td align="center">&nbsp;</td><td align="center">つける</td><td align="center">&nbsp;</td></tr><tr><td align="center">降ります</td><td align="center">おります</td><td align="center">降りる</td><td align="center">おりる</td></tr><tr><td align="center">買い物します</td><td align="center">かいものします</td><td align="center">買い物する</td><td align="center">かいものする</td></tr><tr><td align="center">卒業します</td><td align="center">そつぎょうします</td><td align="center">卒業する</td><td align="center">そつぎょうする</td></tr><tr><td align="center">食事します</td><td align="center">しょくじします</td><td align="center">食事する</td><td align="center">しょくじする</td></tr><tr><td align="center">整理します</td><td align="center">せいりします</td><td align="center">整理する</td><td align="center">せいりする</td></tr><tr><td align="center">コピーします</td><td align="center">&nbsp;</td><td align="center">コピーする</td><td align="center">&nbsp;</td></tr></tbody></table></div><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>昨日（きのう）　デパートへ　<span style="color:red">行（い）って</span>、買（か）い物（もの）しました<br>昨天去商场买东西了</p><p>李さんは　毎晩（まいばん）　ラジオを　<span style="color:red">聞（き）いてから</span>　寝（ね）ます<br>小李每晚听了收音机后睡觉</p><p>ここに　住所（じゅうしょ）と　名前（なまえ）を　<span style="color:red">書（か）いて</span>　ください<br>请在这里填写您的住址和姓名</p><p>李さんは　毎朝（まいあさ）　七時（しちじ）に　<span style="color:red">家（いえ）を　出（で）ます</span><br>小李每天早晨7点从家出发</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="动词的て形"><a href="#动词的て形" class="headerlink" title="动词的て形"></a>动词的て形</h4><p><img src="/2025/11/01/Android-%E6%97%A7%E7%89%88%E6%9C%AC%E5%8C%85%E9%97%AE%E9%A2%98/png" alt="て形"></p><h4 id="动て-动（相继发生）"><a href="#动て-动（相继发生）" class="headerlink" title="动て　动（相继发生）"></a>动て　动（相继发生）</h4><p>表示两个以上的动作按照时间顺序相继发生，动作数量没有限制。<strong>时态由ます型的动词决定</strong></p><p>昨日　デパートへ　行って、買い物しました<br>昨日、デパートへ　行きました。そして、買い物しました</p><p>家（いえ）へ　帰（かえ）って、宿題（しゅくだい）を　します<br>回家，然后做作业</p><p>図書館（としょかん）へ　<span style="color:red">行（い）って</span>　本（ほん）を　<span style="color:red">借（か）りて</span>、家へ　<span style="color:red">帰ります</span><br>去图书馆借书，然后回家</p><p>昨天去电影院看电影了<br>昨日、<strong>私は</strong>映画館（えいがかん）へ　行って、映画を　見（み）ました</p><h4 id="动てから-动（相继发生）"><a href="#动てから-动（相继发生）" class="headerlink" title="动てから　动（相继发生）"></a>动てから　动（相继发生）</h4><p>表示两个以上的动作按照时间顺序相继发生，更强调<strong>先后顺序</strong>。てから 不能在一个句子中反复使用两次以上</p><p>李さんは　毎晩　ラジオを　聞いてから　寝ます</p><p>昼（ひる）ご飯（はん）を　食（た）べでから　出（で）かげます<br>吃了午饭后出门</p><p>家（いえ）へ　帰（かえ）ってから、もう一度（いちど）　日本語（にほんご）の　勉強（べんきょう）を　します<br>回家后，再学一遍日语</p><h4 id="动て-ください"><a href="#动て-ください" class="headerlink" title="动て　ください"></a>动て　ください</h4><p><strong>请求</strong>某人做某事时使用</p><p>食（た）べる<br>食べてください请你吃</p><p>走（はし）る<br>走ってください请你跑起来</p><p>勉強（べんきょう）する<br>勉強してください请你学习</p><p>ここに　住所と　名前を　書いて　ください</p><p>この　荷物（にもつ）を　航空便（こうくうびん）で　送（おく）って　ください<br>请用空运的方式寄这件包裹</p><p>请你告诉我<br>私に　教（おし）えてください</p><h4 id="名-场所-を-动"><a href="#名-场所-を-动" class="headerlink" title="名[场所]を　动"></a>名[场所]を　动</h4><p><strong>经过</strong>的场所用助词“を”表示，常用的动词有“通（とお）ります”、“渡（わた）ります”、“過（す）ぎます”</p><p>“を”与“出（で）ます”、“卒業（そつぎょう）します”搭配，表示<strong>离开</strong>的场所&#x2F;组织</p><p>この　バスは　駅前（えきまえ）を　通（とお）ります<br>这趟公共汽车经过车站一带（<strong>駅前表示车站周围、附近</strong>，车站前是駅の前）</p><p>この　道（みち）を　まっすぐ　行って、橋（はし）を　渡（わた）って　ください<br>顺这条路一直走，再过那座桥</p><p>李さんは　毎朝　七時に　家を　出ます</p><p>私は　来年（らいねん）　大学（だいがく）を　卒業（そつぎょう）します<br>我明年大学毕业</p><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><h4 id="なかなか"><a href="#なかなか" class="headerlink" title="なかなか"></a>なかなか</h4><p>なかなか 表示实际情况比自己预想的程度要高。不能用于谈及上级或长辈</p><h4 id="～て-くださいませんか"><a href="#～て-くださいませんか" class="headerlink" title="～て　くださいませんか"></a>～て　くださいませんか</h4><p>～て　くださいませんか　是 ～て　ください 更礼貌的表达</p><h4 id="もう"><a href="#もう" class="headerlink" title="もう"></a>もう</h4><p>もう　除了表示“已经”，还有“马上、就要”的意思</p><h4 id="そうして-ください"><a href="#そうして-ください" class="headerlink" title="そうして　ください"></a>そうして　ください</h4><p>こう　そう　ああ</p><p>こうする　そうする　ああする</p><p>そうして　ください 表示“请您那样 做”，翻译时根据上下文调整</p><h4 id="お金（かね）を-下（お）ろします"><a href="#お金（かね）を-下（お）ろします" class="headerlink" title="お金（かね）を　下（お）ろします"></a>お金（かね）を　下（お）ろします</h4><p>下ろします　表示将上面的东西取下来</p><p>お金を　下ろします 表示取钱</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日语动词变形</title>
    <link href="/2026/01/26/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D%E5%8F%98%E5%BD%A2/"/>
    <url>/2026/01/26/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D%E5%8F%98%E5%BD%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="三类动词（カ变、サ变）——-不规则动词"><a href="#三类动词（カ变、サ变）——-不规则动词" class="headerlink" title="三类动词（カ变、サ变）—— 不规则动词"></a>三类动词（カ变、サ变）—— 不规则动词</h2><p>する　ー　して &#x2F; した</p><p>来（く）る　ー　来（き）て &#x2F; 来（き）た</p><h2 id="二类动词（上一段、下一段）"><a href="#二类动词（上一段、下一段）" class="headerlink" title="二类动词（上一段、下一段）"></a>二类动词（上一段、下一段）</h2><p>る　变成　て &#x2F; た</p><p>食（た）べる　ー　食べて &#x2F; 食べた</p><p>調（しら）べる　ー　調べて &#x2F; 調べた</p><h2 id="一类动词（五段动词）"><a href="#一类动词（五段动词）" class="headerlink" title="一类动词（五段动词）"></a>一类动词（五段动词）</h2><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">规则</th><th align="center">示例</th></tr></thead><tbody><tr><td align="center"><span style="color:red">す　ー　して &#x2F; した</span></td><td align="center">話（はな）す　ー　話して &#x2F; 話した</td></tr><tr><td align="center"><span style="color:red">く　ー　いて &#x2F; いた</span></td><td align="center">磨（みが）く　ー　磨いて &#x2F; 磨いた</td></tr><tr><td align="center">ぐ　ー　いで &#x2F; いだ</td><td align="center">急（いそ）ぐ　ー　急いで &#x2F; 急いだ</td></tr><tr><td align="center">う、つ、る　ー　って &#x2F; った</td><td align="center">洗（あら）う　ー　洗って &#x2F; 洗った</td></tr><tr><td align="center">&nbsp;</td><td align="center">待（ま）つ　ー　待って &#x2F; 待った</td></tr><tr><td align="center">&nbsp;</td><td align="center">やる　ー　やって &#x2F; やった</td></tr><tr><td align="center">ぶ、む、ぬ　ー　んで &#x2F; んだ</td><td align="center">遊（あそ）ぶ　ー　遊んで &#x2F; 遊んだ</td></tr><tr><td align="center">&nbsp;</td><td align="center">読（よ）む　ー　読んで &#x2F; 読んだ</td></tr><tr><td align="center">&nbsp;</td><td align="center">死（し）ぬ　ー　死んで &#x2F; 死んだ</td></tr><tr><td align="center"><span style="color:red">行（い）く　ー　行って &#x2F; 行った</span></td><td align="center">&nbsp;</td></tr></tbody></table></div>　　　<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>勉強（べんきょう）する、見（み）る、帰（かえ）る、行（い）く</p><p>3、2、1、1</p><p>勉強して、見て、帰って、行って</p><br><p>好（この）む、考（かんが）える、呼（よ）ぶ、急（いそ）ぐ</p><p>1、2、1、1</p><p>好んで、考えて、呼んで、急いで</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
      <tag>动词</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第13课</title>
    <link href="/2026/01/25/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC13%E8%AF%BE/"/>
    <url>/2026/01/25/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC13%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第13课桌子上有3本书"><a href="#第13课桌子上有3本书" class="headerlink" title="第13课桌子上有3本书"></a>第13课桌子上有3本书</h2><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>机（つくえ）の　上（うえ）に　本（ほん）が　３冊（さんさつ）　あります<br>桌子上有3本书</p><p>李さんは　毎日（まいにち）　七時間（しちじかん）　働（はたら）きます<br>小李每天工作7小时</p><p>李さんは　一週間（いっしゅうかん）に　二回（にかい）　プールへ　行（い）きます<br>小李一周去两次游泳池（游泳）</p><p>午後（ごご）　郵便局（ゆうびんきょく）へ　荷物（にもつ）を　出（だ）しに　行きます<br>下午去邮局托运包裹</p><h3 id="动词"><a href="#动词" class="headerlink" title="动词"></a>动词</h3><style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">单词</th><th align="center">假名</th><th align="center">单词原形</th><th align="center">假名</th></tr></thead><tbody><tr><td align="center">かかります</td><td align="center">&nbsp;</td><td align="center">かかる</td><td align="center">&nbsp;</td></tr><tr><td align="center">咲きます</td><td align="center">さきます</td><td align="center">咲く</td><td align="center">さく</td></tr><tr><td align="center">泳ぎます</td><td align="center">およぎます</td><td align="center">泳ぐ</td><td align="center">およぐ</td></tr><tr><td align="center">遊びます</td><td align="center">あそびます</td><td align="center">遊ぶ</td><td align="center">あそぶ</td></tr><tr><td align="center">吸います</td><td align="center">すいます</td><td align="center">吸う</td><td align="center">すう</td></tr><tr><td align="center">切ります</td><td align="center">きります</td><td align="center">切る</td><td align="center">きる</td></tr></tbody></table></div><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="名-数量-动"><a href="#名-数量-动" class="headerlink" title="名[数量]+动"></a>名[数量]+动</h4><p>数量词用在动词前。量词因所修饰的事物种类而不同</p><p>卵（たまご）を　一個（いっこ）　食（た）べます<br>吃一个鸡蛋</p><p>本（ほん）を　２冊（にさつ）　買（か）いました<br>买了两本书</p><p>緑茶（りょくちゃ）を　３杯（さんばい）　飲（の）みました<br>喝了3杯绿茶</p><p>教室（きょうしつ）に　学生（がくせい）が　四人（よにん）　います<br>教室里有4个学生</p><p>ガレージに　車（くるま）が　５台（ごだい）　あります<br>车库里有5辆车</p><p>引（ひ）き出（だ）しに　鉛筆（えんぴつ）が　十本（じゅっぽん）　あります<br>抽屉里有10支铅笔</p><p>切手（きって）を　何枚（なんまい）　買（か）いましたか<br>买了多少张邮票？</p><blockquote><p>询问数量时，在“何（なん）”的后面加量词，如“何個（なんこ），多少个”　“何本（なんぽん），多少根”“何冊（なんさつ），多少本”，<strong>何 必须读 なん</strong></p><p>指动物时，大动物用“頭（とう）”，小动物用“匹（ひき）”</p></blockquote><p>この　動物園（どうぶつえん）は　象（ぞう）が　二頭（にとう）　います<br>这个动物园里有两头大象</p><p>友達（ともだち）に　猫（ねこ）を　一匹（いっぴき）　もらいました<br>从朋友那里得到1只猫</p><h4 id="名-时间-动"><a href="#名-时间-动" class="headerlink" title="名[时间]+动"></a>名[时间]+动</h4><p>表示时间数量的词语和动词一起使用时，说明<strong>动作、状态的持续时间</strong>。表示时间数量词语后面<span style="color:red"><strong>不能加“に”</strong></span></p><p>李さんは　毎日　七時間　働きます</p><p>昼（ひる）　一時間（いちじかん）　休（やす）みます<br>中午休息1小时</p><p>森さんは　九時間（くじかん）　寝（ね）ます<br>森先生睡9小时</p><h4 id="名-时间-に-名-次数-动"><a href="#名-时间-に-名-次数-动" class="headerlink" title="名[时间]に 名[次数]+动"></a>名[时间]<span style="color:red">に 名[次数]</span>+动</h4><p>表示在一定时间内进行若干次动作</p><p>李さんは　一週間に　二回　プールへ　行きます</p><p>この　花（はな）は　二年（にねん）に　一度（いちど）　咲（さ）きます<br>这种花每两年开一次</p><p>小王一周工作5天<br>王さんは　一週間（いっしゅうかん）に　五日（ごにち）　働（はたら）きます　</p><p>小王每天玩2个小时游戏<br>王さんは　毎日　ゲームを　二時間　遊（あそ）びます</p><h4 id="动词的“ます型”去掉“ます”"><a href="#动词的“ます型”去掉“ます”" class="headerlink" title="动词的“ます型”去掉“ます”"></a>动词的“ます型”去掉“ます”</h4><div class="center"><table><thead><tr><th align="center">ます型</th><th align="center">去掉ます</th></tr></thead><tbody><tr><td align="center">働きます</td><td align="center">はたらき</td></tr><tr><td align="center">休みます</td><td align="center">やすみ</td></tr><tr><td align="center">起きます</td><td align="center">おき</td></tr><tr><td align="center">寝ます</td><td align="center">ね</td></tr></tbody></table></div><p>动词的“<strong>ます型”去掉“ます”<span style="color:red">再加たい</span>（～たい 就是简体形）表示想去做某事</strong></p><h4 id="名-场所-へ-动に-行（い）きます-来（き）ます"><a href="#名-场所-へ-动に-行（い）きます-来（き）ます" class="headerlink" title="名[场所]へ 动に　行（い）きます&#x2F;来（き）ます"></a>名[场所]へ 动に　行（い）きます&#x2F;来（き）ます</h4><p>表示<strong>移动行为的目的</strong></p><p><strong>动词用“ます型”去掉“ます”的形式，表示<span style="color:red">移动行为的目的</span></strong></p><p>午後　郵便局　へ　荷物を　出し　に　行きます</p><p>小野（おの）さんは　プール　へ　泳（およ）ぎ　に　行きます<br>小野女士去游泳池游泳</p><p>李さんは　私の　家（いえ）　へ　遊（あそ）び　に　来ました<br>小李来我家玩了</p><p>小王去电影院看电影<br>王さんは　映画館（えいがかん）へ　映画（えいが）を　見（み）に　行きます</p><h4 id="名-数量-で"><a href="#名-数量-で" class="headerlink" title="名[数量]+で"></a>名[数量]+で</h4><p>用于不称重量而以数个的方式售卖。<strong>数量是1个时，不加“で”</strong></p><p>この　ケーキは　三個（さんこ）で　五百円（ごひゃくえん）です<br>这种蛋糕3个500日元</p><p>この　ケーキは　一個（いっこ）　二百円（にひゃくえん）です<br>这种蛋糕1个200日元</p><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><h4 id="くらい-ぐらい"><a href="#くらい-ぐらい" class="headerlink" title="くらい&#x2F;ぐらい"></a>くらい&#x2F;ぐらい</h4><p>在表示数量的词后加上“くらい” “ぐらい”，表示大概的数量</p><p>“くらい” 和 “ぐらい” 意思相同，有时与“だいたい”同时使用</p><p>询问时使用“どのぐらい” 或 “どれぐらい”</p><h4 id="どのぐらい-かかりますか"><a href="#どのぐらい-かかりますか" class="headerlink" title="どのぐらい　かかりますか"></a>どのぐらい　かかりますか</h4><p>かかりますか 用于<strong>时间和钱</strong>，表示“需要、花费”</p><h4 id="飲（の）みに-行（い）きます"><a href="#飲（の）みに-行（い）きます" class="headerlink" title="飲（の）みに　行（い）きます"></a>飲（の）みに　行（い）きます</h4><p>直接说 “飲みに　行（い）きます” 前面不加喝的东西，表示<strong>喝酒</strong></p><h4 id="とりあえず"><a href="#とりあえず" class="headerlink" title="とりあえず"></a>とりあえず</h4><p>とりあえず　表示总之，暂且……。在饭店点菜时常用，先点……</p><h4 id="量词"><a href="#量词" class="headerlink" title="量词"></a>量词</h4><div class="center"><table><thead><tr><th align="center">量词</th><th align="center">使用对象</th></tr></thead><tbody><tr><td align="center">〜人（にん）</td><td align="center">人</td></tr><tr><td align="center">〜台（だい）</td><td align="center">机械或车辆： 车、机动车、电脑等</td></tr><tr><td align="center">〜枚（まい）</td><td align="center">薄平物品： 纸、盘子、邮票、衬衫等</td></tr><tr><td align="center">〜冊（さつ）</td><td align="center">书、笔记本等</td></tr><tr><td align="center">〜歳（さい）</td><td align="center">年龄</td></tr><tr><td align="center">〜回（かい）</td><td align="center">次数</td></tr><tr><td align="center">〜着（ちゃく）</td><td align="center">衣服等</td></tr><tr><td align="center">〜個（こ）</td><td align="center">立体的物品： 鸡蛋、饭团子、球等<br>空容器或器皿： 箱子、盒子、空罐子、玻璃杯等<br>概念性的、抽象的事物： 密码等</td></tr><tr><td align="center">〜本（ほん）</td><td align="center">细长物品： 瓶、铅笔、伞、香蕉等</td></tr><tr><td align="center">〜杯（はい）</td><td align="center">容器内的饮料： 茶、咖啡、啤酒等</td></tr><tr><td align="center">〜匹（ひき）</td><td align="center">小动物： 狗、猫、昆虫、鱼等</td></tr><tr><td align="center">〜頭（とう）</td><td align="center">大动物： 牛、马、象等</td></tr><tr><td align="center">〜羽（わ）</td><td align="center">鸟、兔</td></tr><tr><td align="center">〜番（ばん）</td><td align="center">顺序</td></tr><tr><td align="center">〜足（そく）</td><td align="center">成对物品： 鞋、袜子等</td></tr><tr><td align="center">〜つ</td><td align="center">1～9岁的年龄<br>立体的物品：橘子、帽子等<br>抽象的事物： 谜、选项等<br><strong>注：</strong>〜つ 不用于10以上的数字</td></tr></tbody></table></div><br><div class="center"><table><thead><tr><th align="center">&nbsp;</th><th align="center">〜つ</th><th align="center">〜人</th><th align="center">〜台</th><th align="center">〜個</th><th align="center">〜本</th><th align="center">〜杯</th></tr></thead><tbody><tr><td align="center">1</td><td align="center"><strong>ひと</strong>つ</td><td align="center"><strong>ひとり</strong></td><td align="center">いちだい</td><td align="center"><strong>いっ</strong>こ</td><td align="center"><strong>いっぽ</strong>ん</td><td align="center"><strong>いっぱ</strong>い</td></tr><tr><td align="center">2</td><td align="center"><strong>ふた</strong>つ</td><td align="center"><strong>ふたり</strong></td><td align="center">にだい</td><td align="center">にこ</td><td align="center">にほん</td><td align="center">にはい</td></tr><tr><td align="center">3</td><td align="center"><strong>みっ</strong>つ</td><td align="center">さんにん</td><td align="center">さんだい</td><td align="center">さんこ</td><td align="center">さん<strong>ぼ</strong>ん</td><td align="center">さん<strong>ば</strong>い</td></tr><tr><td align="center">4</td><td align="center"><strong>よっ</strong>つ</td><td align="center">よにん</td><td align="center">よんだい</td><td align="center">よんこ</td><td align="center">よんほん</td><td align="center">よんはい</td></tr><tr><td align="center">5</td><td align="center"><strong>いつ</strong>つ</td><td align="center">ごにん</td><td align="center">ごだい</td><td align="center">ごこ</td><td align="center">ごほん</td><td align="center">ごはい</td></tr><tr><td align="center">6</td><td align="center"><strong>むっ</strong>つ</td><td align="center">ろくにん</td><td align="center">ろくだい</td><td align="center"><strong>ろっ</strong>こ</td><td align="center"><strong>ろっぽ</strong>ん</td><td align="center"><strong>ろっぱ</strong>い</td></tr><tr><td align="center">7</td><td align="center"><strong>なな</strong>つ</td><td align="center">ななにん &#x2F; しちにん</td><td align="center">ななだい</td><td align="center">ななこ</td><td align="center">ななほん</td><td align="center">ななはい</td></tr><tr><td align="center">8</td><td align="center"><strong>やっ</strong>つ</td><td align="center">はちにん</td><td align="center">はちだい</td><td align="center"><strong>はっ</strong>こ</td><td align="center"><strong>はっぽ</strong>ん</td><td align="center"><strong>はっぱ</strong>い</td></tr><tr><td align="center">9</td><td align="center"><strong>ここの</strong>つ</td><td align="center">きゅうにん</td><td align="center">きゅうだい</td><td align="center">きゅうこ</td><td align="center">きゅうほん</td><td align="center">きゅうはい</td></tr><tr><td align="center">10</td><td align="center"><strong>とお</strong></td><td align="center">じゅうにん</td><td align="center">じゅうだい</td><td align="center"><strong>じゅっ</strong>こ</td><td align="center"><strong>じゅっぽ</strong>ん</td><td align="center"><strong>じゅっぱ</strong>い</td></tr><tr><td align="center">何</td><td align="center">いくつ</td><td align="center">なんにん</td><td align="center">なんだい</td><td align="center">なんこ</td><td align="center">なん<strong>ぼ</strong>ん</td><td align="center">なん<strong>ば</strong>い</td></tr></tbody></table></div><br><p><strong>规律：</strong></p><ul><li><p>1、3、6、8、10 读音发生变化</p></li><li><p>いち、ろく、はち、じゅう</p></li><li><p>いっ　ぱい</p></li><li><p>ろっ　ぱい</p></li><li><p>はっ　ぱい</p></li><li><p>じゅっ　ぱい</p></li><li><p>さん　ばい、　ぼん</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第12课</title>
    <link href="/2026/01/24/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC12%E8%AF%BE/"/>
    <url>/2026/01/24/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC12%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第12课小李比森先生年轻"><a href="#第12课小李比森先生年轻" class="headerlink" title="第12课小李比森先生年轻"></a>第12课小李比森先生年轻</h2><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>李さんは　森さんより　若（わか）いです<br>小李比森先生年轻</p><p>日本（にほん）より　中国（ちゅうごく）の　ほうが　広（ひろ）いです<br>和日本相比，中国更辽阔</p><p>神戸（こうべ）は　大阪（おおさか）ほど　にぎやがでは　ありません<br>神户没有大阪那么繁荣</p><p>スポーツの　中（なか）で　サッカーが　いちばん　おもしろいです<br>在各种体育活动中，足球最有意思</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="Aは-Bより-一类形-二类形です"><a href="#Aは-Bより-一类形-二类形です" class="headerlink" title="Aは Bより 一类形&#x2F;二类形です"></a>Aは Bより 一类形&#x2F;二类形です</h4><p>A比B<strong>更具有形容词所表示的性质</strong>时使用</p><p>李さんは　森さん　より　若いです</p><p>中国は　日本　より　広いです<br>中国比日本辽阔</p><p>上海（シャンハイ）は　北京（ペキン）　より　にぎやがですか<br>上海比北京热闹吗？</p><br><p>程度差异较大时用副词“<strong>ずっと</strong>”强调</p><p>中国は　日本　より　ずっと　広いです<br>中国比日本辽阔得多</p><h4 id="Aより、Bのほうが-一类形-二类形です"><a href="#Aより、Bのほうが-一类形-二类形です" class="headerlink" title="Aより、Bのほうが　一类形&#x2F;二类形です"></a>Aより、B<span style="color:red">の</span>ほうが　一类形&#x2F;二类形です</h4><p>与A相比，B更加的……</p><p>日本　より　中国　の　ほうが　広いです</p><p>北京　より　東京（とうきょう）　の　ほうが　暖（あたた）かいです<br>与北京相比，东京更暖和</p><p>大阪（おおさか）　より　東京　の　ほうが　にぎやかですか<br>与大阪相比，东京更热闹吗？</p><h4 id="AはBほど-一类形く-ないです-二类形では-ありませんです"><a href="#AはBほど-一类形く-ないです-二类形では-ありませんです" class="headerlink" title="AはBほど　一类形く　ないです&#x2F;二类形では　ありませんです"></a>AはBほど　一类形く　ないです&#x2F;二类形では　ありませんです</h4><p>A没有B那么……</p><p>東京の　冬（ふゆ）は　北京の　冬　ほど　寒（さむ）くないです<br>东京的冬天没有北京的冬天那么冷</p><p>神戸は　大阪　ほど　にぎやか　では　ありません<br>神户没有大阪那么繁华</p><p>私の　部屋（へや）は　王さんの　部屋　ほど　きれい　<span style="color:red"><strong>では　ありません</strong></span><br>我的房间没有小王的房间那么整洁</p><h4 id="Aの中（なか）で、Bが一番（いちばん）一类形-二类形です"><a href="#Aの中（なか）で、Bが一番（いちばん）一类形-二类形です" class="headerlink" title="Aの中（なか）で、Bが一番（いちばん）一类形&#x2F;二类形です"></a>Aの中（なか）で、Bが一番（いちばん）一类形&#x2F;二类形です</h4><p>在A的范围内，B是最……的</p><p>スポーツ　の　中で　サッカー　が　一番　おもしろいです</p><p>日本料理（にほんりょうり）　の　中で　寿司（すし）　が　一番　おいしいです<br>日式饭菜中，寿司最好吃</p><br><p>A表示<strong>场所或时间</strong>，后面不加“の中”</p><p>使用 <strong>A[场所&#x2F;时间]で 一番（いちばん）一类形&#x2F;二类形 Bは　Cです</strong> 的句型</p><p>日本で　一番　高（たか）い　山（やま）は　富士山（ふじさん）です<br>日本最高的山是富士山</p><p>一年（いちねん）で　一番　寒（さむ）い　月（つき）は　２月（にがつ）です<br>一年当中最冷的月份是2月份</p><blockquote><p>日语的“一番”只能用于 “〜の 中で” “〜で”等<strong>明确指出比较对象或范围</strong>的情况</p></blockquote><h4 id="Aと-Bと-どちらが-一类形-二类形ですか"><a href="#Aと-Bと-どちらが-一类形-二类形ですか" class="headerlink" title="Aと　Bと　どちらが　一类形&#x2F;二类形ですか"></a>Aと　Bと　どちらが　一类形&#x2F;二类形ですか</h4><p>询问<strong>两种</strong>事物中哪种更具有该句形容词的性质时使用</p><blockquote><p>どちら　是二选一时使用的疑问句，使用“<strong>〜の　ほうが〜</strong>”回答</p><p>两者<strong>程度相当</strong>，使用“どちらも　〜です”回答</p><p>口语中有时将“どちら”说成“どっち”</p></blockquote><p>日本語　と　英語（えいご）　と　<span style="color:red">どちら</span>が　難（むずか）しいですか　日语和英语哪个更难学？<br>ーー日本語　の　ほうが　難しいです日语更难学</p><p>コーヒー　と　紅茶（こうちゃ）　と　<span style="color:red">どっち</span>が　好（す）きですか咖啡与红茶更喜欢哪个？<br>ーー紅茶　の　ほうが　好きです更喜欢红茶<br>ーーどちらも　好きです哪个都喜欢</p><blockquote><p>询问范围为<strong>两种</strong>事物，无论人、物还是时间，都可以用“どちらが”</p><p>询问<strong>三种以上</strong>的事物时不能使用“どちら”</p></blockquote><h4 id="どの-名-いつ-どれ-だれ-何（なに）が-一番（いちばん）-一类形-二类形ですか"><a href="#どの-名-いつ-どれ-だれ-何（なに）が-一番（いちばん）-一类形-二类形ですか" class="headerlink" title="どの　名&#x2F;いつ&#x2F;どれ&#x2F;だれ&#x2F;何（なに）が　一番（いちばん）　一类形&#x2F;二类形ですか"></a>どの　名&#x2F;いつ&#x2F;どれ&#x2F;だれ&#x2F;何（なに）が　一番（いちばん）　一类形&#x2F;二类形ですか</h4><p>询问<strong>三种以上</strong>事物中哪一个更具有该句形容词的性质</p><ul><li>询问人用“だれが”</li><li>询问物用“どの ~が”　“どれが” 或 “何が”　</li><li>询问时间用“いつが”</li></ul><p>この　中（なか）で　<span style="color:red">どの　料理（りょうり）　が</span>　いちばん　おいしいですか　这些菜中，哪个菜最好吃<br>ーーこの　料理　が　いちばん　おいしいです　这个菜最好吃</p><p>季節（きせつ）の　中で　<span style="color:red">いつ　が</span>　いちばん　好きですか　四个季节中，你最喜欢哪个？<br>ーー私は　春（はる）が　いちばん　好きです　我最喜欢春天</p><p><strong>被选择的事物在上下文中提到或在眼前，使用“どの ~が”或“どれが”，否则使用“何（なに）が”</strong></p><p>リンゴと　ナシと　バナナの　中で　どれが　いちばん　好きですか<br>苹果、梨和香蕉当中你最喜欢什么？</p><p>果物（くだもの）の　中で　何が　いちばん　好きですか<br>水果当中你最喜欢什么？</p><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><h4 id="最近（さいきん）"><a href="#最近（さいきん）" class="headerlink" title="最近（さいきん）"></a>最近（さいきん）</h4><p>日语的“最近”表示过去到现在为止，不表示将来</p><h4 id="〜が-いいです"><a href="#〜が-いいです" class="headerlink" title="〜が　いいです"></a>〜が　いいです</h4><p>〜が　いいです　表示“～比较好”，“我喜欢～”</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第11课</title>
    <link href="/2026/01/23/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC11%E8%AF%BE/"/>
    <url>/2026/01/23/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC11%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第11课小野女士喜欢唱歌"><a href="#第11课小野女士喜欢唱歌" class="headerlink" title="第11课小野女士喜欢唱歌"></a>第11课小野女士喜欢唱歌</h2><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>小野（おの）さんは　歌（うた）が　好（す）きです<br>小野女士喜欢唱歌</p><p>スミスさんは　韓国語（かんこくご）が　分（わ）かります<br>史密斯先生懂韩语</p><p>吉田（よしだ）さんは　時々（ときどき）　中国（ちゅごく）や　韓国へ　行（い）きます<br>吉田先生有时去中国和韩国</p><p>森（もり）さんは　お酒（さけ）が　好きですから、毎日（まいにち）　飲（の）みます<br>森先生喜欢喝酒，每天都喝</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="名1は-名2が-一类形-二类形です"><a href="#名1は-名2が-一类形-二类形です" class="headerlink" title="名1は 名2が 一类形&#x2F;二类形です"></a>名1は 名2が 一类形&#x2F;二类形です</h4><p>好きです、嫌（きら）いです、怖（こわ）いです　等<strong>表达情感的形容词</strong>可以</p><p>以 “<strong>[名1]は [名2]が 一类形容词，二类形容词です</strong>” 的句型使用</p><p>名1 表示<strong>情感主体</strong>，名2 表示<strong>情感对象</strong></p><p>小野さんは　歌　が　好きです</p><p>王（おう）さんは　肉（にく）　が　嫌いです<br>小王不喜欢吃肉</p><p>林（はやし）さんは　犬（いぬ）　が　怖いです<br>林先生害怕狗</p><p>小王喜欢电影<br>王さんは　映画（えいが）が　好きです</p><h4 id="名1は-名2が-分（わ）かります-できます"><a href="#名1は-名2が-分（わ）かります-できます" class="headerlink" title="名1は 名2が 分（わ）かります&#x2F;できます"></a>名1は 名2が 分（わ）かります&#x2F;できます</h4><p>分かります、できます、上手（じょうず）です、下手（へた）です、苦手（にがて）です　等<strong>有关能力的词语</strong></p><p>也可以以 “<strong>[名1]は [名2]が [动词]ます&#x2F;[一类形容词&#x2F;二类形容词]です</strong>” 的句型使用</p><p>スミスさんは　韓国語　が　分かります</p><p>私は　コンピュータ　が　できません<br>我不会用电脑</p><p>小野さんは　料理（りょうり）　が　上手（じょうず）です<br>小野女士擅长做饭</p><p>我不擅长打游戏<br>私は　ゲームが　下手です</p><h4 id="名や名"><a href="#名や名" class="headerlink" title="名や名"></a>名や名</h4><p>助词や和と一样用于连接名词，<strong>と</strong>用于列举<strong>所有的项目</strong></p><p><strong>や</strong>用于只列举<strong>许多项目中的两项</strong>，相当于“~呀～什么的”</p><p>や常和“など”呼应使用，构成“<strong>~や　~など</strong>” 表示“<strong>～等等</strong>”</p><p>吉田さんは　時々　中国や　韓国へ　行きます</p><p>森さんは　サッカーや　野球（やきゅう）が　好きです<br>森先生喜欢足球和棒球</p><p>私は　お店（みせ）で　野菜（やさい）<span style="color:red">や</span>　果物（くだもの）<span style="color:red">など</span>を　買（か）いました<br>我在店里买了蔬菜和水果等等</p><h4 id="から-和-だから-说明原因、理由"><a href="#から-和-だから-说明原因、理由" class="headerlink" title="~から　和　だから 说明原因、理由"></a>~から　和　だから 说明原因、理由</h4><p>~から 表示“因为……”</p><p>森さんは　お酒が　好き<strong>ですから</strong>、毎日　飲みます [表示因为]</p><p>寒（さむ）い<strong>ですから</strong>、窓（まど）を　閉（し）めます<br>因为太冷了，我要把窗户关上</p><p>窓（まど）を　閉めます。寒いですから<br>我要把窗户关上，因为太冷了</p><p>因为很热，所以我打开了窗户<br>熱（あつ）いから　窓を　開（あ）けました</p><br><p>だから 表示“所以……”，偏口语。ですから 是比较正式、礼貌的说法</p><p>キムさんは　野菜（やさい）が　嫌（きら）いです。<span style="color:red">だから</span>、あまり　野菜を　食（た）べません<br>金女士不喜欢蔬菜，所以不怎么吃</p><p>明日（あした）は　休（やす）みです。ですから、子供（こども）と　動物園（どうぶつえん）へ　行（い）きます<br>明天休息，所以我跟孩子去动物园</p><p>后天要考试，所以今晚我要熬夜<br>明後日（あさって）は　試験（しけん）が　<span style="color:red">あります</span>から&#x2F;あるから。今晩（こんばん）、徹夜（てつや）します</p><blockquote><p><strong>~から</strong>　可以直接接在<strong>一类形容词和动词</strong>后，暑（あつ）いから、食べますから</p><p><strong>二类形容词和名词</strong>后接<strong>だから　或　ですから</strong>，好きだから、好きですから、学校（がっこう）だから、学校ですから</p></blockquote><h4 id="表示频率的副词"><a href="#表示频率的副词" class="headerlink" title="表示频率的副词"></a>表示频率的副词</h4><p><strong>あまり、全然（ぜんぜん）<strong>后须接</strong>否定形式</strong></p><p><img src="/2025/11/01/Android-%E6%97%A7%E7%89%88%E6%9C%AC%E5%8C%85%E9%97%AE%E9%A2%98/quency.png" alt="频率副词比较"></p><p>私は　たまに　コンサートへ　行きます<br>我偶尔去听音乐会</p><p>李さんは　時々（ときどき）　映画（えいが）を　見（み）ます<br>小李有时看电影</p><p>田中（たなか）さんは　あまり　横浜（よこはま）へは　行きません<br>田中先生不太去横滨（<strong>否定句中へ后加は</strong>突出“针对该方向&#x2F;对象的动作不发生”）</p><p>我不怎么看动漫<br>私は　あまり　アニメを　見（み）ま<span style="color:red"><strong>せん</strong></span></p><h4 id="どうしてですか"><a href="#どうしてですか" class="headerlink" title="どうしてですか"></a>どうしてですか</h4><p>どうしてですか　用于询问事由，相当于“为什么”。回答时在谓语后加“から”</p><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><h4 id="ぼく"><a href="#ぼく" class="headerlink" title="ぼく"></a>ぼく</h4><p>ぼく 表示“我”，一般小学男生用</p><h4 id="ホテルで-写真展（しゃしんてん）が-あります"><a href="#ホテルで-写真展（しゃしんてん）が-あります" class="headerlink" title="ホテルで　写真展（しゃしんてん）が　あります"></a>ホテルで　写真展（しゃしんてん）が　あります</h4><p><a href="https://yojayc.github.io/2026/01/06/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E5%9B%9B%E8%AF%BE/#%E8%AF%AD%E6%B3%95">“名[场所]<strong>に</strong> 名[物]<strong>が</strong>　あります”</a></p><p>将“<strong>名[物]</strong>”换成“摄影展、联欢会、会议”等<strong>表示事件的名词</strong>，表示在某处发生某事</p><p>动作发生的场所用“<strong>で</strong>”表示，に　强调存在的地点</p><h4 id="いかがですか"><a href="#いかがですか" class="headerlink" title="いかがですか"></a>いかがですか</h4><p>いかがですか　是　どうですか 的礼貌表达方式，对<strong>长辈或上级</strong>使用</p><p>用于征求对方意见或想法，也可用于向对方提出某种建议或推荐某物</p><h4 id="そうですね"><a href="#そうですね" class="headerlink" title="そうですね"></a>そうですね</h4><p>そうですね　用在<strong>疑问句</strong>后，表示说话人在思考接下来要说的内容</p><h4 id="迷（まよ）います"><a href="#迷（まよ）います" class="headerlink" title="迷（まよ）います"></a>迷（まよ）います</h4><p>迷います 表示“犹豫”，用于难以立即做出选择的场合</p><p>也可以表示“迷路”，道（みち）に　迷いました</p><h4 id="気（き）に-入（い）りました"><a href="#気（き）に-入（い）りました" class="headerlink" title="気（き）に　入（い）りました"></a>気（き）に　入（い）りました</h4><p>気に入りました　表示原来不知道、不喜欢，没有关注过，<strong>此时此刻</strong>看了之后喜欢。</p><p>只能用于<strong>朋友或熟人</strong>之间，对<strong>长辈不能使用</strong></p><p>好きです　一般用于<strong>持续性的爱好</strong></p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第十课</title>
    <link href="/2026/01/22/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E5%8D%81%E8%AF%BE/"/>
    <url>/2026/01/22/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E5%8D%81%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第十课京都的红叶很有名"><a href="#第十课京都的红叶很有名" class="headerlink" title="第十课京都的红叶很有名"></a>第十课京都的红叶很有名</h2><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>京都（きょうと）の　紅葉（もみじ）は　有名（ゆうめい）です<br>京都的红叶很有名</p><p>この　通（とお）りは　にぎやかでは　ありません<br>这条街不热闹</p><p>奈良（なら）は　静（しず）かな　町（まち）です<br>奈良是个很安静的城市</p><p>昨日（きのう）は　日曜日（にちようび）でした<br>昨天是星期日</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="名は-二类形です-でした"><a href="#名は-二类形です-でした" class="headerlink" title="名は　二类形です &#x2F;　でした"></a>名は　二类形です &#x2F;　でした</h4><p>二类形容词作谓语时要在后面加 <strong>です</strong>，过去式是 <strong>でした</strong></p><p>京都の　紅葉は　有名　です</p><p>この　通りは　静か　です<br>这条街很安静</p><p>この　町は　にぎやか　でした<br>这个城市从前很热闹</p><h4 id="名は-二类形では-ありません-では-ありませんでした"><a href="#名は-二类形では-ありません-では-ありませんでした" class="headerlink" title="名は　二类形では　ありません &#x2F;　では　ありませんでした"></a>名は　二类形では　ありません &#x2F;　では　ありませんでした</h4><p>二类形容词作谓语时<strong>否定形式</strong>要在后面加 <strong>では　ありません</strong>，过去式是 <strong>では　ありませんでした</strong>。では　ありませんでした 在口语中说成 <strong>じゃ　ありませんでした</strong></p><p>この　通りは　にぎやか　では　ありません</p><p>昨日（きのう）は　暇（ひま）じゃ　ありませんでした<br>昨天没空</p><h4 id="名は-二类形な-名です"><a href="#名は-二类形な-名です" class="headerlink" title="名は　二类形な　名です"></a>名は　二类形<span style="color:red">な</span>　名です</h4><p>二类形容词 + <strong>な</strong> + 名词</p><p>奈良は　静か　な　町です</p><p>奈良は　にぎやか　な　町では　ありません<br>奈良不是个热闹的城市</p><h4 id="名でした"><a href="#名でした" class="headerlink" title="名でした"></a>名でした</h4><p>名词作谓语时的过去式是 <strong>名词でした</strong>，否定形式是 <strong>名词では　ありませんでした</strong></p><p>昨日（きのう）は　日曜日　でした</p><p>一昨日（おととい）は　休（やす）み　でした<br>前天是休息日</p><p>昨日は　雨（あめ）では　ありませんでした<br>昨天没下雨</p><p>一昨日は　曇（くも）り　じゃ　ありませんでした<br>前天不是阴天</p><p>昨天不是星期六<br>昨日は　土曜日（どようび）　では　ありませんでした</p><h4 id="どんな"><a href="#どんな" class="headerlink" title="どんな"></a>どんな</h4><p><strong>どんな + 名词</strong> 用于询问人或事物的性质，どんな 相当于“什么样的”</p><p>横浜（よこはま）は　どんな　町（まち）ですか横滨是个什么样的城市？<br>——とても　にぎやかな　町です是个非常热闹的城市</p><p>張（ちょう）さんは　どんな　人（ひと）ですか小张是什么样的人？<br>——　親切（しんせつ）な　人です是个很热情的人</p><h4 id="何（なん）の-和-どんな"><a href="#何（なん）の-和-どんな" class="headerlink" title="何（なん）の　和　どんな"></a>何（なん）の　和　どんな</h4><p>何の　有询问<strong>内容和材料</strong>两种用法</p><p>何の　本（ほん）ですか　[内容]什么书？<br>ーー自動車（じどうしゃ）の本です关于汽车的书</p><p>何の　料理（りょうり）ですか [材料]什么菜啊？<br>ーー魚（さかな）の料理です鱼</p><br><p>どんな 询问<strong>性质</strong></p><p>どんな　本ですか什么样的书？<br>ーー面白（おもしろ）い　本です非常有趣的书</p><p>どんな　料理ですか什么样的菜？<br>ーーちょっと　辛い料理です有点儿辣的菜</p><h4 id="どうですか"><a href="#どうですか" class="headerlink" title="どうですか"></a>どうですか</h4><p>どうですか　用于询问<strong>对方对某状态的意见或感想</strong>时的表达方式（现在或未来的事情），或<strong>劝诱对方进行某动作</strong></p><p>どう<strong>でしたか</strong>　用于询问过去的事情</p><p>この料理は　どうですか<br>这个菜怎么样？</p><p>京都（きょうと）は　どうでしたか<br>京都怎么样？（询问去过京都旅游的人）</p><p>お茶（ちゃ）、どうですか您喝杯茶吧<br>ーーありがどう　ございます谢谢</p><h4 id="でも-和-そして"><a href="#でも-和-そして" class="headerlink" title="でも　和　そして"></a>でも　和　そして</h4><p>でも 表示<strong>转折</strong>关系的连词，<strong>只用于口语</strong>，书面用<strong>しかし</strong></p><p>そして 表示<strong>并列</strong>关系的连词</p><p>私の　部屋（へや）は　狭（せま）いです。でも、綺麗（きれい）です<br>我的房间很小，但是很干净</p><p>私の　部屋（へや）は　狭いです。そして、汚（きたな）いです<br>我的房间很小，而且很脏</p><p>这道菜很辣，但是很好吃<br>この料理は　辛いです。でも、おいしいです</p><h4 id="常用二类形容词"><a href="#常用二类形容词" class="headerlink" title="常用二类形容词"></a>常用二类形容词</h4><p>嫌（きら）い 讨厌</p><p>綺麗　きれい　漂亮</p><p>有名　ゆうめい</p><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><h4 id="一昨日は-雨（あめ）でした"><a href="#一昨日は-雨（あめ）でした" class="headerlink" title="一昨日は　雨（あめ）でした"></a>一昨日は　雨（あめ）でした</h4><p>下雨，下雪等自然现象直接使用“雨です”　“雪（ゆき）です”等名词句的形式</p><h4 id="ところで"><a href="#ところで" class="headerlink" title="ところで"></a>ところで</h4><p>ところで　用于转换话题</p><h4 id="场所-中"><a href="#场所-中" class="headerlink" title="场所+中"></a>场所+中</h4><p>[场所]+中 表示场所内</p><p>[时间&#x2F;期间]+中 用 “一（いち&#x2F;ひと）〜中（じゅう）” 表示在某个期间一直</p><p><img src="/2025/11/01/Android-%E6%97%A7%E7%89%88%E6%9C%AC%E5%8C%85%E9%97%AE%E9%A2%98/.png" alt="中的用法"></p><h4 id="形容词-の"><a href="#形容词-の" class="headerlink" title="形容词+の"></a>形容词+の</h4><p>面白（おもしろ）い<strong>の</strong>が　ありますよ 中的<strong>の</strong>用于代指前面提到的东西</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第九课</title>
    <link href="/2026/01/21/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%B9%9D%E8%AF%BE/"/>
    <url>/2026/01/21/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%B9%9D%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第九课四川菜很辣"><a href="#第九课四川菜很辣" class="headerlink" title="第九课四川菜很辣"></a>第九课四川菜很辣</h2><h3 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h3><h4 id="一类形容词"><a href="#一类形容词" class="headerlink" title="一类形容词"></a>一类形容词</h4><ul><li><p>以い结尾</p></li><li><p>汉字+い　热い、冷たい、寒い、暖かい</p></li></ul><h5 id="肯定句：-い-＋-です"><a href="#肯定句：-い-＋-です" class="headerlink" title="肯定句： い　＋　です"></a>肯定句： い　＋　です</h5><style>.center {width:auto;display:table;margin-left:auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">一类形</th><th align="center">肯定</th></tr></thead><tbody><tr><td align="center">あつい</td><td align="center">あついです</td></tr><tr><td align="center">さむい</td><td align="center">さむいです</td></tr><tr><td align="center">からい</td><td align="center">からいです</td></tr><tr><td align="center">あたらしい</td><td align="center">あたらしいです</td></tr><tr><td align="center">むずかしい</td><td align="center">むずかしいです</td></tr><tr><td align="center">おもしろい</td><td align="center">おもしろいです</td></tr><tr><td align="center">つまらない</td><td align="center">つまらないです</td></tr></tbody></table></div><h5 id="否定句：-い-ー-くないです-くありません"><a href="#否定句：-い-ー-くないです-くありません" class="headerlink" title="否定句： い　ー　くないです&#x2F;くありません"></a>否定句： い　ー　くないです&#x2F;くありません</h5><div class="center"><table><thead><tr><th align="center">一类形</th><th align="center">否定</th></tr></thead><tbody><tr><td align="center">あつい</td><td align="center">あつくないです&#x2F;熱くありません</td></tr><tr><td align="center">さむい</td><td align="center">さむくないです&#x2F;寒くありません</td></tr><tr><td align="center">からい</td><td align="center">からくないです&#x2F;辛くありません</td></tr><tr><td align="center">あたらしい</td><td align="center">新しくないです&#x2F;新しくありません</td></tr><tr><td align="center">むずかしい</td><td align="center">難しくないです&#x2F;難しくありません</td></tr><tr><td align="center">おもしろい</td><td align="center">面白くないです&#x2F;面白くありません</td></tr><tr><td align="center">つまらない</td><td align="center">つまらなくないです&#x2F;つまらなくありません</td></tr></tbody></table></div><h5 id="过去式：-い-ー-かった"><a href="#过去式：-い-ー-かった" class="headerlink" title="过去式： い　ー　かった"></a>过去式： い　ー　かった</h5><p>今日（きょう）は　暑いです、昨日（きのう）は　<span style="color:red"><strong>暑かった</strong></span>です</p><div class="center"><table><thead><tr><th align="center">一类形</th><th align="center">过去式</th></tr></thead><tbody><tr><td align="center">あつい</td><td align="center">あつかった　です</td></tr><tr><td align="center">さむい</td><td align="center">さむかった　です</td></tr><tr><td align="center">からい</td><td align="center">からかった　です</td></tr><tr><td align="center">あたらしい</td><td align="center">あたらしかった　です</td></tr><tr><td align="center">おもしろい</td><td align="center">おもしろかった　です</td></tr><tr><td align="center">つまらない</td><td align="center">つまらなかった　です</td></tr></tbody></table></div><h4 id="二类形容词"><a href="#二类形容词" class="headerlink" title="二类形容词"></a>二类形容词</h4><p>二类形容词是<strong>不以“い”结尾的形容词</strong></p><p><strong>特例：</strong></p><p>綺麗 きれい、詳細　しょうさい、愉快　ゆかい、嫌い　きらい、細かい　こまかい、柔らかい　やわらかい、硬い　かたい</p><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>四川料理（しせんりょうり）は　辛（から）いです<br>四川菜很辣</p><p>この　スープは　あまり　熱（あつ）く　ないです<br>这个汤不太热</p><p>旅行（りょこう）は　とても　楽（たの）しかったです<br>旅行很愉快</p><p>中国（ちゅごく）は　広（ひろ）い　国（くに）です<br>中国是个幅员辽阔的国家</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="名は-一类形です"><a href="#名は-一类形です" class="headerlink" title="名は 一类形です"></a>名は 一类形です</h4><p>一类形容词作谓语时要在后面加です</p><p>四川料理は　辛　いです</p><p>あの　スープは　冷（つめ）た　いです<br>那个汤是凉的</p><p>この　お茶（ちゃ）は　熱（あつ）いです<br>这茶很烫</p><p>阿飞老师很帅<br>AFEI先生は　かっこいいです&#x2F;FLY ティーチェーは　かっこいいです</p><h4 id="一类形作谓语时的否定形式"><a href="#一类形作谓语时的否定形式" class="headerlink" title="一类形作谓语时的否定形式"></a>一类形作谓语时的否定形式</h4><p><strong>い　ー　くないです&#x2F;くありません</strong></p><p>この　スープは　熱（あつ）く　ないです<br>这个汤不热</p><p>今日（きょう）は　寒（さむ）く　ないです<br>今天不冷</p><p>この本（ほん）は　高（たか）く　ありません<br>这本书不贵</p><blockquote><p><strong>いいです</strong>（好）　的否定形式和 よい　一样是 <strong>よくないです</strong>　或 <strong>よくありません</strong></p></blockquote><p>这场考试不难<br>この試験（しけん）&#x2F;テストは　難（むずか）しくないです</p><h4 id="一类形作谓语时的过去形式"><a href="#一类形作谓语时的过去形式" class="headerlink" title="一类形作谓语时的过去形式"></a>一类形作谓语时的过去形式</h4><p>过去： <strong>い　ー　かった　です</strong></p><p>过去否定： <strong>い　ー　くなかった　です&#x2F;くありませんでした</strong></p><p>形容词：<br>あつい　ー　あつくない　ー　あつくなかったです<br>　　　　　　　否定     ー     过去否定</p><p>动词：<br>食べる　ー　食べません　ー　食べませんでした<br>　　　　　　　否定     ー     过去否定</p><p>旅行（りょこう）は　楽（たの）しかったです<br>旅行很愉快</p><p>昨日（きのう）は　寒（さむ）くなかったです&#x2F;昨日（きのう）は　寒くありませんでした<br>昨天不冷</p><blockquote><p>おいしいです　ー　おいしかったです</p><p>いいです　ー　よかったです　ー　よくなかったです</p></blockquote><p>10年前，小王不高<br>10年（ねん）前（まえ）、王さんは　高（たか）くなかった　です</p><h4 id="一类形-名"><a href="#一类形-名" class="headerlink" title="一类形+名"></a>一类形+名</h4><p>一类形容词可以<strong>直接修饰名词</strong></p><p>広（ひろ）い国（くに）<br>幅员辽阔的国家</p><p>青（あお）い海（うみ）<br>蓝色的大海</p><p>おいしい料理（りょうり）<br>可口的饭菜</p><p>白（しろ）い紙（かみ）<br>白纸</p><p>帅气的阿飞老师<br>かっこいいAFEI先生</p><blockquote><p><strong>形容词和名词之间不能加“の”</strong></p></blockquote><h4 id="あまり＋一类形-动词（否定）"><a href="#あまり＋一类形-动词（否定）" class="headerlink" title="あまり＋一类形&#x2F;动词（否定）"></a>あまり＋一类形&#x2F;动词（否定）</h4><p>あまり＋否定表示程度不高</p><p>この　スープは　あまり　熱（あつ）く　ないです<br>这个汤不太热</p><p>試験（しけん）は　あまり　難（むずか）しく　ありませんでした<br>考试不太难</p><p>我不怎么去图书馆<br>私は　あまり　図書館（としょかん）へ　行（い）きません&#x2F;私は　図書館（としょかん）へ あまり　行（い）きません</p><p>我不怎么吃蛋糕<br>私は　あまり　ケーキを　食べません&#x2F;私は　ケーキを あまり　食べません</p><h4 id="表示程度的副词"><a href="#表示程度的副词" class="headerlink" title="表示程度的副词"></a>表示程度的副词</h4><p>とても&#x2F;たいへん很，非常</p><p>少(すこ)し&#x2F;ちょっと一点儿</p><p>あまり　+ 否定　不太～</p><p>全然（ぜんぜん）+ 否定　根本不～</p><p>この　料理（りょうり）は　とても　おいしいです<br>这个菜非常好吃</p><p>この　スープは　少（すこ）し　辛（から）いです<br>这个汤有点辣</p><p>試験（しけん）は　全然（ぜんぜん）　難（むずか）しく　ありませんでした<br>考试一点儿也不难</p><blockquote><p>汉语中形容词前面的 很 有时并不表示程度很重。今天<span style="color:red">很热</span>&#x2F;今天热</p><p>日语中使用とても等则强调程度非常重要</p></blockquote><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><h4 id="多（おお）い-和-少（すく）ない"><a href="#多（おお）い-和-少（すく）ない" class="headerlink" title="多（おお）い　和　少（すく）ない"></a>多（おお）い　和　少（すく）ない</h4><p>多い和少ない不能单独修饰名词</p><p>不能说“多い本”和“少ない本”，只能说“<strong>本は多いです</strong>”和“<strong>本が少ないです</strong>”，或者换词“たくさんの本”</p><h4 id="あら"><a href="#あら" class="headerlink" title="あら"></a>あら</h4><p>あら　是女性感到惊讶或疑惑不解时使用的词语，由　あれ（男女通用）变化而来</p><h4 id="熱（あつ）く-ないですか-否定疑问句"><a href="#熱（あつ）く-ないですか-否定疑问句" class="headerlink" title="熱（あつ）く　ないですか[否定疑问句]"></a>熱（あつ）く　ないですか[否定疑问句]</h4><p>熱く　ないですか　水不烫吗？<br>——はい、熱く　ないです　是的，不烫<br>——いいえ、熱く　ないです　不，不烫</p><h4 id="ちょうど-いい"><a href="#ちょうど-いい" class="headerlink" title="ちょうど　いい"></a>ちょうど　いい</h4><p>ちょうど　いいです　表示时间或分量等合适</p><h4 id="お湯-ゆ-和-水-みず"><a href="#お湯-ゆ-和-水-みず" class="headerlink" title="お湯(ゆ)　和　水(みず)"></a>お湯(ゆ)　和　水(みず)</h4><p>お湯 指开水或热水，水仅指凉水</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第八课</title>
    <link href="/2026/01/18/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E5%85%AB%E8%AF%BE/"/>
    <url>/2026/01/18/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E5%85%AB%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第八课小李用日语写信"><a href="#第八课小李用日语写信" class="headerlink" title="第八课小李用日语写信"></a>第八课小李用日语写信</h2><h3 id="动词原形"><a href="#动词原形" class="headerlink" title="动词原形"></a>动词原形</h3><p><img src="/2025/11/01/Android-%E6%97%A7%E7%89%88%E6%9C%AC%E5%8C%85%E9%97%AE%E9%A2%98/Base.png" alt="动词原形"></p><p><img src="/2025/11/01/Android-%E6%97%A7%E7%89%88%E6%9C%AC%E5%8C%85%E9%97%AE%E9%A2%98/Base1.png" alt="动词原形1"></p><p><img src="/2025/11/01/Android-%E6%97%A7%E7%89%88%E6%9C%AC%E5%8C%85%E9%97%AE%E9%A2%98/Base2.png" alt="动词原形2"></p><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>李さんは　日本語（にほんご）で　手紙（てがみ）を　書（か）きます<br>小李用日语写信</p><p>私は　小野さんに　お土産（みやげ）を　あげます<br>我送礼物给小野女士</p><p>私は　小野さんに　辞書（じしょ）を　もらいました<br>小野女士给了我一本词典</p><p>李さんは　明日（あした）　長島（ながしま）さんに　会（あ）います<br>小李明天见长岛先生</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="1-名-工具-で-动"><a href="#1-名-工具-で-动" class="headerlink" title="1.名[工具]で　动"></a>1.名[工具]で　动</h4><p>で 还可以用来表示其他<strong>手段</strong>及<strong>原料</strong></p><p>李さんは　日本語　で　手紙を　書きます</p><p>手紙を　速達（そくたつ）で　送（おく）りました<br>用速递寄了信</p><p>新聞紙（しんぶんし）で　紙（かみ）飛行機（ひこうき）を　作（つく）りました<br>用报纸折了纸飞机</p><p>何　で　うどんを　作（つく）りますか<br>用什么做面条？</p><p>昨天我没有用日语写日记<br>昨日、私は　日本語で　日記（にっき）を　つけませんでした</p><blockquote><p>　日記を書く　强调写日记的动作</p><p>　日記をつける　强调记日记，习惯用法</p></blockquote><h4 id="2-名1-人-は-名2-人-に-名3-物-を-あげます"><a href="#2-名1-人-は-名2-人-に-名3-物-を-あげます" class="headerlink" title="2.名1[人]は 名2[人]に 名3[物]を　あげます"></a>2.名1[人]は 名2[人]に 名3[物]を　あげます</h4><p>あげます 表示“<strong>给</strong>”。物品用助词“<strong>を</strong>”表示，<span style="color:red">接受者</span>用助词“<strong>に</strong>”表示，表示<strong>我把东西给别人</strong></p><p>别人把东西给我用 くれます、原型 くれる</p><br><p>私は　小野さん　に　お土産　を　あげます</p><p>小野さんは　森さん　に　チョコレート　を　あげました<br>小野女士给了森先生巧克力</p><blockquote><p>あげます　表示打算给，还没有给</p><p>あげました　表示给了</p></blockquote><p>我在淘宝给小王买了一件衣服<br>私は　TAOBAOで　王さんに　服を　買(か)ってあげました（て型）</p><p>私は　TAOBAOで　王さんに　服を　あげました</p><p><span style="color:red"><strong>当第三人称其中之一是说话人的亲戚时，按说话人的立场处理</strong></span></p><p><img src="/2025/11/01/Android-%E6%97%A7%E7%89%88%E6%9C%AC%E5%8C%85%E9%97%AE%E9%A2%98/u.png" alt="あげる的用法"></p><p>弟（おとうと）は　小野さん　に　花（はな）を　あげました<br>弟弟送花给小野女士</p><p>母（はは）は　長島（ながしま）さん　ワインを　あげました<br>母亲送葡萄酒给长岛先生</p><h4 id="3-名1-人-は-名2-人-に-名3-物-を-もらいます"><a href="#3-名1-人-は-名2-人-に-名3-物-を-もらいます" class="headerlink" title="3.名1[人]は 名2[人]に 名3[物]を　もらいます"></a>3.名1[人]は 名2[人]に 名3[物]を　もらいます</h4><p>もらいます 与 あげます 意思相反，表示“<strong>得到、接受</strong>”的意思。物品用“<strong>を</strong>”表示，赠送者用“<strong>に</strong>”表示（赠送者也可以看成物品移动的起点，用“<strong>から</strong>”表示）</p><p>私は　小野さん　に　辞書（じしょ）を　もらいました<br>小野女士给了我一本词典</p><p>私は　長島（ながしま）さん　<strong>から</strong>　写真（しゃしん）を　もらいました<br>我从长岛先生那儿得到了照片</p><p>森さんは　長島さん　に　パンフレット　を　もらいました<br>森先生从长岛先生那儿得到了小册子</p><p>我从小王那里得到了一本书<br>私は　王さんから　本を　もらいました</p><blockquote><p>当第三人称其中之一是说话人的亲戚时，按说话人的立场处理</p></blockquote><p><img src="/2025/11/01/Android-%E6%97%A7%E7%89%88%E6%9C%AC%E5%8C%85%E9%97%AE%E9%A2%98/u.png" alt="もらう的用法"></p><p>母は　小野さんに　ハンカチを　もらいました<br>小野女士送给母亲手绢</p><p>弟（おとうと）は　長島さんから　本を　もらいました<br>弟弟从长岛先生那儿得到一本书</p><h4 id="4-名-人-に-会-あ-います"><a href="#4-名-人-に-会-あ-います" class="headerlink" title="4.名[人]に 会(あ)います"></a>4.名[人]に 会(あ)います</h4><p>会います　表示“<strong>见</strong>”。见到的对象用助词“<strong>に</strong>”表示</p><p>李さんは　明日　長島さん　に　会います</p><p>私は　駅（えき）で　森さん　に　会いました<br>我在车站见到了森先生</p><p>我在大学见到了佐藤先生<br>私は　大学で　佐藤さん　に　会いました</p><h4 id="5-よ"><a href="#5-よ" class="headerlink" title="5.よ"></a>5.よ</h4><p>表示告知、提醒、轻微的警告</p><p>すみません、李さんは　いますか请问，小李在吗？<br>——もう　帰りました<strong>よ</strong>已经回去了[告知]</p><p>私は　毎日　アイスクリースを　食べます我每天都吃冰淇淋<br>——太（ふと）ります<strong>よ</strong>那你要发胖的[提醒、轻微的警告]</p><h4 id="6-もう"><a href="#6-もう" class="headerlink" title="6.もう"></a>6.もう</h4><p>表示完了，相当于“<strong>已经</strong>”</p><p>昼（ひる）ご飯（はん）を　食（た）べましたか你吃过午饭了吗？<br>——ええ、もう　食べました是的，我已经吃过了</p><p>你已经把数学作业写好了吗？数学（すうがく）&#x2F;算数（さんすう）の宿題（しゅくだい）は　書きましたか<br>——已经写好了[告知]ええ、もう　書きましたよ</p><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><h4 id="から-もらいます"><a href="#から-もらいます" class="headerlink" title="~から　もらいます"></a>~から　もらいます</h4><p>从“会社”或“学校”之类的<strong>组织或团体</strong>接受物品时用“<strong>から</strong>”</p><p>从个人接受时多用“に”</p><h4 id="これ、どうぞ-どうですか"><a href="#これ、どうぞ-どうですか" class="headerlink" title="これ、どうぞ&#x2F;どうですか"></a>これ、どうぞ&#x2F;どうですか</h4><p>给别人东西时用<strong>これ、どうぞ或どうですか</strong>，直接说あげます不礼貌</p><h4 id="さっき和たった今（いま）"><a href="#さっき和たった今（いま）" class="headerlink" title="さっき和たった今（いま）"></a>さっき和たった今（いま）</h4><p>さっき和たった今都表示离现在很近的过去。</p><blockquote><p>现在8:00</p><p>さっき表示<strong>刚才</strong>，7：55分</p><p>たった今表示<strong>刚刚，此时此刻</strong>，7：59分</p></blockquote><h4 id="の件（けん）"><a href="#の件（けん）" class="headerlink" title="~の件（けん）"></a>~の件（けん）</h4><p>~の件表示关于……的事情</p><h4 id="お願いします"><a href="#お願いします" class="headerlink" title="お願いします"></a>お願いします</h4><p>お願いします 表示请求对方做某事</p><h4 id="分（わ）かりました"><a href="#分（わ）かりました" class="headerlink" title="分（わ）かりました"></a>分（わ）かりました</h4><p>分かりました表示<strong>明白了和好的</strong></p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第七课</title>
    <link href="/2026/01/11/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%B8%83%E8%AF%BE/"/>
    <url>/2026/01/11/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%B8%83%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第七课小李每天都喝咖啡"><a href="#第七课小李每天都喝咖啡" class="headerlink" title="第七课小李每天都喝咖啡"></a>第七课小李每天都喝咖啡</h2><h3 id="动词原形"><a href="#动词原形" class="headerlink" title="动词原形"></a>动词原形</h3><p><img src="/2026/01/11/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%B8%83%E8%AF%BE/verbBase.png" alt="动词原形"></p><p><img src="/2026/01/11/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%B8%83%E8%AF%BE/verbBase1.png" alt="动词原形1"></p><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>李さんは　毎日（まいにち）　コーヒーを　飲（の）みます<br>小李每天喝咖啡</p><p>李さんは　図書館（としょかん）で　勉強（べんきょう）します<br>小李在图书馆学习</p><p>私は　毎朝（まいあさ）　パンか　お粥（かゆ）を　食（た）べます<br>我每天早晨吃面包或（喝）稀饭</p><p>コーラと　ケーキを　ください<br>请给我可乐和蛋糕</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="1-名を-动"><a href="#1-名を-动" class="headerlink" title="1.名を　动"></a>1.名を　动</h4><p><strong>动作的对象</strong>用助词 <span style="color:red"><strong>を（お）</strong></span> 表示</p><p>李さんは　毎日　コーヒー　<strong>を</strong>　飲みます</p><p>私は　毎日　ジョギング　<strong>を</strong>　します<br>我每天慢跑</p><p>私は　新聞（しんぶん）　<strong>を</strong>　読（よ）みません<br>我不看报</p><p>李さんは　毎朝（まいあさ）　何（なに）　<strong>を</strong>　食べますか<br>小李每天早晨吃什么？</p><p>作业写了吗？<br>宿題（しゅくだい）<strong>を</strong>　書（か）きましたか</p><p>宿題を　書きますか<br>你写作业吗？</p><h4 id="2-名-场所-で-动"><a href="#2-名-场所-で-动" class="headerlink" title="2.名[场所]で　动"></a>2.名[场所]で　动</h4><p>表示在某地做某事</p><blockquote><p>中文都用“在”表示存在的场所和动作进行的场所</p><p>日语中存在的场所用 <strong>に</strong>、动作进行的场所用　<strong>で</strong></p></blockquote><blockquote><p><strong>场所+に</strong> 表示<strong>静态的状态</strong></p><p>机の上に　パンがあります</p></blockquote><p>李さんは　図書館（としょかん）　<strong>で</strong>　勉強（べんきょう）します<br>小李在图书馆学习</p><p>私は　コンビニ　<strong>で</strong>　お弁当（べんどう）　を　買（か）います<br>我在便利店买盒饭</p><p>今日（きょう）　どこ　<strong>で</strong>　新聞（しんぶん）　を　読（よ）みましたか<br>今天，你在哪儿看报纸了？</p><p>昨天，我和小王在图书馆看了书<br>昨日（きのう）、私は　王さんと　図書館<strong>で</strong>　<span style="color:red"><strong>本を</strong></span>　読みました</p><h4 id="3-名か-名"><a href="#3-名か-名" class="headerlink" title="3.名か　名"></a>3.名か　名</h4><p>对若干名词进行选择时，名词和名词之间加“<strong>か</strong>”，相当于中文中的“<strong>或者</strong>”</p><p>私は　毎朝　パン　<strong>か</strong>　お粥を　食べます</p><p>休（やす）みは　何（なん）曜日（ようび）ですか　你星期几休息？<br>——休みは　月（げつ）曜日　<strong>か</strong>　火（か）曜日です我星期一或星期二休息</p><p>我今晚要么看动漫要么看电视剧<br>今夜（こんばん）、私は　アニメ<strong>か</strong>　<strong>ドラマ</strong>を 見（み）ます</p><h4 id="4-名を-ください"><a href="#4-名を-ください" class="headerlink" title="4.名を　ください"></a>4.名を　ください</h4><p>常用语，用于花钱购物和不花钱的索取</p><p>コーラと　ケーキを　ください</p><p>申込書（もうしこみしょ）　を　ください<br>请给我一张申请表</p><p>この　本　を　ください<br>我买这本书</p><p>请给我来一份奶酪蛋糕<br>チーズケーキを　ください</p><h3 id="表达词及解释"><a href="#表达词及解释" class="headerlink" title="表达词及解释"></a>表达词及解释</h3><h4 id="何的读法"><a href="#何的读法" class="headerlink" title="何的读法"></a>何的读法</h4><p>最基本的读音是“<strong>なに</strong>”，在<strong>助词“の”和量词前</strong>读成“<strong>なん</strong>”</p><p><img src="/2026/01/11/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%B8%83%E8%AF%BE/nani.png" alt="何的读法"></p><p>为避免误会，“<strong>で</strong>”前一般读“<strong>なに</strong>”</p><h4 id="そうですか"><a href="#そうですか" class="headerlink" title="そうですか"></a>そうですか</h4><p>应答时常用的说法。读<strong>降调</strong>时，表示理解了听到的新信息。相当于汉语“<strong>是吗</strong>”。</p><p>句尾读<strong>升调</strong>，表示对对方所说的内容<strong>持有疑问</strong></p><h4 id="そうですね"><a href="#そうですね" class="headerlink" title="そうですね"></a>そうですね</h4><p>用于<strong>同意对方的提议</strong>，“ね”的发音不能拉长</p><h4 id="じゃあ"><a href="#じゃあ" class="headerlink" title="じゃあ"></a>じゃあ</h4><p>用于<strong>承接话题，或中断谈话</strong>，相当于汉语“<strong>那么</strong>”</p><p>打招呼说<strong>再见、拜拜</strong>时用</p><p>正式场合要用“<strong>では（wa）</strong>”</p><h4 id="礼貌用语"><a href="#礼貌用语" class="headerlink" title="礼貌用语"></a>礼貌用语</h4><h5 id="失礼（しつれい）します"><a href="#失礼（しつれい）します" class="headerlink" title="失礼（しつれい）します"></a>失礼（しつれい）します</h5><p>表示“<strong>打扰、打扰一下</strong>”，去别人家时用。离开时说“<strong>失礼しました</strong>”</p><h5 id="すみません"><a href="#すみません" class="headerlink" title="すみません"></a>すみません</h5><p>表示“<strong>不好意思、对不起、你好</strong>”</p><h5 id="いってらっしゃい、いってすいります-いってきます"><a href="#いってらっしゃい、いってすいります-いってきます" class="headerlink" title="いってらっしゃい、いってすいります&#x2F;いってきます"></a>いってらっしゃい、いってすいります&#x2F;いってきます</h5><p>いってらっしゃい　表示“你慢走”</p><p>いってきます 表示出门时我走了</p><p>いってすいります 在商务等正式场合使用，也表示我走了</p><h5 id="ただいま、お帰りなさい"><a href="#ただいま、お帰りなさい" class="headerlink" title="ただいま、お帰りなさい"></a>ただいま、お帰りなさい</h5><p>ただいま　表示“我回来了”</p><p>お帰りなさい 表示“你回来了”</p><h5 id="いらっしゃいませ、かしこまりました"><a href="#いらっしゃいませ、かしこまりました" class="headerlink" title="いらっしゃいませ、かしこまりました"></a>いらっしゃいませ、かしこまりました</h5><p>いらっしゃいませ 表示“欢迎光临”</p><p>かしこまりました 表示“明白了”，店员对顾客使用</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第六课</title>
    <link href="/2026/01/10/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E5%85%AD%E8%AF%BE/"/>
    <url>/2026/01/10/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E5%85%AD%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第六课吉田先生下个月来中国"><a href="#第六课吉田先生下个月来中国" class="headerlink" title="第六课吉田先生下个月来中国"></a>第六课吉田先生下个月来中国</h2><h3 id="动词原形"><a href="#动词原形" class="headerlink" title="动词原形"></a>动词原形</h3><p><img src="/2026/01/10/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E5%85%AD%E8%AF%BE/verbBase.png" alt="动词原形"></p><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p><img src="/2026/01/10/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E5%85%AD%E8%AF%BE/dates.png" alt="日期"></p><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>吉田さんは　来月（らいげつ）　中国（ちゅうごく）へ　行（い）きます<br>吉田先生下个月去中国</p><p>李さんは　先月（せんげつ）　北京（ペキン）から　来（き）ました<br>小李上个月从北京来</p><p>小野さんは　友達（ともだち）と　帰（かえ）りました<br>小野女士和朋友（一块儿）回去</p><p>森さんは　東京（とうきょう）から　広島（ひろしま）まで　新幹線（しんかんせん）で　行きます<br>森先生从东京坐新干线去广岛</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="1-名-场所-へ-动"><a href="#1-名-场所-へ-动" class="headerlink" title="1.名[场所]へ 动"></a>1.名[场所]へ 动</h4><p>使用 <strong>行きます 帰ります</strong> 等表示<span style="color:red"><strong>移动的动词</strong></span>时，移动的目的地用助词“<strong>へ（え）</strong>”表示</p><p>吉田さんは　中国　<strong>へ</strong>　行きます</p><p>森さんは　日本（にほん）<strong>へ</strong>　帰ります<br>森先生回日本</p><p>李さんは　どこ　<strong>へ</strong>　行きましたか<br>小李去哪儿了？</p><p>昨天，你去哪了？<br>昨日（きのう）どこ　<strong>へ</strong>　行きましたか</p><h4 id="2-名-场所-から-动词"><a href="#2-名-场所-から-动词" class="headerlink" title="2.名[场所]から　动词"></a>2.名[场所]から　动词</h4><p>使用移动动词时，移动的<strong>起点</strong>用助词 から 表示</p><p>李さんは　先月　北京　から　来ました</p><p>あの方（かた）は　どこ　から　来ましたか<br>那个人是从哪儿来的？</p><p>我来自中国<br>私は　中国から　来ました</p><h4 id="3-名-人-と-动"><a href="#3-名-人-と-动" class="headerlink" title="3.名[人]と　动"></a>3.名[人]と　动</h4><p>共同做某事的对象用助词 <strong>と</strong> 表示</p><p>小野さんは　友達　と　帰りました</p><p>李さんは　だれ　と　日本へ　来ましたか<br>小李和谁一块儿来日本的？</p><p>我每天都和小王一起上学<br>毎日（まいにち）、私は　王さんと　一緒に（いっしょに）　学校（がっこう）<strong>へ</strong>　行きます</p><h4 id="4-名-交通工具-で-动"><a href="#4-名-交通工具-で-动" class="headerlink" title="4.名[交通工具]で　动"></a>4.名[交通工具]で　动</h4><p>交通工具用助词“<strong>で</strong>”表示。步行时用“歩（ある）いて”</p><p>上海（シャンハイ）まで　飛行機（ひこうき）　<strong>で</strong>　行きます<br>坐飞机去上海</p><p>私は　バス　<strong>で</strong>　家（いえ）へ　帰（かえ）ります<br>我乘公共汽车回家</p><p>李さんは　<strong>歩（ある）いて</strong>　アパートへ　帰りました<br>小李步行回公寓</p><p>京都（きょうと）へ　何（なに）<strong>で</strong>　来ましたか<br>你是怎么来京都的？</p><p>小王坐出租车回家<br>王さん　タクシー<strong>で</strong>　家へ　帰ります</p><h4 id="5-名-场所-から-名-场所-まで-动"><a href="#5-名-场所-から-名-场所-まで-动" class="headerlink" title="5.名[场所]から 名[场所]まで　动"></a>5.名[场所]から 名[场所]まで　动</h4><p>表示<strong>移动的范围时</strong>，<strong>起点</strong>用 から，<strong>终点</strong>用 まで</p><p>森さんは　東京（とうきょう）から　広島（ひろしま）まで　新幹線（しんかんせん）で　行きます</p><p>李さんは　駅（えき）から　アパートまで　歩（ある）いて　帰りました<br>小李从车站走回公寓</p><p>小李从美国乘飞机去北京<br>李さんは　アメリカから　北京まで　飛行機で　行きます<br>李さんは　飛行機で アメリカから　北京まで　行きます</p><h3 id="表达及词语"><a href="#表达及词语" class="headerlink" title="表达及词语"></a>表达及词语</h3><h4 id="たしか表示不完全有把握的记忆"><a href="#たしか表示不完全有把握的记忆" class="headerlink" title="たしか表示不完全有把握的记忆"></a>たしか表示不完全有把握的记忆</h4><p>あの人（ひと）は　誰ですか　那个人是谁？<br>——たしか　李さんの　会社（かいしゃ）の人です 我记得好象是小李他们公司的人</p><h4 id="家-和-うち-都表示“（我）家”"><a href="#家-和-うち-都表示“（我）家”" class="headerlink" title="家 和 うち 都表示“（我）家”"></a>家 和 うち 都表示“（我）家”</h4><p>家　指建筑物，表示 我家 时要加上 私の家</p><p>うち 指家人，本身就表示 我家</p><h4 id="まっすぐ-帰りました"><a href="#まっすぐ-帰りました" class="headerlink" title="まっすぐ　帰りました"></a>まっすぐ　帰りました</h4><p>まっすぐ　表示“笔直”，与 帰ります 一起使用时表示<strong>径直去某地，没有去别的地方</strong></p><p>今日（きょう）は　まっすぐ　帰ります<br>今天直接回家</p><p>道草（みちくさ）表示绕弯</p><h4 id="それ-不仅可以指眼前的事物，还可以指前面提到的事情"><a href="#それ-不仅可以指眼前的事物，还可以指前面提到的事情" class="headerlink" title="それ　不仅可以指眼前的事物，还可以指前面提到的事情"></a>それ　不仅可以指眼前的事物，还可以指前面提到的事情</h4><p>毎日（まいにち）夜（よる）11時（じゅういちじ）まで　働（はたら）きます我每天工作到夜里11点<br>——それは　大変（だいへん）ですね那你可真不容易</p><h4 id="お疲（つか）れ様（さま）でした"><a href="#お疲（つか）れ様（さま）でした" class="headerlink" title="お疲（つか）れ様（さま）でした"></a>お疲（つか）れ様（さま）でした</h4><p>体谅、安慰对方使用的词语。也用于工作结束后的寒暄用语</p><h4 id="終電（しゅうでん）"><a href="#終電（しゅうでん）" class="headerlink" title="終電（しゅうでん）"></a>終電（しゅうでん）</h4><p>日语把末班电车称为“最終電車（さいしゅうでんしゃ）”，简称为“終電”</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日语动词三分类</title>
    <link href="/2026/01/08/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D%E4%B8%89%E5%88%86%E7%B1%BB/"/>
    <url>/2026/01/08/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D%E4%B8%89%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="所有的动词原形都是由う段结尾"><a href="#所有的动词原形都是由う段结尾" class="headerlink" title="所有的动词原形都是由う段结尾"></a>所有的动词原形都是由う段结尾</h2><p><img src="/2026/01/08/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D%E4%B8%89%E5%88%86%E7%B1%BB/50Oto.png" alt="五十音图"></p><h2 id="一类动词（五段动词）"><a href="#一类动词（五段动词）" class="headerlink" title="一类动词（五段动词）"></a>一类动词（五段动词）</h2><p><strong>1.结尾是う段非る的动词，肯定是5段动词</strong></p><p>書く　かく<br>写</p><p>探す　さがす<br>搜索</p><p>勝つ　かつ<br>赢</p><p>遊ぶ　あそぶ<br>玩</p><p>読む　よむ<br>读</p><br><p><strong>2.あ段+る、う段+る、お段+る（看最后面两个读音）</strong></p><p>困る　こまる<br>为难；困惑；难办；陷入困境；感到困扰</p><p>怒る　おこる<br>生气；发怒</p><p>やる<br>做；给；进行；派遣</p><br><p><strong>3.特例</strong></p><p><strong>切る</strong>　きる　い段+る　<br>切断；终止；断开；关闭；剪裁；划破；切换；减少；砍伐；离开；割伤；切断关系</p><p><strong>帰る</strong>　かえる　え段+る<br>返回；回家；回到（某地）</p><p><strong>走る</strong>　はしる　い段+る<br>跑；行驶；奔向；贯穿；延伸</p><h2 id="二类动词（上一段动词、下一段动词）"><a href="#二类动词（上一段动词、下一段动词）" class="headerlink" title="二类动词（上一段动词、下一段动词）"></a>二类动词（上一段动词、下一段动词）</h2><blockquote><p>あ　い　う　え　お</p><p>う在中间，あ、い是う的上一段，え、お是う的下一段</p></blockquote><p><strong>い段+る</strong> 上一段动词</p><p><strong>え段+る</strong> 下一段动词</p><br><p>おきるい段+る<br>起床；发生；站起来</p><p>たべるえ段+る<br>吃；进食；用餐</p><p>みえるえ段+る<br>看得见；显得；看起来</p><p>おしえるえ段+る<br>传授；教导；教育；告知；指点</p><p>きる い段+る<br>切断；终止；断开；关闭；剪裁；划破；切换；减少；砍伐；离开；割伤；切断关系</p><p>うけるえ段+る<br>接受; 遭受; 获得; 受到（影响）; 参加（考试）</p><h2 id="三类动词（カ变、サ变）"><a href="#三类动词（カ变、サ变）" class="headerlink" title="三类动词（カ变、サ变）"></a>三类动词（カ变、サ变）</h2><p><strong>くる</strong> 来</p><p><strong>する</strong>　做</p><p><strong>名词</strong>+する</p><br><p>会う（あう）：见面，一类动词</p><p>開ける（あける）：打开，二类动词</p><p>洗濯する（せんたくする）：洗衣服，三类动词</p><p>来る（くる）：来，<strong>三类动词</strong></p><br><p>吸う（すう）：吸，一类动词</p><p>調べる（しらべる）：调查，二类动词</p><p>走る（はしる）：跑，<strong>一类动词</strong></p><p>勉強する（べんきょうする）：学习，三类动词</p><h2 id="动词原形变为ます型"><a href="#动词原形变为ます型" class="headerlink" title="动词原形变为ます型"></a>动词原形变为ます型</h2><h3 id="一类动词"><a href="#一类动词" class="headerlink" title="一类动词"></a>一类动词</h3><p><img src="/2026/01/08/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D%E4%B8%89%E5%88%86%E7%B1%BB/50Oto.png" alt="五十音图"></p><p><strong>公式：う段 ー い段 + ます</strong></p><p>五十音图中<strong>う段变为同行的い段再加ます</strong></p><p>書く　かく　ー　書きます</p><p>吸う　すう　ー　吸います</p><p>切る　きる　ー　切ります</p><p>呼ぶ　よぶ　ー　呼びます</p><h3 id="二类动词"><a href="#二类动词" class="headerlink" title="二类动词"></a>二类动词</h3><p><strong>公式：る　ー　ます</strong></p><p>直接将结尾的<strong>る变为ます</strong></p><p>教える　おしえる　ー　教えます</p><p>開ける　あける　ー　開けます</p><p>調べる　しらべる　ー　調べます</p><p>得る　える　ー　得ます</p><h3 id="三类动词"><a href="#三类动词" class="headerlink" title="三类动词"></a>三类动词</h3><p><strong>公式：</strong></p><p><strong>来る（くる）　ー　来ます（きます）</strong><br><strong>する　ー　します</strong></p><p>勉強する　べんきょうする　ー　勉強します</p><p>散歩する　さんぽする　ー　散歩します</p><p>努力する　どりょくする　ー　努力します</p><h3 id="ます型变回原型"><a href="#ます型变回原型" class="headerlink" title="ます型变回原型"></a>ます型变回原型</h3><p><img src="/2026/01/08/%E6%97%A5%E8%AF%AD%E5%8A%A8%E8%AF%8D%E4%B8%89%E5%88%86%E7%B1%BB/50Oto.png" alt="五十音图"></p><p>働きます　はたらきます１</p><p>はたらきます　ー　はたらき　ー　はたらく</p><p>始まります　はじまります１</p><p>はじまります　ー　はじまり　ー　はじまる</p><p>終わります　おわります　１</p><p>おわります　ー　おわり　ー　おわる</p><p>起きます　おきます　２</p><p>おきます　ー　おき　ー　おきる</p><p>寝ます　ねます　２</p><p>ねます　ー　ね　ー　ねる</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日语</tag>
      
      <tag>动词</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第五课</title>
    <link href="/2026/01/08/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%BA%94%E8%AF%BE/"/>
    <url>/2026/01/08/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%BA%94%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><h2 id="第五课森先生7点起床"><a href="#第五课森先生7点起床" class="headerlink" title="第五课森先生7点起床"></a>第五课森先生7点起床</h2><h3 id="动词原形"><a href="#动词原形" class="headerlink" title="动词原形"></a>动词原形</h3><p><img src="/2026/01/08/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%BA%94%E8%AF%BE/verbBase.png" alt="动词原形"></p><h3 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h3><p><img src="/2026/01/08/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%BA%94%E8%AF%BE/time.png" alt="日语时间读音"></p><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>今（いま）　四時（よじ）です<br>现在4点</p><p>森さんは　七時（しちじ）に　起（お）きます<br>森先生7点起床</p><p>森さんは　先週（せんしゅう）　休（やす）みました<br>森先生上周休息</p><p>わたしは　昨日（きのう）　働（はたら）きませんでした<br>我昨天没上班</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><strong>1.动词</strong></p><p>ます　用于<span style="color:red"><strong>肯定</strong>地叙述现在的习惯性动作、状态以及未来的动作、状态</span>，<strong>否定</strong>形式是 ません</p><p>ました　用于肯定地叙述<strong>过去</strong>的动作，<strong>否定</strong>形式是 ませんでした</p><p><strong>示例：</strong></p><p>原形：働く（はたらく）工作</p><p>ます型：働きます　ます型否定：働きません</p><p>过去：働きました　过去否定：働きませんでした</p><br><div class="center"><table><thead><tr><th align="center">原形</th><th align="center">ます型</th><th align="center">否定（ません）</th><th align="center">过去（ました）</th><th align="center">过去否定（ませんでした）</th></tr></thead><tbody><tr><td align="center">帰る（かえる）</td><td align="center">帰ります</td><td align="center">帰りません</td><td align="center">帰りました</td><td align="center">帰りませんでした</td></tr><tr><td align="center">行く（いく）</td><td align="center">行きます</td><td align="center">行きません</td><td align="center">行きました</td><td align="center">行きませんでした</td></tr><tr><td align="center">出会う（であう）</td><td align="center">出会います</td><td align="center">出会いません</td><td align="center">出会いました</td><td align="center">出会いませんでした</td></tr></tbody></table></div><br><p>原形：運動（うんどう）する<br>ます型：運動します<br>否定：運動しません</p><p>ます型：寝（ね）ます<br>过去：寝ました</p><p>否定：ありません<br>过去否定：ありませんでした</p><p>ます型：休（やす）みます<br>否定：休みません</p><br><p><strong>2.名[时间]に 动词</strong></p><p>表示动作发生的时间时，要在<strong>具体时间</strong>词语后加上助词“<strong>に</strong>”</p><p>森さんは　七時（しちじ）　に　起（お）きます<br>森先生7点起床</p><p>学校（がっこう）は　8時（はちじ）半（はん）　に　始（はじ）まります<br>学校8点半开始上课</p><blockquote><p><span style="color:red">今、昨日、今日、明日、每日、去年、来年</span> 不需要加 に</p><p>月曜日ー日曜日　<span style="color:red">一般加 に</span>，根据情况也可不加</p></blockquote><p><strong>将时间词放在最前面可以不加 に</strong></p><p>七時、森さんは起きます</p><p>八時半、学校は始まります</p><p>我昨天8点起床<br>私は昨日（きのう）の8時起きました<br>昨日の8時、私は起きました</p><br><p><strong>3.名[时间]から 名[时间]まで 动词</strong></p><p>表示某动作发生在某个期间时，用 ～から（表示从……）　〜まで（表示到……）</p><p>私は　九時（くじ）　から　5時（ごじ）　まで　働（はたら）きます<br>我从9点工作到5点 </p><p>森さんは　月曜日（げつようび）　から　水曜日（すいようび）　まで　休（やす）みました<br>森先生从星期一休息到星期三</p><blockquote><p>から 和 まで 也可以分开使用</p></blockquote><p>私は　九時から　働きます<br>我从9点开始工作</p><p>王さんは　九時まで　働きます<br>王先生工作到了9点</p><p>我学习到夜里2点<br>私は　夜中（よるなか）の2時まで　勉強（べんきょう）しました</p><br><p><strong>4.いつ　动词　ますか</strong></p><p>询问什么时候做某事</p><blockquote><p>常见词：何時（なんじ）に、何曜日（なんようび）に、何日（なんにち）に</p></blockquote><p>試験（しけん）は　いつ　始（はじ）まりましか<br>什么时候开始考试？</p><p>仕事（しごと）は　何時に　終（お）わりますか<br>工作几点结束？</p><p>展覧会（てんらんかい）は　いつから　始まりますか<br>展览会从什么时候开始？</p><p>張さんは　何曜日にまで　休（やす）みますか  小张休息到星期几？<br>火曜日（かようび）までです  休息到星期二</p><p>什么时候开学？<br>学校は　いつ　始まりますか</p><br><blockquote><p>当两个名词都表示时间，前面的名词中包含“<strong>每</strong>”时，<strong>两个名词之间不加“の”</strong></p><p>森さんは　毎日（まいにち）　七時（しちじ）に　起きます（不用“毎日の七時”）</p></blockquote><blockquote><p><strong>ごろ</strong>　接在表示时间的词语后面表示大致的时间范围</p><p>１時ごろ、１時30分ごろ</p><p>ごろ　后不加 に</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日语建筑设施</title>
    <link href="/2026/01/07/%E6%97%A5%E8%AF%AD%E5%BB%BA%E7%AD%91%E8%AE%BE%E6%96%BD/"/>
    <url>/2026/01/07/%E6%97%A5%E8%AF%AD%E5%BB%BA%E7%AD%91%E8%AE%BE%E6%96%BD/</url>
    
    <content type="html"><![CDATA[<style>.center {width: auto;display: table;margin-left: auto;margin-right: auto;}</style><div class="center"><table><thead><tr><th align="center">日语</th><th align="center">中文</th></tr></thead><tbody><tr><td align="center">ビル&#x2F;建物（たてもの）</td><td align="center">大楼，建筑物</td></tr><tr><td align="center">&nbsp;</td><td align="center">&nbsp;</td></tr><tr><td align="center">映画館（えいがかん）</td><td align="center">电影院</td></tr><tr><td align="center">美術館（びじゅつかん）</td><td align="center">美术馆</td></tr><tr><td align="center">体育館（たいいくかん）</td><td align="center">体育馆</td></tr><tr><td align="center">博物館（はくぶつかん）</td><td align="center">博物馆</td></tr><tr><td align="center">図書館（としょかん）</td><td align="center">图书馆</td></tr><tr><td align="center">&nbsp;</td><td align="center">&nbsp;</td></tr><tr><td align="center">公園（こうえん）</td><td align="center">公园</td></tr><tr><td align="center">動物園（どうぶつえん）</td><td align="center">动物园</td></tr><tr><td align="center">遊園地（ゆうえんち）</td><td align="center">游乐园</td></tr><tr><td align="center">&nbsp;</td><td align="center">&nbsp;</td></tr><tr><td align="center">駅（えき）</td><td align="center">车站</td></tr><tr><td align="center">空港（くうこう）</td><td align="center">机场</td></tr><tr><td align="center">市役所（しやくしょ）</td><td align="center">市政所</td></tr><tr><td align="center">消防署（しょうぼうしょ）</td><td align="center">消防局</td></tr><tr><td align="center">警察署（けいさつしょ）</td><td align="center">警察局</td></tr><tr><td align="center">交番（こうばん）</td><td align="center">派出所</td></tr><tr><td align="center">病院（びょういん）</td><td align="center">医院</td></tr><tr><td align="center">&nbsp;</td><td align="center">&nbsp;</td></tr><tr><td align="center">銀行（ぎんこう）</td><td align="center">银行</td></tr><tr><td align="center">郵便局（ゆうびんきょく）</td><td align="center">邮局</td></tr><tr><td align="center">&nbsp;</td><td align="center">&nbsp;</td></tr><tr><td align="center">工場（こうじょう）</td><td align="center">工厂</td></tr><tr><td align="center">劇場（げきじょう）</td><td align="center">剧场</td></tr><tr><td align="center">駐車場（ちゅうしゃじょう）</td><td align="center">停车场</td></tr><tr><td align="center">&nbsp;</td><td align="center">&nbsp;</td></tr><tr><td align="center">学校（がっこう）</td><td align="center">学校</td></tr><tr><td align="center">&nbsp;</td><td align="center">&nbsp;</td></tr><tr><td align="center">お店（みせ）</td><td align="center">商店，小店</td></tr><tr><td align="center">本屋（ほんや）</td><td align="center">书店</td></tr><tr><td align="center">八百屋（やおや）</td><td align="center">蔬菜店</td></tr><tr><td align="center">肉屋（にくや）</td><td align="center">肉店</td></tr><tr><td align="center">魚屋（さかなや）</td><td align="center">鱼店</td></tr><tr><td align="center">蕎麦屋（そばや）</td><td align="center">荞麦面店</td></tr><tr><td align="center">床屋（とこや）</td><td align="center">理发店</td></tr><tr><td align="center">薬局（やっきょく）</td><td align="center">药店</td></tr><tr><td align="center">喫茶店（きっさてん）</td><td align="center">咖啡馆</td></tr><tr><td align="center">&nbsp;</td><td align="center">&nbsp;</td></tr><tr><td align="center">ホテル</td><td align="center">宾馆</td></tr><tr><td align="center">デパート</td><td align="center">百货商店</td></tr><tr><td align="center">スーパー</td><td align="center">超市</td></tr><tr><td align="center">コンビニ</td><td align="center">便利店</td></tr><tr><td align="center">レストラン</td><td align="center">餐馆，西餐馆</td></tr><tr><td align="center">ガソリンスタンド</td><td align="center">加油站</td></tr></tbody></table></div><p><strong>注：</strong></p><p>在表格中添加空格 <code>&amp;nbsp;</code> 来占位，否则单元格不会填充</p><p>表格在页面整体中居中显示，在 <code>Markdown</code> 中添加如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;style&gt;<br>.<span class="hljs-property">center</span> &#123;<br><span class="hljs-attr">width</span>: auto;<br><span class="hljs-attr">display</span>: table;<br>margin-<span class="hljs-attr">left</span>: auto;<br>margin-<span class="hljs-attr">right</span>: auto;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>并将表格置于 <code>&lt;div&gt;&lt;/div&gt;</code> 中</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/jianmuzi/p/16795528.html">https://www.cnblogs.com/jianmuzi/p/16795528.html</a></p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将Markdown源码上传到Github</title>
    <link href="/2026/01/07/%E5%B0%86Markdown%E6%BA%90%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0Github/"/>
    <url>/2026/01/07/%E5%B0%86Markdown%E6%BA%90%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0Github/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>使用 <code>hexo</code> 的部署方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate  // hexo g<br>hexo deploy  // hexo d<br></code></pre></td></tr></table></figure><p>只能将编译后的网页推送到 <code>Github</code> 仓库，无法推送 <code>Markwon</code> 源文件。</p><p>可以在仓库中创建一个分支，将 <code>Markwon</code> 文件对应的文件夹推送到这个分支。</p><p>在本地配置完成后，后续只需在对应的文件夹中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;Add my blog source files&quot;</span><br>git push<br></code></pre></td></tr></table></figure><p>就可以将 <code>Markdown</code> 源代码上传到对应的分支</p><h2 id="初始化Git"><a href="#初始化Git" class="headerlink" title="初始化Git"></a>初始化<code>Git</code></h2><p>在需要上传的文件夹目录初始化 <code>Git</code>，并创建新的源码分支（例如<code>source-branch</code>）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br>git checkout -b source-branch<br></code></pre></td></tr></table></figure><h2 id="添加-提交文件"><a href="#添加-提交文件" class="headerlink" title="添加&#x2F;提交文件"></a>添加&#x2F;提交文件</h2><p>将需要上传的文件夹目录添加到 <code>Git</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 将本地工作区中所有修改 / 新增 / 删除的文件，添加到 Git 的 “暂存区”<br>git add .<br>// 将暂存区的文件正式 “提交” 到本地 Git 仓库，生成一个新的提交记录<br>git commit -m <span class="hljs-string">&quot;Add my blog source files&quot;</span><br></code></pre></td></tr></table></figure><h2 id="将-source-branch-推送到-Github-仓库"><a href="#将-source-branch-推送到-Github-仓库" class="headerlink" title="将 source-branch 推送到 Github 仓库"></a>将 <code>source-branch</code> 推送到 <code>Github</code> 仓库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin &lt;Github仓库地址&gt;<br>/*<br>告诉 Git，本地的 source-branch 分支要追踪远程 origin 仓库下的同名分支<br>建立后，后续在这个分支下只需输入 git push/git pull<br>Git 就知道要推 / 拉到哪个远程分支，无需重复写完整命令<br><br>origin 是远程仓库的默认别名，指向代码托管平台上的远程仓库地址<br><br>source-branch 是要推送的本地分支名称<br>命令会把这个分支的所有本地提交推到远程 origin 仓库的同名分支（如果远程没有这个分支，会自动创建）<br>*/<br>git push -u origin source-branch<br></code></pre></td></tr></table></figure><p><img src="/2026/01/07/%E5%B0%86Markdown%E6%BA%90%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0Github/githubAddr.png" alt="&#96;Github&#96;仓库地址"></p><p><code>Github</code> 仓库地址是 <code>Github</code> 仓库中 <code>Code</code> 按钮下方展开显示的链接选项</p><br><p><span style="color:red">注：</span></p><p>直接输入 <code>git push -u origin source-branch</code> 会提示输入用户名和密码，但是 <code>Github</code> 不再<br>支持使用账号密码进行 <code>Git https</code> 推送，可以采用 <a href="%60ssh%60%E5%AF%86%E9%92%A5"><code>ssh</code> 密钥</a>的方式进行推送</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/Dasi_C_upup/article/details/151193854">https://blog.csdn.net/Dasi_C_upup/article/details/151193854</a></p>]]></content>
    
    
    <categories>
      
      <category>Markdown</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第四课</title>
    <link href="/2026/01/06/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E5%9B%9B%E8%AF%BE/"/>
    <url>/2026/01/06/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E5%9B%9B%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第四课房间里有桌子和椅子"><a href="#第四课房间里有桌子和椅子" class="headerlink" title="第四课房间里有桌子和椅子"></a>第四课房间里有桌子和椅子</h2><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>部屋（へや）に　机と　いすが　あります<br>房间里有桌子和椅子</p><p>机の　上（うえ）に　猫（ねこ）が　います<br>桌子上面有一只猫</p><p>売店（ばいてん）は　駅（えき）の　外（そと）に　あります<br>小卖部在车站的外边</p><p>吉田さんは　庭（にわ）に　いすま<br>吉田先生在院子里</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>1.あります | います</p><p>あります表示“<strong>有</strong>”，用于花、草、桌子等<strong>不具有意志的事务</strong></p><p><span style="color:red">名[场所]<strong>に</strong> 名[物]<strong>が</strong>　あります</span><br>表示某地有某物，に　强调存在的地点</p><br><p>部屋に　机が　あります<br>房间里有一张桌子</p><p>ここに　本が　あります<br>这里有一本书</p><p>庭に　何（なに）が　ありますか<br>院子里有什么？</p><p>桌子上有一台电脑<br>机に　パソコンが　あります</p><blockquote><p>何（なん）</p><p>询问数量：如「何人 (なんにん)」(多少人)、「何時 (なんじ)」(几点)、「何回 (なんかい)」(几次)</p><p>接「だ、です、の」：如「これは何だ (これはなんだ)」(这是什么)</p><p>接「で」：表示“为什么”或“怎么做”，例如「何で行きますか (なんでいきますか)」 (为什么去&#x2F;怎么去)</p></blockquote><blockquote><p>何（なに）</p><p>询问内容&#x2F;种类：如「何を (なにを)」(什么东西)、「何語 (なにご)」(哪国话)</p><p>接「が、を、も、に」：如「何がありますか (なにがありますか)」(有什么)</p><p>接「で」：表示“用什么方法&#x2F;交通工具”，例如「何で行きますか (なにでいきますか)」(用什么去)</p></blockquote><br><p>います也表示“<strong>有</strong>”，用于<strong>具有意志的</strong>人、动物、昆虫</p><p><span style="color:red">名[场所]<strong>に</strong> 名[人]<strong>が</strong>　います</span><br>表示某地有某人</p><p>部屋に　猫が　います<br>房间里有一只猫</p><p>公園（こうえん）に　子供（こども）が　います<br>公园里有孩子</p><p>あそこに　誰が　いますか<br>那里有谁？</p><p>桌子下面有一只猫<br>机の下（した）に　猫が　います</p><br><p><span style="color:red">名[物]<strong>は</strong> 名[场所]<strong>に</strong>　あります</span><br>表示某物在某地</p><p>いすは　部屋に　あります<br>椅子在房间里</p><p>本は　ここに　あります<br>书在这里</p><p>図書館（としょかん）は　どこに　ありますか<br>图书馆在哪里？</p><p>笔记本在桌子上面<br>手帳（てちょう）は　机に　あります</p><br><p><span style="color:red">名[人]<strong>は</strong> 名[场所]<strong>に</strong>　います</span><br>表示某人在某地</p><p>吉田（よしだ）さんは　庭に　います<br>吉田先生在院子里</p><p>子供（こども）は　公園（こうえん）に　います<br>孩子在公园里</p><p>犬（いぬ）は　どこに　いますか<br>狗在哪里？楼上</p><p>猫在箱子里面<br>猫は　箱（はこ）の中（なか）に　います</p><br><p>「〜は　どこですか」可以替换为「〜は　どこに　ありますか」和「〜は　どこに　いますか」，但不常用</p><p>小野さんの　家（いえ）は　どこですか<br>小野さんの　家は　どこに　ありますか</p><p>林さんは　どこ　ですか<br>林さんは　どこに　いますか</p><br><p>2.名 と 名</p><p>助词“<strong>と</strong>”加在两个名词之间表示<strong>并列</strong>，相当于汉语的“和”</p><p>時計（とけい）　と　眼鏡（めがね）<br>表和眼镜</p><p>ビール　と　ワイスキー<br>啤酒和威士忌</p><p>居間（いま）&#x2F;リビング に　テレビ　と　ビデオが　あります<br>起居室&#x2F;客厅里有电视机和录像机</p><p>冰箱里有可乐和蛋糕<br>冷蔵庫（れいぞうこ）に　コーラー　と　ケーキ が　あります<br>コーラー と ケーキ は　冷蔵庫 に あります</p><br><p>3.上（うえ）&#x2F;下（した）&#x2F;前（まえ）&#x2F;後（うし）ろ&#x2F;<strong>隣（となり）</strong>&#x2F;中（なか）&#x2F;外（そと）</p><p>名词 + の + 方位</p><p>机の　上に　ねこが　います<br>桌子上面有一只猫</p><p>会社の　隣に　花屋（はなや）が　あります<br>公司旁边有花店</p><p>猫は　箱（はこ）の　中に　います<br>猫在箱子里</p><p>売店（ばいてん）は　駅（えき）の　外に　あります<br>小卖部在车站的外边</p><p>学校在邮局的前面<br>学校（がっこ）は　郵便局（ゆうびんきょく）の　前に　あります</p><blockquote><p>日语中“上”表示的是位于绝对平面之上</p><p>日语中墙上（壁の上）指的是天花板，不是垂直的墙壁。</p><p>表达“墙上有开关”：壁（かべ）にスイッチがあります</p></blockquote><br><p>4.ね</p><p>当说话人就某事征求听话人的同意时，句尾用动词 ね，读<span style="color:red">升调</span></p><p>あそこに　犬（いぬ）が　いますね<br>那儿有一只狗</p><p>この　新聞（しんぶん）は　林さんのですね<br>这报纸是林先生的吧</p><p>駅（えき）の　まえに　銀行（ぎんこう）が　ありますね<br>车站前面有家银行吧</p><br><p>5.疑问句 + も + 动词表示<strong>全面否定</strong>，声调<strong>从低往上</strong></p><blockquote><p>います 的否定是 <strong>いません</strong><br>あります 的否定是 <strong>ありません</strong></p></blockquote><p>教室（きょうしつ）に　だれも　<strong>いません</strong><br>教室里一个人也没有</p><p>冷蔵庫に　何も　<strong>ありません</strong><br>冰箱里什么也没有</p><p>房间里没有人<br>部屋に　だれも　いません</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第三课</title>
    <link href="/2026/01/05/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%B8%89%E8%AF%BE/"/>
    <url>/2026/01/05/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%B8%89%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第三课这里是商场"><a href="#第三课这里是商场" class="headerlink" title="第三课这里是商场"></a>第三课这里是商场</h2><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>ここは　デパートです<br>这里是百货商店</p><p>食堂（しょくどう）は　デパートの　７階（ななかい）です<br>食堂在百货商店的7楼</p><p>あそこも　JC（ジェーシー）企画（きかく）の　ビルです<br>那里也是JC策划公司的大楼</p><p>かばん売（う）り場（ば）は　一階（い<span style="color:red">っ</span>かい）ですか、２階（にかい）ですか<br>卖包的柜台在一楼还是二楼？</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>1.ここ&#x2F;そこ&#x2F;あそこ　は　名　です  |  <span style="color:red">こそあ　ど（疑问词，哪里 どこ）</span></p><p>用 ここ&#x2F;そこ&#x2F;あそこ 指示<strong>场所</strong>，表示的位置关系与 これ&#x2F;それ&#x2F;あれ 相同，偏口语</p><p>こちら&#x2F;そちら&#x2F;あちら　是比较<strong>正式、有礼貌</strong>的表达，可以指场所和人</p><p>这位是…… この人、この方、こちら、こちらの方</p><p>哪一位？ どちらさまですか</p><br><p>ここ　は　デパートです<br>这里是百货商店</p><p>そこ　は　図書館（としょかん）です<br>那里是图书馆</p><p>あそこ　は　入（い）り口（ぐち）です<br>那儿是入口</p><p>那里是便利店（远距离）<br>あそこコンビニです</p><br><p>2.名は 名<span style="color:red">[场所]</span>　です</p><p>表示“名词”存在于“名词[场所]”</p><br><p>食堂　は　デパートの　７階　です<br>食堂在百货商店的7层</p><p>トイレ　は　ここ　です<br>厕所在这儿</p><p>小野さん　は　事務所（じむしょ）です<br>小野女士在事务所</p><p>洗手间在超市的2楼<br>トイレ&#x2F;お手洗い（おてあらい）　は　スーパーの２階です</p><br><p>3.名 は　<span style="color:red">どこ</span>ですか</p><p>用于询问场所</p><p>トイレは　どこ　ですか厕所在哪儿？<br>——あちら（あそこ）です在那儿</p><p>あなたの　かばんは　どこですか你的包在哪里？<br>——わたしの　かばんは　ここです我的包在这儿</p><p>打扰一下，请问ABC大学在哪里？<br>すみません、ABC大学は　どこですか</p><br><p>4.名も　名です</p><p>助词“<strong>も</strong>”相当于汉语的“<strong>也</strong>”</p><p>ここ　は　JC企画の　ビルです<br>这里是JC策划公司的大楼</p><p>あそこ　も　JC企画の　ビルです<br>那里也是JC策划公司的大楼</p><p>李さん　は　中国人です<br>小李是中国人</p><p>張さん　も　中国人です<br>小张也是中国人</p><p>あなた　も　中国人ですか<br>你也是中国人吗？</p><p>你也是北京大学的学生吗？<br>あなた&#x2F;王さん　も　北京大学の学生ですか</p><br><p>5.名は　名ですか　名ですか  |  Aは　Bですか、Cですか、Dですか</p><p>答案有多种可能，询问其中的一种，重复使用谓语“～ですか”</p><p>かばん売り場は　一階ですか、２階ですか<br>卖包的柜台在1层还是2层？</p><p>今日（きょう）は水曜日（すいようび）ですか、木曜日（もくようび）ですか<br>今天是星期三还是星期四？</p><p>林さんは　韓国人ですか、日本人ですか、中国人ですか林先生是韩国人？日本人？还是中国人？<br>——日本人です是日本人</p><p>中村先生是医生？教师？总经理？<br>中村さんは　医者（いしゃ）ですか、教師（きょうし）ですか、社長ですか</p><br><p>6.名は　いくらですか</p><p>用“いくら”询问价钱</p><p>これは　いくらですか<br>这个多少钱？</p><p>その　服（ふく）は　いくらですか<br>那件衣服多少钱？</p><p>这件毛衣多少钱？<br>この　セーターは　いくらですか</p><p><img src="/2025/11/01/Android-%E6%97%A7%E7%89%88%E6%9C%AC%E5%8C%85%E9%97%AE%E9%A2%98/er.png" alt="100以上的数字"></p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第二课</title>
    <link href="/2026/01/02/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%BA%8C%E8%AF%BE/"/>
    <url>/2026/01/02/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%BA%8C%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第二课这是书"><a href="#第二课这是书" class="headerlink" title="第二课这是书"></a>第二课这是书</h2><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>これは　本です<br>这是书</p><p>それは　何ですか<br>那是什么？</p><p>あれは　誰の　傘ですか<br>那是谁的伞？</p><p>この　カメラは　スミスさんのです<br>这个照相机是史密斯先生的</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>1.これ(这个)&#x2F;それ(那个)&#x2F;あれ(那个，距离较远)　は　名です</p><p>用 これ&#x2F;それ&#x2F;あれ 指示<strong>事物</strong></p><p>(1) 两人对话相隔一段距离，面对面 </p><p>これ 距说话人较近的事务 [说话人的范围、领域内的事务]</p><p>それ 距听话人较近的事务 [听话人的范围、领域内的事务]</p><p>あれ 距说话人和听话人都比较远的事务 [不属于任何一方范围、领域内的事务]</p><br><p>(2) 说话人和听话人位于同一位置，面向同一方向  </p><p>こ　そ　あ　ど</p><p>こ(近距离)　そ(中距离)　あ(远距离)　ど(表示疑问词)</p><br><p>これ 距说话人、听话人较近的事务</p><p>それ 距说话人、听话人较远的事务</p><p>あれ 距说话人、听话人更远的事务</p><br><p>これは　本（ほん）です　　这是书</p><p>それは　かばん　です　　那是包</p><p>あれは　テレビ　です　　那是电视机</p><p>これは　地図（ちず）　ですか　　这是地图吗？</p><br><p>2.誰（だれ）ですか&#x2F;何（なん）ですか</p><p>誰（だれ）询问<span style="color:red">人</span>，何（なん）询问<span style="color:red">事务</span></p><p>それは　何ですか　　那是什么？</p><p>あの　人（ひと）は　誰ですか　　那个人是谁？</p><p>“だれ”（对方与自己地位相当或比自己地位低）　比较礼貌的说法（对尊长或比自己地位高的人）是 “<strong>どなた</strong>“（哪一位）</p><p>スミスさん　は　誰ですか&#x2F;<span style="color:red">どなた</span>ですか　　史密斯先生是哪一位？</p><br><p>3.名の名 [所属]</p><p>助词 “の” 连接名词和名词，表示所属</p><p>わたしの　かぎ　　我的钥匙</p><p>田中さんの　車（くるま）　　田中先生的车</p><p>これは　私の　ノートパソコン　です　　这个是我的笔记本电脑</p><br><p>4.この&#x2F;その&#x2F;あの　名は　名です</p><p>用 この&#x2F;その&#x2F;あの 修饰名词，この&#x2F;その&#x2F;あの 表示的位置关系与 これ&#x2F;それ&#x2F;あれ 相同</p><p><span style="color:red">の　后接名词</span></p><p>この　カメラは　スミスさんの[カメラ]です　　这个照相机是史密斯先生的</p><p>その　自転車（じてんしゃ）は　森さんの[自転車]です　　那辆自行车是森先生的</p><p>あの　ノートは　だれの[ノート]ですか　　那个笔记本是谁的？</p><p>この ケイタイ(手机)&#x2F;スマホ(智能手机)は　李さんの[ケイタイ&#x2F;スマホ]です</p><blockquote><p>一般要把 の　后重复的名词删掉</p><p>[] 中的内容表示省略</p></blockquote><br><p>5.どれ、どの　名</p><p>どれ どの 是在三个以上的事物中，不能确定是哪一个时所用的<span style="color:red">疑问句</span>，表示 “哪一个”</p><p><span style="color:red">单独使用用 どれ</span>，修饰名词用 どの</p><br><p>森さんの　かばんは　どれ　ですか　　森先生的包是哪个？</p><p>長島（ながしま）さんの　傘（かさ）は　どれ　ですか　　长岛先生的伞是哪一把？</p><p>小野さんの　机（つくえ）は　どの　机　ですか　　小野女士的桌子是哪一张？</p><br><p>李さんの　パソコンは　どれ　ですか　　小李的电脑是哪一台？</p><p>李さんの　パソコンは　どのパソコン　ですか　<span style="color:red">の　后的　パソコン　不能省略</span></p><h3 id="表达及词语讲解"><a href="#表达及词语讲解" class="headerlink" title="表达及词语讲解"></a>表达及词语讲解</h3><p>1.方（かた）</p><p>对长辈、工作单位的上司等应该尊敬的对象，或初次见面的人以及交往不多的人，一般使用<span style="color:red">礼貌语言</span></p><p>将 “この&#x2F;その&#x2F;あの　人” 变为 “この&#x2F;その&#x2F;あの　方” 即成为一种礼貌语言</p><br><p>2.询问年龄</p><p>年龄相近或年轻：何歳（なんさい）ですか　　多大了？</p><p>对陌生人或年长，比较礼貌的语言： おいくつ ですか　　多大年纪了？</p><p>询问孩子的年龄： “いくつ”　或 “何歳”，不用 “何歳ですか”　“おいくつですか”</p><p><img src="/2025/11/01/Android-%E6%97%A7%E7%89%88%E6%9C%AC%E5%8C%85%E9%97%AE%E9%A2%98/er.png" alt="100以下的数字"></p><br><p>3.どうぞ</p><p>请，根据场合判断请什么</p><br><p>4.叹词</p><p>(1) えっ，比较意外时感叹</p><p>(2) わあ，感动或吃惊</p><br><p>5.はい、ええ</p><p>在口语中都表示 是。ええ 更随意，偏口语。はい 是比较正式的表达</p><p><strong>别人叫到自己的名字时必须用 はい</strong></p><br><p>6.外来语</p><p>从外语引进的词（音译）称为 外来語（がいらいご，外来词），用片假名书写</p><p>古代从中国引进的词称为 漢語（かんご，汉字词），不是外来词</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新标日-初级-第一课</title>
    <link href="/2026/01/02/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%B8%80%E8%AF%BE/"/>
    <url>/2026/01/02/%E6%96%B0%E6%A0%87%E6%97%A5-%E5%88%9D%E7%BA%A7-%E7%AC%AC%E4%B8%80%E8%AF%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="第一课小李是中国人"><a href="#第一课小李是中国人" class="headerlink" title="第一课小李是中国人"></a>第一课小李是中国人</h2><p>金  キム（韩国人）　　 キン（中国人）</p><p>你好  こんにちは　　は 读 wa</p><p>是的，是（这样）  はい、そうです</p><p>不，不是  いいえ、ちがいます</p><h3 id="课文"><a href="#课文" class="headerlink" title="课文"></a>课文</h3><p>李（り）さんは　中国人（ちゅごくじん）です<br>小李是中国人</p><p>森（もり）さんは　学生（がくせい）では　ありません<br>森先生不是学生</p><p>林（はやし）さんは　日本人（にほんじん）ですか<br>林先生是日本人吗？</p><p>李さんは　JC（ジェーシー）企画（きかく）の　社員（しゃいん）です<br>小李是JC策划公司的职员</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>1.「A<span style="color:red">は</span>　Bです」，相当于汉语 “A是B”。A表示主题（包括主语）</p><p>は　作为<strong>助词</strong>（提示助词）读 wa，<span style="color:red">用于提示主题</span></p><p>〜です　是谓语部分</p><p>李さんは　中国人（ちゅうごくじん）です（主+宾+谓）　　李先生是中国人</p><p>林（はやし）さんは　日本人（にほんじん）です　　林先生是日本人</p><p>李さんは　JC企画（ジェーシーきかく）の　社員（しゃいん）です　　李先生是 JC 策划公司的职员</p><p>私は　学生です　　我是学生</p><br><p>2.「AはB　<span style="color:red">では</span>　ありません」，相当于汉语“A不是B”</p><p>有时 “では（wa）” 在口语中会发成 “じゃ”</p><p>森（もり）さんは　学生（がくせん）　では　ありません　　森先生不是学生</p><p>わたしは　日本人　では　ありません　　我不是日本人</p><p>わたしは　田中（たなか）じゃ　ありません　　我不是田中</p><p>私は　小学生（しょうがくせい）　では　ありません　　我不是小学生</p><br><p>3.「AはB です<span style="color:red">か</span>」，相当于汉语 “A是B吗？”</p><p>助词 “か” 接在句尾表示疑问。日语疑问句在句尾不使用 “？”</p><p>あなたは　小野（おの）さん　ですか　　您是小野女士吗？<br>——はい、小野　です　　是的，我是小野<br>——はい、そうです　　是的，是那样的</p><p>キムさんは　中国人　ですか　　金女士是中国人吗？<br>——いいえ、中国人 では　ありません　　不，不是中国人<br>——いいえ、ちがいます　　不，不是的</p><br><p>4.「AのB」，表示从属机构、国家或属性</p><p><span style="color:red">一般情况下</span>相当于汉语 “的” 的意思</p><p>助词 “の” 连接名词和名词，表示前面的名词是后面名词<strong>从属的机构、国家或属性</strong></p><p>李さんは<span style="color:red">JC企画の社員</span>です　　李先生是 JC 策划公司的职员</p><p>北京旅行社（ぺキンりょこうしゃ）は<span style="color:red">中国の企業（きぎょう）</span>です　　北京旅行社是中国的企业</p><p>ヂュポンさんほ<span style="color:red">大学（だいがく）の先生（せんせい）</span>です　　迪蓬先生是大学老师</p><p>王さんは北京大学の学生です　　王先生是北京大学的学生</p><h4 id="人称"><a href="#人称" class="headerlink" title="人称"></a>人称</h4><p>(1) “わたし”、“<span style="color:red">あなた</span>”、“あの人”</p><p>在不知道对方的姓名又必须打招呼的时候，才会使用第二人称 “あなた”<br>用 “あなた” 称呼对方有时会显得很不礼貌</p><p>(2) ~さん</p><p>称呼别人时，不分男女，都在其姓后加 “さん”。只用于他人的姓名后，不用于自己的姓名后</p><h4 id="省略"><a href="#省略" class="headerlink" title="省略"></a>省略</h4><p>[] 中的内容为省略</p><p>[あなたは]　吉田（よしだ）さんですか　　你是吉田先生吗<br>——いいえ、[わたしは]　吉田じゅ　ありません。[わたしは]　森です　　不，我不是吉田。我是森</p><p>小野さんは　会社員（かいしゃいん）ですか　　你是公司职员吗<br>——はい、[わたしは]　JC企画の　社員です　　是的，我是JC策划公司的职员</p><h4 id="惊叹-“あっ”"><a href="#惊叹-“あっ”" class="headerlink" title="惊叹 “あっ”"></a>惊叹 “あっ”</h4><h4 id="寒暄语-どうぞ-よろしく-お願（ねが）いします"><a href="#寒暄语-どうぞ-よろしく-お願（ねが）いします" class="headerlink" title="寒暄语 どうぞ　よろしく　お願（ねが）いします"></a>寒暄语 どうぞ　よろしく　お願（ねが）いします</h4><p>自我介绍完后接 “どうぞ　よろしく　お願（ねが）いします” 相当于汉语中的 “请多关照”</p><p>はじめまして、李です。どうぞ　よろしく　お願いします　　初次见面，我姓李，请多关照<br>——<span style="color:red">こちらこそ</span>、どうぞ　よろしく　お願いします　　我才要请你多多关照</p>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>标准日本语-初级</title>
    <link href="/2026/01/02/%E6%A0%87%E5%87%86%E6%97%A5%E6%9C%AC%E8%AF%AD-%E5%88%9D%E7%BA%A7/"/>
    <url>/2026/01/02/%E6%A0%87%E5%87%86%E6%97%A5%E6%9C%AC%E8%AF%AD-%E5%88%9D%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="日语的文字与书写方法"><a href="#日语的文字与书写方法" class="headerlink" title="日语的文字与书写方法"></a>日语的文字与书写方法</h2><h3 id="日语的文字"><a href="#日语的文字" class="headerlink" title="日语的文字"></a>日语的文字</h3><p><mark>平假名</mark>可以书写<strong>所有</strong>的日语发音，主要用于表现具有<strong>语法功能</strong>的词</p><p><mark>汉字</mark>用于表示<strong>实物的名称或动作</strong></p><p><mark>片假名</mark>用于书写<strong>外来词、拟声词、拟态词和一部分动、植物的名称</strong></p><h3 id="标点符号"><a href="#标点符号" class="headerlink" title="标点符号"></a>标点符号</h3><p>。  句号。用于句尾</p><p>， 、  逗号。横写时可以用<code>，</code>或<code>、</code>，竖写时只用<code>、</code> ，横写时不能在同一篇文章中混用<code>，</code>和<code>、</code>，统一使用其中的一种。日语没有逗号和顿号的区别。逗号使用没有严格规定。</p><p>.  中黑点。相当于汉语中连接名词的顿号<code>、</code> </p><p>「　」  单引号。相当于汉语的引号 <code>“”</code>。横写和竖写都用</p><p>『　』  双引号。相当于汉语的书名号</p><p>( )  括弧。相当于汉语的小括号</p><br><blockquote><p>单引号和双引号在微软日语输入法下输入 <strong>“&lt;”</strong> 再按空格选择</p><p><code>Mozc</code> 输入法按一下 <code>[</code> 键，再按一下空格，在候选词中选择 <code>『</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新标日</tag>
      
      <tag>初级</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android 旧版本包问题</title>
    <link href="/2025/11/01/Android-%E6%97%A7%E7%89%88%E6%9C%AC%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <url>/2025/11/01/Android-%E6%97%A7%E7%89%88%E6%9C%AC%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">import android.support.v4.app.ActivityCompat<span class="hljs-comment">;</span><br>import android.support.v7.app.AppCompatActivity<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>可改为：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">import androidx.core.app.ActivityCompat<span class="hljs-comment">;</span><br>import androidx.appcompat.app.AppCompatActivity<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-函数</title>
    <link href="/2025/10/31/JavaScript-%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0/"/>
    <url>/2025/10/31/JavaScript-%E7%AC%94%E8%AE%B0-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-代理模式</title>
    <link href="/2025/10/30/JavaScript-%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/10/30/JavaScript-%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="跟踪属性访问"><a href="#跟踪属性访问" class="headerlink" title="跟踪属性访问"></a>跟踪属性访问</h2><p>通过捕获 <code>get</code>、<code>set</code> 和 <code>has</code> 等操作，可以知道什么时候访问和查询过对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jake&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(user, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property, receiver</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Getting <span class="hljs-subst">$&#123;property&#125;</span>`</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;,<br><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Setting <span class="hljs-subst">$&#123;property&#125;</span>=<span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br>proxy.<span class="hljs-property">name</span>;  <span class="hljs-comment">// Getting name</span><br>proxy.<span class="hljs-property">age</span> = <span class="hljs-number">27</span>;  <span class="hljs-comment">// Setting age=27</span><br></code></pre></td></tr></table></figure><h2 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h2><p>代理的内部实现对外部代码不可见，能方便地隐藏目标对象上的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hiddenProperties = [<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>];<br><br><span class="hljs-keyword">const</span> targetObject = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">baz</span>: <span class="hljs-number">3</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(targetObject, &#123;<br>   <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property</span>) &#123;<br>       <span class="hljs-keyword">if</span>(hiddenProperties.<span class="hljs-title function_">includes</span>(property)) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>       &#125;<br>   &#125;,<br><br>   <span class="hljs-title function_">has</span>(<span class="hljs-params">target, property</span>) &#123;<br>       <span class="hljs-keyword">if</span>(hiddenProperties.<span class="hljs-title function_">includes</span>(property)) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(...<span class="hljs-variable language_">arguments</span>);<br>       &#125;<br>   &#125;<br>&#125;);<br><br><span class="hljs-comment">// 调用 get() 代理</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">bar</span>);  <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">baz</span>);  <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 调用 has() 代理</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span> <span class="hljs-keyword">in</span> proxy);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span> <span class="hljs-keyword">in</span> proxy);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;baz&#x27;</span> <span class="hljs-keyword">in</span> proxy);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h2><p>所有赋值操作都会触发 <code>set()</code> 捕获器，可以根据所赋的值决定允许还是拒绝赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">onlyNumbersGoHere</span>: <span class="hljs-number">0</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br><br>proxy.<span class="hljs-property">onlyNumbersGoere</span> = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">onlyNumbersGoere</span>);  <span class="hljs-comment">// 1</span><br><br>proxy.<span class="hljs-property">onlyNumbersGoere</span> = <span class="hljs-string">&#x27;2&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">onlyNumbersGoere</span>);  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h2 id="函数与构造函数参数验证"><a href="#函数与构造函数参数验证" class="headerlink" title="函数与构造函数参数验证"></a>函数与构造函数参数验证</h2><p>可以审查函数和构造函数参数，让函数只接收某种类型的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">median</span>(<span class="hljs-params">...nums</span>) &#123;<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-title function_">sort</span>()[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(nums.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>)];<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(median, &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        target: 目标对象</span><br><span class="hljs-comment">        thisArg: 调用函数时的 this 参数</span><br><span class="hljs-comment">        argumentsList: 调用函数时的参数列表</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, argumentsList</span>) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> arg <span class="hljs-keyword">of</span> argumentsList) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> arg !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Non-number argument provided&#x27;</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>));  <span class="hljs-comment">// 4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-number">1</span>));  <span class="hljs-comment">// Non-number argument provided</span><br></code></pre></td></tr></table></figure><p>可以要求实例化时必须给构造函数传参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">id_</span> = id;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">User</span>, &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        target: 目标构造函数</span><br><span class="hljs-comment">        argumentsList: 传给目标构造函数的参数列表</span><br><span class="hljs-comment">        newTarget: 最初被调用的构造函数</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, argumentsList, newTarget</span>) &#123;<br>        <span class="hljs-keyword">if</span>(argumentsList[<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;User cannot be instantiated without id&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(...<span class="hljs-variable language_">arguments</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>();  <span class="hljs-comment">// User cannot be instantiated without id</span><br></code></pre></td></tr></table></figure><h2 id="数据绑定与可观察对象"><a href="#数据绑定与可观察对象" class="headerlink" title="数据绑定与可观察对象"></a>数据绑定与可观察对象</h2><p>通过代理可以联系运行时原本不相关的部分，实现各种模式，让不同的代码互操作</p><p>比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> userList = [];<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span> = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">User</span>, &#123;<br>    <span class="hljs-title function_">construct</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> newUser = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(...<span class="hljs-variable language_">arguments</span>);<br>        userList.<span class="hljs-title function_">push</span>(newUser);<br><br>        <span class="hljs-keyword">return</span> newUser;<br>    &#125;<br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;Jacob&#x27;</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;Jingleheimerschmidt&#x27;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">[</span><br><span class="hljs-comment">  User &#123; name_: &#x27;John&#x27; &#125;,</span><br><span class="hljs-comment">  User &#123; name_: &#x27;Jacob&#x27; &#125;,</span><br><span class="hljs-comment">  User &#123; name_: &#x27;Jingleheimerschmidt&#x27; &#125;</span><br><span class="hljs-comment">]</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userList);<br></code></pre></td></tr></table></figure><p>也可以把集合绑定到一个事件分派程序，每次插入新实例都会发送消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> userList = [];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">emit</span>(<span class="hljs-params">newValue</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newValue);<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(userList, &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        set拦截器对所有属性设置操作都会响应，包括length属性的更新</span><br><span class="hljs-comment">        每次push会触发两次emit调用：</span><br><span class="hljs-comment">            一次是新元素被添加时（输出 &#x27;John&#x27; 和 &#x27;Jacob&#x27;）</span><br><span class="hljs-comment">            一次是数组长度被更新时（输出 1 和 2）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        target: 目标对象</span><br><span class="hljs-comment">        property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">        value: 要赋给属性的值</span><br><span class="hljs-comment">        receiver: 接收最初赋值的对象</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123;<br>        <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);<br>        <span class="hljs-keyword">if</span>(result) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                target: 目标对象</span><br><span class="hljs-comment">                property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">                receiver: 代理对象或继承代理对象的对象</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-title function_">emit</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, property, receiver));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// push 是数组的方法，在添加元素后，会返回数组的新长度</span><br><span class="hljs-comment">// John</span><br><span class="hljs-comment">// 1</span><br>proxy.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br><span class="hljs-comment">// Jacob</span><br><span class="hljs-comment">// 2</span><br>proxy.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;Jacob&#x27;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-代理捕获器与反射方法</title>
    <link href="/2025/10/30/JavaScript-%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%90%86%E6%8D%95%E8%8E%B7%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95/"/>
    <url>/2025/10/30/JavaScript-%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%90%86%E6%8D%95%E8%8E%B7%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在代理对象上执行的任何一种操作，<mark>只会调用一个捕获处理程序</mark>，不存在重复捕获。</p><p>只要在代理上调用，所有捕获器都会拦截它们对应的反射 <code>API</code> 操作。</p><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p>获取属性值的操作会调用 <code>get()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.get()</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">receiver: 代理对象或继承代理对象的对象</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property, receiver</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br>proxy.<span class="hljs-property">foo</span>;  <span class="hljs-comment">// get()</span><br></code></pre></td></tr></table></figure><p><code>get()</code> 捕获器无返回值限制，会拦截 <code>proxy.property</code>、<code>proxy[property]</code>、<code>Object.create(proxy)[property]</code> 和 <code>Reflect.get(proxy, property, receiver)</code> 操作。</p><p>如果：</p><ul><li><p><code>target.property</code> <strong>不可写且不可配置</strong>，处理程序返回的值必须与 <code>target.property</code> 匹配</p></li><li><p><code>target.property</code> <strong>不可配置</strong>且 <code>[[Get]]</code> 为 <code>undefined</code>，处理程序的返回值也必须是 <code>undefined</code></p></li></ul><h2 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h2><p>设置属性值的操作会调用 <code>set()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.set()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">value: 要赋给属性的值</span><br><span class="hljs-comment">receiver: 接收最初赋值的对象</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br>proxy.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;bar&#x27;</span>;  <span class="hljs-comment">// set()</span><br></code></pre></td></tr></table></figure><p><code>set()</code> 捕获器返回 <code>true</code> 表示成功；返回 <code>false</code> 表示失败，严格模式会抛出 <code>TypeError</code>。会拦截 <code>proxy.property = value</code>、<code>proxy[property] = value</code>、<code>Object.create(proxy)[property] = value</code> 和 <code>Reflect.set(proxy, property, value, receiver)</code> 操作。</p><p>如果：</p><ul><li><p><code>target.property</code> <mark>不可写且不可配置</mark>，则不能修改目标属性的值</p></li><li><p><code>target.property</code> <mark>不可配置且 <code>[[Set]]</code> 特性为 <code>undefined</code></mark>，则不能修改目标属性的值</p></li></ul><h2 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h2><p>在 <code>in</code> 操作符中会调用 <code>has()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.has()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">has</span>(<span class="hljs-params">target, property</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;has()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-string">&#x27;foo&#x27;</span> <span class="hljs-keyword">in</span> proxy;  <span class="hljs-comment">// has()</span><br></code></pre></td></tr></table></figure><p><code>has()</code> 必须返回表示属性是否存在的布尔值，返回非布尔值会转为布尔值。会拦截 <code>property in proxy</code>、<code>property in Object.create(proxy)</code>、<code>with(proxy) {(property);}</code> 和 <code>Reflect.has(proxy, property)</code> 操作。</p><p>如果：</p><ul><li><p><code>target.property</code> <mark>存在且不可配置</mark>，处理程序必须返回 <code>true</code></p></li><li><p><code>target.property</code> <mark>存在且目标对象不可扩展</mark>，处理程序必须返回 <code>true</code></p></li></ul><h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h2><p>在 <code>Object.defineProperty()</code> 中会调用 <code>defineProperty()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.defineProperty()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">descriptor: 包含可选的 enumerable、configurable、writable、value、get 和 set 定义的对象</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">defineProperty</span>(<span class="hljs-params">target, property, descriptor</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;defineProperty()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// defineProperty()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(proxy, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p><code>defineProperty()</code> 必须返回表示属性是否存在的布尔值，返回非布尔值会转为布尔值。会拦截 <code>Object.defineProperty(proxy, property, descriptor)</code> 和 <code>Reflect.defineProperty(proxy, property, descriptor)</code> 操作。</p><p>如果：</p><ul><li><p>目标对象<mark>不可扩展</mark>，无法定义属性</p></li><li><p>目标对象有一个<mark>可配置的属性</mark>，不能添加同名的不可配置属性</p></li><li><p>目标对象有一个<mark>不可配置的属性</mark>，不能添加同名的可配置属性</p></li></ul><h2 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h2><p>在 <code>Object.getOwnPropertyDescriptor()</code> 中会调用 <code>getOwnPropertyDescriptor()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.getOwnPropertyDescriptor()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">getOwnPropertyDescriptor</span>(<span class="hljs-params">target, property</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;getOwnPropertyDescriptor()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// getOwnPropertyDescriptor()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(proxy, <span class="hljs-string">&#x27;foo&#x27;</span>);<br></code></pre></td></tr></table></figure><p><code>getOwnPropertyDescriptor()</code> <mark>必须返回对象</mark>，在属性不存在时返回 <code>undefined</code>。会拦截 <code>Object.getOwnPropertyDescriptor(proxy, property)</code> 和 <code>Reflect.getOwnPropertyDescriptor(proxy, property)</code> 操作。</p><p>如果：</p><ul><li><p><code>target.property</code> <mark>存在且不可配置</mark>，必须返回一个表示该属性存在的对象</p></li><li><p><code>target.property</code> <mark>存在且可配置</mark>，必须返回表示该属性可配置的对象</p></li><li><p><code>target.property</code> <mark>存在且 <code>target</code> 不可扩展</mark>，必须返回一个表示该属性存在的对象</p></li><li><p><code>target.property</code> <mark>不存在且 <code>target</code> 不可扩展</mark>，必须返回 <code>undefined</code> 表示该属性不存在</p></li><li><p><code>target.property</code> <mark>不存在</mark>，不能返回表示该属性可配置的对象</p></li></ul><h2 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h2><p>在 <code>delete</code> 操作符中会调用 <code>deleteProperty()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.deleteProperty()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, property</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;deleteProperty()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// deleteProperty()</span><br><span class="hljs-keyword">delete</span> proxy.<span class="hljs-property">foo</span>;<br></code></pre></td></tr></table></figure><p><code>deleteProperty()</code> 必须返回表示属性是否存在的布尔值，返回非布尔值会转为布尔值。会拦截 <code>delete proxy.property</code>、<code>delete proxy[property]</code> 和 <code>Reflect.deleteProperty(proxy, property)</code> 操作。</p><ul><li>如果 <code>target.property</code> <mark>存在且不可配置</mark>，不能删除这个属性</li></ul><h2 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h2><p>在 <code>Object.keys()</code> 及类似方法中会调用 <code>ownKeys()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.ownKeys()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">ownKeys</span>(<span class="hljs-params">target</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ownKeys()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// ownKeys()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(proxy);<br></code></pre></td></tr></table></figure><p><code>ownKeys()</code> 必须返回包含字符串或符号的可枚举对象。会拦截 <code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code> 和 <code>Reflect.ownKeys(proxy)</code> 操作。</p><ul><li><p>必须返回包含 <code>target</code> 所有不可配置的自有属性的可枚举对象</p></li><li><p>如果 <code>target</code> 不可扩展，返回可枚举对象必须准确包含自有属性键</p></li></ul><h2 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h2><p>在 <code>Object.getPrototypeOf()</code> 中会调用 <code>getPrototypeOf()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.getPrototypeOf()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-params">target</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;getPrototypeOf()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// getPrototypeOf()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proxy);<br></code></pre></td></tr></table></figure><p><code>getPrototypeOf()</code> 必须返回对象或 <code>null</code>。会拦截 <code>Object.getPrototypeOf(proxy)</code>、<code>Reflect.getPrototypeOf(proxy)</code>、<code>proxy.__proto__</code>、<code>Object.prototype.isPrototypeOf(proxy)</code> 和 <code>proxy instanceof Object</code> 操作。</p><ul><li>如果 <code>target</code> 不可扩展，<code>Object.getPrototypeOf(proxy)</code> 唯一有效的返回值就是 <code>Object.getPrototypeOf(target)</code> 的返回值</li></ul><h2 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h2><p>在 <code>Object.setPrototypeOf()</code> 中会调用 <code>setPrototypeOf()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.setPrototypeOf()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">prototype: target 的替代原型，如果是顶级原型则为 null</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">setPrototypeOf</span>(<span class="hljs-params">target, prototype</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setPrototypeOf()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">setPrototypeOf</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// setPrototypeOf()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(proxy, <span class="hljs-title class_">Object</span>);<br></code></pre></td></tr></table></figure><p><code>getPrototypeOf()</code> 必须返回表示原型赋值是否成功的布尔值，返回非布尔值会转为布尔值。会拦截 <code>Object.setPrototypeOf(proxy)</code> 和 <code>Reflect.setPrototypeOf(proxy)</code> 操作。</p><ul><li>如果 <code>target</code> 不可扩展，<code>Object.setPrototypeOf()</code> 唯一有效的 <code>prototype</code> 参数就是 <code>Object.getPrototypeOf(target)</code> 的返回值</li></ul><h2 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h2><p>在 <code>Object.isExtensible()</code> 中会调用 <code>isExtensible()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.isExtensible()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">isExtensible</span>(<span class="hljs-params">target</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;isExtensible()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">isExtensible</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// isExtensible()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isExtensible</span>(proxy);<br></code></pre></td></tr></table></figure><p><code>getPrototypeOf()</code> 必须返回表示 <code>target</code> 是否可扩展的布尔值，返回非布尔值会转为布尔值。会拦截 <code>Object.isExtensible(proxy)</code> 和 <code>Reflect.isExtensible(proxy)</code> 操作。</p><p>如果：</p><ul><li><p><code>target</code> 可扩展，必须返回 <code>true</code></p></li><li><p><code>target</code> 不可扩展，必须返回 <code>false</code></p></li></ul><h2 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h2><p>在 <code>Object.preventExtensions()</code> 中会调用 <code>preventExtensions()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.preventExtensions()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">preventExtensions</span>(<span class="hljs-params">target</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;preventExtensions()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">preventExtensions</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// preventExtensions()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>(proxy);<br></code></pre></td></tr></table></figure><p><code>preventExtensions()</code> 必须返回表示 <code>target</code> 是否已不可扩展的布尔值，返回非布尔值会转为布尔值。会拦截 <code>Object.preventExtensions(proxy)</code> 和 <code>Reflect.preventExtensions(proxy)</code> 操作。</p><ul><li>如果 <code>Object.isExtensible(proxy)</code> 是 <code>false</code>，必须返回 <code>true</code></li></ul><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p>在调用函数时会调用 <code>apply()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.apply()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">myTarget</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">thisArg: 调用函数时的 this 参数</span><br><span class="hljs-comment">argumentsList: 调用函数时的参数列表</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, ...argumentsList</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;apply()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// apply()</span><br><span class="hljs-title function_">proxy</span>();<br></code></pre></td></tr></table></figure><p><code>apply()</code> 返回值无限制。会拦截 <code>proxy(...argumentsList)</code>、<code>Function.prototype.apply(thisArg, argumentsList)</code>、<code>Function.prototype.call(thisArg, ...argumentsList)</code> 和 <code>Reflect.apply(target, thisArgument, argumentsList)</code> 操作。</p><ul><li><code>target</code> 必须是一个函数对象</li></ul><h2 id="construt"><a href="#construt" class="headerlink" title="construt()"></a>construt()</h2><p>在 <code>new</code> 操作符中会调用 <code>construt()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.construt()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标构造函数</span><br><span class="hljs-comment">argumentsList: 传给目标构造函数的参数列表</span><br><span class="hljs-comment">newTarget: 最初被调用的构造函数</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, argumentsList, newTarget</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;construct()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// construct()</span><br><span class="hljs-keyword">new</span> proxy;<br></code></pre></td></tr></table></figure><p><code>construct()</code> 必须返回一个对象。会拦截 <code>new proxy(...argumentsList)</code> 和 <code>Reflect.construct(target, argumentsList, newTarget)</code> 操作。</p><ul><li><code>target</code> 必须可用作构造函数</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-代理基础</title>
    <link href="/2025/10/29/JavaScript-%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/10/29/JavaScript-%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%90%86%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><mark>代理是目标对象的抽象。</mark>目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理。</p><p>使用 <code>Proxy</code> 构造函数创建代理，该函数接收<strong>目标对象</strong>和<strong>处理程序对象</strong>作为参数。</p><h2 id="创建空代理"><a href="#创建空代理" class="headerlink" title="创建空代理"></a>创建空代理</h2><p>空代理除了作为一个抽象的目标对象，什么也不做。在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。</p><p>可以向 <code>Proxy</code> 构造函数传递一个简单的对象字面量作为处理程序对象，来创建空代理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;target&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> handler = &#123;&#125;;<br><br><span class="hljs-comment">// 使用 Proxy 构造函数创建代理</span><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-comment">// id 属性会访问同一个值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">id</span>);  <span class="hljs-comment">// target</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">id</span>);  <span class="hljs-comment">// target</span><br><br><span class="hljs-comment">// 给目标属性赋值会反映在两个对象上</span><br>target.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">id</span>);  <span class="hljs-comment">// foo</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">id</span>);  <span class="hljs-comment">// foo</span><br><br><span class="hljs-comment">// 在代理对象上执行的任何操作都会应用到目标对象</span><br>proxy.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">id</span>);  <span class="hljs-comment">// bar</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">id</span>);  <span class="hljs-comment">// bar</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;id&#x27;</span>));  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;id&#x27;</span>));  <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// Proxy.prototype 是 undefined，不能使用 instanceof 操作符</span><br><span class="hljs-comment">// TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Proxy</span>);<br><span class="hljs-comment">// TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Proxy</span>);<br><br><span class="hljs-comment">// 使用严格相等区分代理和目标</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target === proxy);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h2><ul><li><p>使用代理的主要目的是定义<strong>捕获器（trap）</strong></p></li><li><p>捕获器是在处理程序对象中定义的“基本操作的拦截器”</p></li><li><p>每个处理程序对象可以包含<strong>零个或多个捕获器</strong>，每个捕获器都对应一种基本操作，代理对象可以<strong>直接或间接调用</strong></p></li><li><p>代理可以在基本操作传播到目标对象之前先调用捕获器函数，<mark>拦截并修改相应的行为</mark></p></li></ul><blockquote><p>捕获器在操作系统中是程序流的一个同步中断，可以暂停程序流，转而执行一段子例程，再返回原始程序流</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 定义一个 get() 捕获器</span><br><span class="hljs-comment">// 在 ECMAScript 以某种形式调用 get() 时触发</span><br><span class="hljs-keyword">const</span> handler = &#123;<br><span class="hljs-comment">// 捕获器在处理程序对象中以方法名为键</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;handler override&#x27;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">    只有通过 代理对象 执行 get() 操作时</span><br><span class="hljs-comment">    才会触发定义的 get() 捕获器</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    只有在 代理对象 上执行</span><br><span class="hljs-comment">    proxy[property]、proxy.property 或 Object.create(proxy)[property]</span><br><span class="hljs-comment">    等操作才会触发基本的 get() 操作以获取属性</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// handler override</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target[<span class="hljs-string">&#x27;foo&#x27;</span>]);  <span class="hljs-comment">// bar </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy[<span class="hljs-string">&#x27;foo&#x27;</span>]);  <span class="hljs-comment">// handler override</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(target)[<span class="hljs-string">&#x27;foo&#x27;</span>]);  <span class="hljs-comment">// bar</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proxy)[<span class="hljs-string">&#x27;foo&#x27;</span>]);  <span class="hljs-comment">// handler override</span><br></code></pre></td></tr></table></figure><h2 id="捕获器参数和反射-API"><a href="#捕获器参数和反射-API" class="headerlink" title="捕获器参数和反射 API"></a>捕获器参数和反射 API</h2><p>所有捕获器都可以访问相应的参数，<code>get()</code> 捕获器能接收到<mark>目标对象、要查询的属性和代理对象。</mark></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    // 目标对象、要查询的属性和代理对象</span><br><span class="hljs-comment">    get(trapTarget, property, receiver) &#123;</span><br><span class="hljs-comment">        console.log(trapTarget === target);</span><br><span class="hljs-comment">        console.log(property);</span><br><span class="hljs-comment">        console.log(receiver === proxy);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 重写被捕获方法</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">trapTarget, property, receiver</span>) &#123;<br>        <span class="hljs-keyword">return</span> trapTarget[property];<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    true</span><br><span class="hljs-comment">    foo</span><br><span class="hljs-comment">    true</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// proxy.foo;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br></code></pre></td></tr></table></figure><ul><li><p>可以通过调用全局 <code>Reflect</code> 对象（封装了原始行为）的同名方法来重写函数。<code>Reflect</code> 是一个内置的对象，它提供了一组静态方法，用于执行各种与对象操作相关的通用功能，动态地检查或修改对象的结构和行为。</p></li><li><p>处理程序对象中所有可捕获的方法都有与捕获器拦截的方法相同的名称和函数签名，而且有和被拦截方法相同行为的相应的反射（<code>Reflect</code>）<code>API</code> 方法。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 使用反射 API 定义空代理对象</span><br><span class="hljs-keyword">const</span> handler = &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    get() &#123;</span><br><span class="hljs-comment">        return Reflect.get(...arguments);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-attr">get</span>: <span class="hljs-title class_">Reflect</span>.<span class="hljs-property">get</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br></code></pre></td></tr></table></figure><p>不需要定义处理程序对象就可以创建一个可以捕获所有方法，并将每个方法转发给对应反射 <code>API</code> 的空代理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, <span class="hljs-title class_">Reflect</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br></code></pre></td></tr></table></figure><p>可以在反射 <code>API</code> 样板代码的基础上用最少的代码修改捕获的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    <span class="hljs-attr">baz</span>: <span class="hljs-string">&#x27;qux&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">trapTarget, property, receiver</span>) &#123;<br>        <span class="hljs-keyword">let</span> decoration = <span class="hljs-string">&#x27;&#x27;</span>;<br><br>        <span class="hljs-keyword">if</span>(property === <span class="hljs-string">&#x27;foo&#x27;</span>) &#123;<br>            decoration = <span class="hljs-string">&#x27;!!!&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>) + decoration;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, <span class="hljs-title class_">Reflect</span>);<br><br><span class="hljs-comment">// 只有通过代理执行时才会触发捕获器</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar!!!</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">baz</span>);  <span class="hljs-comment">// qux</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">baz</span>);  <span class="hljs-comment">// qux</span><br></code></pre></td></tr></table></figure><h2 id="捕获器的限制"><a href="#捕获器的限制" class="headerlink" title="捕获器的限制"></a>捕获器的限制</h2><p>每个捕获的方法都知道<mark>目标对象上下文、捕获函数签名</mark>，捕获处理程序的行为<mark>必须遵循</mark>“<strong>捕获器不变式</strong>”（trap invariant）。</p><p>如果目标对象有一个不可配置且不可写的数据属性，捕获器返回一个与该属性不同的值，会抛出 <code>TypeError</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;);<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;qux&#x27;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    TypeError: &#x27;get&#x27; on proxy: property &#x27;foo&#x27; is a read-only and non-configurable</span><br><span class="hljs-comment">    data property on the proxy target but the proxy did not return its actual</span><br><span class="hljs-comment">    value (expected &#x27;bar&#x27; but got &#x27;qux&#x27;)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);<br></code></pre></td></tr></table></figure><h2 id="撤销代理"><a href="#撤销代理" class="headerlink" title="撤销代理"></a>撤销代理</h2><p><code>Proxy</code> 的 <code>revocable()</code> 方法支持撤销代理对象与目标对象的关联，且操作不可逆。撤销代理后再调用代理会抛出 <code>TypeError</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;intercepted&#x27;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 在实例化时同时生成代理对象和撤销函数</span><br><span class="hljs-keyword">const</span> &#123; proxy, revoke &#125; = <span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">revocable</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// intercepted</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br><br><span class="hljs-comment">// 撤销代理</span><br><span class="hljs-title function_">revoke</span>();<br><br><span class="hljs-comment">// TypeError: Cannot perform &#x27;get&#x27; on a proxy that has been revoked</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);<br></code></pre></td></tr></table></figure><h2 id="反射-API"><a href="#反射-API" class="headerlink" title="反射 API"></a>反射 API</h2><p>以下是优先使用反射 <code>API</code> 的情况</p><h3 id="反射-API-与对象-API"><a href="#反射-API-与对象-API" class="headerlink" title="反射 API 与对象 API"></a>反射 API 与对象 API</h3><p><code>Object</code> 的方法适用于通用程序，反射方法适用于细粒度的对象控制与操作</p><ul><li><p>反射 <code>API</code> 并不限于捕获处理程序</p></li><li><p>大多数反射 <code>API</code> 方法在 <code>Object</code> 类型上有对应的方法</p></li></ul><h3 id="状态标记"><a href="#状态标记" class="headerlink" title="状态标记"></a>状态标记</h3><p>反射方法返回称作“<strong>状态标记</strong>”的布尔值，表示执行的操作是否成功</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123;&#125;;<br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(o, <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;failure&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 使用 Reflect.defineProperty() 重构上面的代码</span><br><span class="hljs-keyword">const</span> o = &#123;&#125;;<br><br><span class="hljs-comment">// 属性定义错误时，Reflect.defineProperty() 返回 false</span><br><span class="hljs-keyword">if</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(o, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125;)) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;failure&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Reflect.defineProperty()</code>、<code>Reflect.preventExtensions()</code>、<code>Reflect.setPrototypeOf()</code>、<code>Reflect.set()</code> 和 <code>Reflect.deleteProperty()</code> 都会提供状态标记</p><h3 id="替代操作符"><a href="#替代操作符" class="headerlink" title="替代操作符"></a>替代操作符</h3><p><code>Reflect.get()</code>（可以替代对象属性访问操作符）、<code>Reflect.set()</code>（可以替代 <code>=</code> 赋值操作符）、<code>Reflect.has()</code>（可以替代 <code>in</code> 操作符或 <code>with()</code>）、<code>Reflect.deleteProperty()</code>（可以替代 <code>delete</code> 操作符）和 <code>Reflect.construct()</code>（可以替代 <code>new</code> 操作符）等反射方法<strong>提供只有通过操作符才能完成的操作</strong></p><h3 id="安全地使用函数"><a href="#安全地使用函数" class="headerlink" title="安全地使用函数"></a>安全地使用函数</h3><p>为了绕过使用 <code>apply</code> 方法调用函数时，被调函数也定义了 <code>apply</code> 属性的情况（直接使用 <code>对象.apply(...)</code> 调用函数时，会优先访问函数自身的 <code>apply</code> 属性），可使用定义在 <code>Function</code> 原型上的 <code>apply</code> 方法（强制使用 <code>JavaScript</code> 引擎内置的函数调用逻辑，无论被调函数是否有 <code>apply</code> 属性，都能保证正确执行目标函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">apply</span>.<span class="hljs-title function_">call</span>(myFunc, thisVal, argumentList);<br><br><span class="hljs-comment">// 避免被调函数也定义了 apply 属性</span><br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(myFunc, thisVal, argumentList);<br></code></pre></td></tr></table></figure><h2 id="代理另一个代理"><a href="#代理另一个代理" class="headerlink" title="代理另一个代理"></a>代理另一个代理</h2><p>可以通过一个代理去代理另一个代理，在一个目标对象上构建多层拦截网</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> firstProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;first proxy&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-keyword">const</span> secondProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(firstProxy, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;second proxy&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">second proxy</span><br><span class="hljs-comment">first proxy</span><br><span class="hljs-comment">bar</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(secondProxy.<span class="hljs-property">foo</span>);<br></code></pre></td></tr></table></figure><h2 id="代理的问题"><a href="#代理的问题" class="headerlink" title="代理的问题"></a>代理的问题</h2><p>代理作为对象的虚拟层可以正常使用，但某些情况下不能与现有的机制协同</p><h3 id="潜在问题来源-——-this-值"><a href="#潜在问题来源-——-this-值" class="headerlink" title="潜在问题来源 —— this 值"></a>潜在问题来源 —— this 值</h3><p>如果代理的目标对象依赖于<strong>对象标识</strong>（判断两个对象是否是同一个实例的机制，两个变量是否指向内存中的同一个对象），可能会碰到问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-title function_">thisValEqualsProxy</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 方法中的 this 通常指向调用这个方法的对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span> === proxy;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 空代理</span><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-title function_">thisValEqualsProxy</span>());  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-title function_">thisValEqualsProxy</span>());  <span class="hljs-comment">// true</span><br><br><br><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><br><span class="hljs-comment">// 依赖 User 实例的对象标识</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">userId</span>) &#123;<br>        <span class="hljs-comment">// WeakMap 的键只能是对象，键的唯一性完全依赖对象标识</span><br>        wm.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, userId);<br>    &#125;<br><br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">id</span>(<span class="hljs-params">userId</span>) &#123;<br>        wm.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, userId);<br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">id</span>() &#123;<br>        <span class="hljs-keyword">return</span> wm.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">123</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">id</span>);  <span class="hljs-comment">// 123</span><br><br><span class="hljs-comment">// 代理对象尝试从自身获取该实例</span><br><span class="hljs-comment">// 代理对象 userInstanceProxy 从未作为键存入 WeakMap</span><br><span class="hljs-comment">// const userInstanceProxy = new Proxy(user, &#123;&#125;);</span><br><span class="hljs-comment">// console.log(userInstanceProxy.id);  // undefined</span><br><br><span class="hljs-comment">// 代理 User 类本身</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserClassProxy</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">User</span>, &#123;&#125;);<br><span class="hljs-comment">// 以代理实例作为 WeakMap 的键</span><br><span class="hljs-keyword">const</span> proxyUser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserClassProxy</span>(<span class="hljs-number">456</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxyUser.<span class="hljs-property">id</span>);  <span class="hljs-comment">// 456</span><br></code></pre></td></tr></table></figure><h3 id="代理与内部槽位"><a href="#代理与内部槽位" class="headerlink" title="代理与内部槽位"></a>代理与内部槽位</h3><p>有些 <code>ECMAScript</code> 内置类型可能会依赖代理无法控制的机制，导致在代理上调用某些方法出错。</p><p>比如，<code>Date</code> 类型方法的执行依赖 <code>this</code> 值的内部槽位 <code>[[NumberDate]]</code>，但代理对象不存在该内部槽位，代理拦截后会抛出 <code>TypeError</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>);  <span class="hljs-comment">// true</span><br><br>proxy.<span class="hljs-title function_">getDate</span>();  <span class="hljs-comment">// TypeError: this is not a Date object</span><br></code></pre></td></tr></table></figure><blockquote><p>内部槽位是 <code>ECMA</code> 规范定义的、对象内部用于存储状态或特性的特殊“容器”，不是对象的属性，无法直接访问或修改。内部槽位仅在引擎层面存在，用于实现语言的核心功能</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript笔记-类</title>
    <link href="/2025/10/26/JavaScript%E7%AC%94%E8%AE%B0-%E7%B1%BB/"/>
    <url>/2025/10/26/JavaScript%E7%AC%94%E8%AE%B0-%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p><code>ECMAScript 6</code> 引入的 <code>class</code> 关键字具有正式定义类的能力，但<mark>实际上使用的仍然是原型和构造函数的概念</mark></p><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>有两种主要方式定义类：类声明和类表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 类声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><br><span class="hljs-comment">// 类表达式</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Animal</span> = <span class="hljs-keyword">class</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>函数表达式和类表达式在求值前都不能引用</p></li><li><p>类定义不能提升，但函数定义可以</p></li><li><p>函数受<strong>函数作用域</strong>限制，类受<strong>块作用域</strong>限制</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">FunctionDeclaration</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassDeclaration</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// [Function: FunctionDeclaration]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">FunctionDeclaration</span>);<br><span class="hljs-comment">// ReferenceError: ClassDeclaration is not defined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ClassDeclaration</span>);<br></code></pre></td></tr></table></figure><ul><li><p>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但<mark>都不是必须的</mark></p></li><li><p>空的类定义同样有效</p></li><li><p>默认情况下，类定义中的代码都在严格模式下执行</p></li><li><p><mark>类名的首字母大写</mark>，以区别于通过它创建的实例</p></li><li><p><mark>类表达式的名称是可选的</mark>。把类表达式赋值给变量后，可以<mark>通过 <code>name</code> 属性取得类表达式的名称字符串</mark>，但<mark>不能在类表达式作用域外访问该标识符</mark></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonName</span> &#123;<br>    <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">name</span>, <span class="hljs-title class_">PersonName</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>p.<span class="hljs-title function_">identify</span>();  <span class="hljs-comment">// PersonName PersonName</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// PersonName</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">PersonName</span>);  <span class="hljs-comment">// ReferenceError: PersonName is not defined</span><br></code></pre></td></tr></table></figure><h2 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h2><ul><li><p><code>constructor</code> 关键字用于在类定义块内部创建类的构造函数</p></li><li><p><code>constructor</code> 会告诉解释器在使用 <code>new</code> 操作符创建类的新实例时，调用该函数</p></li><li><p>不定义构造函数相当于将构造函数定义为<strong>空函数</strong></p></li></ul><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>使用 <code>new</code> 调用类的构造函数会执行<a href="../../22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">创建对象</a>的过程</p><p>类实例化时传入的参数会用作构造函数的参数</p><p>默认情况下，类构造函数会在执行后返回 <code>this</code> 对象，被用作实例化的对象</p><p>如果返回的不是 <code>this</code> 对象，而是其他对象，对这个对象使用 <code>instanceof</code> 操作符返回结果为 <code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">override</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><br>        <span class="hljs-keyword">if</span>(override) &#123;<br>            <span class="hljs-comment">// 返回的不是 this 对象</span><br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>            &#125;;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(),<br>    <span class="hljs-comment">// 未返回 this 对象，p2 的原型指针没有被修改</span><br>    p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);  <span class="hljs-comment">// Person &#123; foo: &#x27;foo&#x27; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> p1);  <span class="hljs-comment">// object</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);  <span class="hljs-comment">// &#123; bar: &#x27;bar&#x27; &#125;</span><br><span class="hljs-comment">// 无法通过 instanceof 操作符检测出跟类有关联</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> p2);  <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><p>调用类构造函数必须使用 <code>new</code> 操作符，不使用 <code>new</code> 会抛出错误</p><p>普通构造函数如果不使用 <code>new</code> 调用，就会以全局的 <code>this</code>（通常是 <code>window</code>）作为内部对象</p><p>实例化后，类构造函数会成为普通的实例方法（仍需使用 <code>new</code> 调用），可以在实例上引用它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-comment">// TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;</span><br><span class="hljs-comment">// p1.constructor();</span><br><br><span class="hljs-comment">// 使用类构造函数的引用创建一个新实例</span><br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> p1.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>);<br></code></pre></td></tr></table></figure><h3 id="把类当成特殊函数"><a href="#把类当成特殊函数" class="headerlink" title="把类当成特殊函数"></a>把类当成特殊函数</h3><p><code>ECMAScript</code> 类是一种特殊的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// [class Person]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// function</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-comment">// 类标识符的 prototype 属性有一个 constructor 属性指向类自身</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>类中定义的 <code>constructor</code> 方法<strong>不会</strong>被当成构造函数，对它使用 <code>instanceof</code> 操作符返回 <code>false</code>。如果在创建实例时直接<mark>将类构造函数当成普通构造函数</mark>，<code>instanceof</code> 操作符的返回值会<strong>反转</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>.<span class="hljs-property">constructor</span>);  <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 直接将类构造函数当成普通构造函数使用</span><br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>.<span class="hljs-property">constructor</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>类可以像其他对象或函数引用一样作为参数传递</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 类可以像函数一样在任何地方定义，比如数组中</span><br><span class="hljs-keyword">let</span> classList = [<br>    <span class="hljs-keyword">class</span> &#123;<br>        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">id_</span> = id;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`instance <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.id_&#125;</span>`</span>);<br>        &#125;<br>    &#125;<br>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createInstance</span>(<span class="hljs-params">classDefinition, id</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">classDefinition</span>(id);<br>&#125;<br><br><span class="hljs-comment">// classList[0] 是作为参数传递的类</span><br><span class="hljs-keyword">let</span> foo = <span class="hljs-title function_">createInstance</span>(classList[<span class="hljs-number">0</span>], <span class="hljs-number">3141</span>);  <span class="hljs-comment">// instance 3141</span><br></code></pre></td></tr></table></figure><p>类可以像立即调用函数表达式一样立即实例化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 类表达式的类名是可选的</span><br><span class="hljs-comment">// let p = new class Foo &#123;</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">class</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>    &#125;<br>&#125;(<span class="hljs-string">&#x27;bar&#x27;</span>);  <span class="hljs-comment">// bar</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);  <span class="hljs-comment">// Foo &#123;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在构造函数内部，可以为新创建的实例（<code>this</code>）添加“自有”属性。构造函数执行完也可以给实例继续添加新成员</p><p><mark>每个实例都对应一个唯一的成员对象，所有成员都不会在原型上共享</mark></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 为新创建的实例(this)添加&quot;自有&quot;属性</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            箭头函数，调用时会打印 this.name</span><br><span class="hljs-comment">            箭头函数没有自己的 this，它的 this 继承自定义时所在的上下文（即构造函数执行时的 this）</span><br><span class="hljs-comment">            箭头函数的 this 始终绑定创建时的实例，而普通函数的 this 会随调用方式变化</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">nicknames</span> = [<span class="hljs-string">&#x27;Jake&#x27;</span>, <span class="hljs-string">&#x27;J-Dog&#x27;</span>]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 每个实例都对应一个唯一的成员对象，所有成员都不会在原型上共享</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(),<br>    p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>p1.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// [String: &#x27;Jack&#x27;]</span><br>p2.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// [String: &#x27;Jack&#x27;]</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span> === p2.<span class="hljs-property">name</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">sayName</span> === p2.<span class="hljs-property">sayName</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">nicknames</span> === p2.<span class="hljs-property">nicknames</span>);  <span class="hljs-comment">// false</span><br><br>p1.<span class="hljs-property">name</span> = p1.<span class="hljs-property">nicknames</span>[<span class="hljs-number">0</span>];<br>p2.<span class="hljs-property">name</span> = p2.<span class="hljs-property">nicknames</span>[<span class="hljs-number">1</span>];<br><br>p1.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Jake</span><br>p2.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// J-Dog</span><br></code></pre></td></tr></table></figure><h3 id="原型方法与访问器"><a href="#原型方法与访问器" class="headerlink" title="原型方法与访问器"></a>原型方法与访问器</h3><ul><li><p>类体内直接声明的方法会自动绑定到原型对象上，无需手动操作 prototype</p></li><li><p>可以把<strong>方法</strong>定义在类构造函数或类块中，不能在类块中给原型添加<strong>原始值或对象</strong>作为成员数据</p></li><li><p>可以使用字符串、符号或计算的值作为类方法的键</p></li><li><p>类定义支持获取和设置访问器</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> symbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;symbolKey&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-comment">// 不能在类块中给原型添加原始值或对象作为成员数据</span><br><span class="hljs-comment">// name: &#x27;Jake&#x27;  // SyntaxError: Unexpected identifier &#x27;name&#x27;</span><br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 添加到 this 的所有内容会存在于不同的实例</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">locate</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;instance&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在类块中定义的所有内容都会定义在类的原型上</span><br>    <span class="hljs-title function_">locate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;prototype&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">stringKey</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;invoked stringKey&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 使用符号作为键</span><br>    [symbolKey]() &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;invoked symbolKey&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 使用计算的值作为键</span><br>    [<span class="hljs-string">&#x27;computed&#x27;</span> + <span class="hljs-string">&#x27;Key&#x27;</span>]() &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;invoked computedKey&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置访问器</span><br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">newName</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span> = newName;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取访问器</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>p.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// instance</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// prototype</span><br><br>p.<span class="hljs-title function_">stringKey</span>();  <span class="hljs-comment">// invoked stringKey</span><br>p[symbolKey]();  <span class="hljs-comment">// invoked symbolKey</span><br>p.<span class="hljs-title function_">computedKey</span>();  <span class="hljs-comment">// invoked computedKey</span><br><br>p.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jake&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Jake</span><br></code></pre></td></tr></table></figure><h3 id="静态类方法"><a href="#静态类方法" class="headerlink" title="静态类方法"></a>静态类方法</h3><p>静态方法通常用于执行不特定于实例的操作，也不要求存在类的实例，<strong>每个类只能有一个静态成员</strong>（类级别的属性）</p><p>静态类成员在类定义中使用 <code>static</code> 关键字作为前缀，使用 <code>this</code> 引用类自身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 添加到 this 的所有内容都会存在于不同的实例上</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">locate</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;instance&#x27;</span>, <span class="hljs-variable language_">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义在类的原型对象上</span><br>    <span class="hljs-title function_">locate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;prototype&#x27;</span>, <span class="hljs-variable language_">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义在类本身上</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">locate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-variable language_">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>p.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// instance Person &#123; locate: [Function (anonymous)] &#125;</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// prototype &#123;&#125;</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// class [class Person]</span><br></code></pre></td></tr></table></figure><p>静态类方法适合作为实例工厂</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">age</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age_</span> = age;<br>    &#125;<br><br>    <span class="hljs-comment">// sayAge() 没有 return 语句，默认返回 undefined</span><br>    <span class="hljs-comment">// 类实例调用 sayAge() 时会先打印年龄，再打印返回的年龄值</span><br>    <span class="hljs-title function_">sayAge</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age_</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义在类本身上</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 使用随机年龄创建并返回一个 Person 实例</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()*<span class="hljs-number">100</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Person &#123; age_: 83 &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-title function_">create</span>());<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">29</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    29</span><br><span class="hljs-comment">    undefined</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">sayAge</span>());<br></code></pre></td></tr></table></figure><h3 id="非函数原型和类成员"><a href="#非函数原型和类成员" class="headerlink" title="非函数原型和类成员"></a>非函数原型和类成员</h3><p><code>ECMAScript 2022</code> 允许直接在类体中定义数据成员，无需在 <code>constructor</code> 中定义</p><p>在类定义外部，可以在原型或类上手动添加成员数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// ES2022 允许直接在类体中定义数据成员，无需在 constructor 中定义</span><br>    age = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-comment">// 在构造函数中通过 this 定义数据成员</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-comment">// this.age = age;</span><br>    &#125;<br><br>    <span class="hljs-title function_">sayJob</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;Person.greeting&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.job&#125;</span>`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Alice</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">age</span>);  <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// 在类定义外部手动添加成员数据</span><br><span class="hljs-comment">// 在类上定义数据成员</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property">greeting</span> = <span class="hljs-string">&#x27;My job is&#x27;</span>;<br><span class="hljs-comment">// 在原型上定义数据成员</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&#x27;Software Engineer&#x27;</span>;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Jake&#x27;</span>);<br>p1.<span class="hljs-title function_">sayJob</span>();  <span class="hljs-comment">// My job is Software Engineer</span><br></code></pre></td></tr></table></figure><h3 id="迭代器与生成器方法"><a href="#迭代器与生成器方法" class="headerlink" title="迭代器与生成器方法"></a>迭代器与生成器方法</h3><p>类定义语法支持在原型和类本身上定义生成器方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">nicknames</span> = [<span class="hljs-string">&#x27;cJack&#x27;</span>, <span class="hljs-string">&#x27;cJake&#x27;</span>, <span class="hljs-string">&#x27;cJ-Dog&#x27;</span>];<br>    &#125;<br><br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    添加一个默认的迭代器，把类实例变成可迭代对象</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    方法名前的 * 表示这是一个 生成器函数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    [Symbol.iterator] 是一个特殊的 内置 Symbol 属性，当一个对象定义了该方法时，就表示它是 “可迭代的”</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    yield* 是 Generator 函数中的语法，用于 “委托” 另一个可迭代对象的迭代过程。它会自动遍历被委托的对象，并逐个返回其迭代结果</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    *[Symbol.iterator]() &#123;</span><br><span class="hljs-comment">        yield *this.nicknames.entries();</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    entries() 方法会返回一个数组迭代器对象，用于遍历其 “键值对”</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 只返回迭代器实例效果与返回可迭代对象相同</span><br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">nicknames</span>.<span class="hljs-title function_">entries</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 在原型上定义生成器方法</span><br>    *<span class="hljs-title function_">creatNicknameIterator</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Jack&#x27;</span>;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Jake&#x27;</span>;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;J-Dog&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 在类上定义生成器方法</span><br>    <span class="hljs-keyword">static</span> *<span class="hljs-title function_">createJobIterator</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Butcher&#x27;</span>;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Baker&#x27;</span>;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Candlestick maker&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> jobIter = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">createJobIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jobIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Butcher</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jobIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Baker</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jobIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Candlestick maker</span><br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">let</span> nicknameIter = p.<span class="hljs-title function_">creatNicknameIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nicknameIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Jack</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nicknameIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Jake</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nicknameIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// J-Dog</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [idx, nickname] <span class="hljs-keyword">of</span> p) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        cJack</span><br><span class="hljs-comment">        cJake</span><br><span class="hljs-comment">        cJ-Dog</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nickname);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><code>ECMAScript 6</code> 原生支持类继承机制，但<mark>背后依旧使用原型链</mark></p><h3 id="继承基础"><a href="#继承基础" class="headerlink" title="继承基础"></a>继承基础</h3><p><code>ES6</code> 支持<strong>单继承</strong>。使用 <code>extends</code> 关键字，可以继承任何拥有 <strong><code>[[Construct]]</code></strong> 和<strong>原型</strong>的对象。不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-params">id</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id, <span class="hljs-variable language_">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">identifyClass</span>(<span class="hljs-params">id</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id, <span class="hljs-variable language_">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 继承类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;&#125;<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Bus</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Vehicle</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">let</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>();<br><br><span class="hljs-comment">// 派生类通过原型链访问类和原型上定义的方法</span><br>b.<span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-string">&#x27;bus&#x27;</span>);  <span class="hljs-comment">// bus, Bus &#123;&#125;</span><br>v.<span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>);  <span class="hljs-comment">// vehicle, Vehicle &#123;&#125;</span><br><br><span class="hljs-title class_">Bus</span>.<span class="hljs-title function_">identifyClass</span>(<span class="hljs-string">&#x27;bus&#x27;</span>);  <span class="hljs-comment">// bus [class Bus extends Vehicle]</span><br><span class="hljs-title class_">Vehicle</span>.<span class="hljs-title function_">identifyClass</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>);  <span class="hljs-comment">// vehicle [class Vehicle]</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engineer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;&#125;<br><br><span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Engineer</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Engineer</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// extends 也可以在类表达式中使用</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Bar</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Foo</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数、HomeObject-和-super"><a href="#构造函数、HomeObject-和-super" class="headerlink" title="构造函数、HomeObject 和 super()"></a>构造函数、HomeObject 和 super()</h3><p>可以使用 <code>super</code> 关键字引用派生类方法的原型</p><ul><li><p><code>super</code> 关键字只能在派生类中使用</p></li><li><p>仅限类构造函数、实例方法和静态方法内部使用</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">hasEngine</span> = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 在调用 super() 之前引用 this 会报错</span><br>        <span class="hljs-comment">// ReferenceError: Must call super constructor in derived class before accessing &#x27;this&#x27; or returning from derived constructor</span><br>        <span class="hljs-variable language_">super</span>();  <span class="hljs-comment">// 相当于 super.constructor()</span><br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Vehicle</span>);  <span class="hljs-comment">// true</span><br>        <span class="hljs-comment">// 派生类的方法</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-comment">// Bus &#123; hasEngine: true &#125;</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 静态方法中可以通过 super 调用父类的静态方法</span><br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">identify</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    true</span><br><span class="hljs-comment">    Bus &#123; hasEngine: true &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>();<br><span class="hljs-title class_">Bus</span>.<span class="hljs-title function_">identify</span>();  <span class="hljs-comment">// vehicle</span><br></code></pre></td></tr></table></figure><ul><li><p><code>ES6</code> 给类构造函数和静态方法添加了内部指针 <code>[[HomeObject]]</code>（无法直接查看），指向定义该方法的对象。</p></li><li><p>该指针自动赋值，<code>[[HomeObject]]</code> 的原型始终定义为 <code>super</code></p></li></ul><br><p>使用 <code>super</code> 注意事项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">licensePlate</span>) &#123;<br>        <span class="hljs-comment">// super 只能在 派生类 构造函数和静态方法中使用</span><br>        <span class="hljs-comment">// super();  // SyntaxError: &#x27;super&#x27; keyword unexpected here</span><br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">licensePlate</span> = licensePlate;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">licensePlate</span>) &#123;<br>        <span class="hljs-comment">// 不能单独引用 super 关键字</span><br>        <span class="hljs-comment">// 要么调用构造函数，要么引用静态方法</span><br>        <span class="hljs-comment">// console.log(super);  // SyntaxError: &#x27;super&#x27; keyword unexpected here</span><br><br>        <span class="hljs-comment">// 需要手动给父类构造函数传参</span><br>        <span class="hljs-variable language_">super</span>(licensePlate);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// super() 会调用父类构造函数，并将返回的实例赋值给 this</span><br>        <span class="hljs-variable language_">super</span>();<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Vehicle</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Van</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-comment">// 在派生类中显式定义构造函数，必须在其中调用 super() 或返回一个对象</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// super();</span><br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 未定义类构造函数，实例化派生类时会调用父类构造函数，并传入所有传给派生类的参数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus1</span>();  <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>(<span class="hljs-string">&#x27;1337H4X&#x27;</span>));  <span class="hljs-comment">// Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus2</span>(<span class="hljs-string">&#x27;1337H4X&#x27;</span>));  <span class="hljs-comment">// Bus2 &#123; licensePlate: &#x27;1337H4X&#x27; </span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Van</span>());  <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p>通过在实例化时检测 <code>new.target</code>（<code>new.target</code> 保存通过 <code>new</code> 关键字调用的类或函数） 是不是抽象基类，可以阻止对抽象基类的实例化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 抽象基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> === <span class="hljs-title class_">Vehicle</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Inheriting class must define foo()&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;success!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Van</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;&#125;<br><br><span class="hljs-comment">// [class Bus extends Vehicle]</span><br><span class="hljs-comment">// success!</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>();<br><span class="hljs-comment">// [class Vehicle]</span><br><span class="hljs-comment">// Error: Vehicle cannot be directly instantiated</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>();<br></code></pre></td></tr></table></figure><h3 id="继承内置类型"><a href="#继承内置类型" class="headerlink" title="继承内置类型"></a>继承内置类型</h3><p>可以扩展内置类型，覆盖 <code>Symbol.species</code> 访问器（决定在创建返回实例时使用的类）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>    <span class="hljs-title function_">shuffle</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">const</span> j = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (i + <span class="hljs-number">1</span>));<br>            [<span class="hljs-variable language_">this</span>[i], <span class="hljs-variable language_">this</span>[j]] = [<span class="hljs-variable language_">this</span>[j], <span class="hljs-variable language_">this</span>[i]];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 默认返回 SuperArray 类实例</span><br>    <span class="hljs-comment">// 返回 Array 类实例</span><br>    <span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperArray</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SuperArray</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <span class="hljs-comment">// SuperArray(5) [ 1, 2, 3, 4, 5 ]</span><br>a.<span class="hljs-title function_">shuffle</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <span class="hljs-comment">// SuperArray(5) [ 1, 5, 3, 2, 4 ]</span><br><br><span class="hljs-keyword">let</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperArray</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    内置类型的方法会返回新实例</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    filter 用于根据条件筛选元素，返回一个新数组</span><br><span class="hljs-comment">    !! 是双重非运算符，用于将数值转为布尔类型</span><br><span class="hljs-comment">    第一个 ! 将数值转换为布尔值的反值</span><br><span class="hljs-comment">    第二个 ! 对第一步的结果取反，得到原 value 对应的真实布尔值</span><br><span class="hljs-comment">    条件等价于 &quot;x 是奇数&quot;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">let</span> a2 = a1.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !!(x%<span class="hljs-number">2</span>))<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a1);  <span class="hljs-comment">// SuperArray(5) [ 1, 2, 3, 4, 5 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2);  <span class="hljs-comment">// [ 1, 3, 5 ]</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SuperArray</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SuperArray</span>);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="多类继承"><a href="#多类继承" class="headerlink" title="多类继承"></a>多类继承</h3><p><code>ES6</code> 没有显式支持多类继承，但通过现有特性可<strong>模拟多类继承</strong></p><p>定义一组“可嵌套”的函数，每个函数分别接收一个超类（被其他类继承的 “父类”）作为参数，将<strong>混入类</strong>定义为该参数的子类，并返回这个类。可以<mark>连续调用组合函数，组成超类表达式</mark></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">FooMixin</span> = (<span class="hljs-params">Superclass</span>) =&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Superclass</span> &#123;<br>    <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">BarMixin</span> = (<span class="hljs-params">Superclass</span>) =&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Superclass</span> &#123;<br>    <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">BazMinxin</span> = (<span class="hljs-params">Superclass</span>) =&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Superclass</span> &#123;<br>    <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;baz&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 接收一个基础类 BaseClass 和任意数量的混入类 Mixins，返回一个融合了所有混入类功能的新类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mix</span>(<span class="hljs-params">BaseClass, ...Mixins</span>) &#123;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">        使用 reduce 迭代 Mixins 数组，将每个混入类依次应用到累积结果上</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        reduce 是 JavaScript 数组的一个高阶函数，用于将数组元素 “累积” 为单个值（也可用于复杂的数组转换）</span><br><span class="hljs-comment">        它通过迭代数组，对每个元素执行回调函数，并将结果传递给下一次迭代，最终得到一个汇总结果</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        迭代过程：</span><br><span class="hljs-comment">        每个 current（当前混入类）是一个函数，它接收上一步的 accumulator（累积的类）作为参数</span><br><span class="hljs-comment">        返回一个继承自 accumulator 并添加了自身功能的新类</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Mixins</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, current</span>) =&gt;</span><br>        <span class="hljs-title function_">current</span>(accumulator),  <span class="hljs-comment">// 当前混入类接收累积类作为参数，返回新的融合类</span><br>        <span class="hljs-title class_">BaseClass</span>);  <span class="hljs-comment">// 初始值：从基础类开始</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">FooMixin</span>(<span class="hljs-title class_">BarMixin</span>(<span class="hljs-title class_">BazMinxin</span>(<span class="hljs-title class_">Vehicle</span>))) &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">mix</span>(<span class="hljs-title class_">Vehicle</span>, <span class="hljs-title class_">FooMixin</span>, <span class="hljs-title class_">BarMixin</span>, <span class="hljs-title class_">BazMinxin</span>) &#123;&#125;<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>();  <span class="hljs-comment">// 与 let b = new Bus1(); 结果相同</span><br>b.<span class="hljs-title function_">foo</span>();  <span class="hljs-comment">// foo</span><br>b.<span class="hljs-title function_">bar</span>();  <span class="hljs-comment">// bar</span><br>b.<span class="hljs-title function_">baz</span>();  <span class="hljs-comment">// baz</span><br></code></pre></td></tr></table></figure><blockquote><p>很多 <code>JavaScript</code> 框架（<code>React</code>）已抛弃混入模式，转向组合模式（把方法提取到独立的类和辅助对象，再把它们组合起来，但不使用继承）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-继承</title>
    <link href="/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/"/>
    <url>/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>很多面向对象语言都支持<strong>接口继承</strong>和<strong>实现继承</strong>。前者只继承<strong>方法签名</strong>，后者继承<strong>实际的方法</strong>。</p><p><code>ECMAScript</code> 中的函数没有签名，所以<strong>只支持实现继承</strong>，并且通过原型链实现。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链的基本思想是<mark>通过原型继承多个引用类型的属性和方法</mark>，在实例和原型之间构造一条原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 实例属性</span><br>&#125;<br><br><span class="hljs-comment">// 原型方法</span><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSuperValue</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span>;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SubType 通过创建 SuperType 的实例并将其赋值给自己的原型实现对 SuperType 的继承</span><br><span class="hljs-comment">    SuperType 实例可以访问的所有属性和方法也会存在于 SubType.prototype</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    SubType.prototype 现在是 SuperType 的一个实例</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();<br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSubValue</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span>;<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getSuperValue</span>());  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><br><p><img src="/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/SubType_SuperType.png" alt="原型之间的关系"><br><br></p><blockquote><p>在读取实例上的属性时，首先在实例上搜索这个属性。如果没找到，则会继承搜索实例的原型</p><p>通过原型链实现继承后，可以继承向上搜索，搜索原型的原型</p><p>对属性和方法的搜索会一直持续到原型链的末端</p></blockquote><p>调用 <code>instance.getSuperValue()</code> 的搜索过程:<br><code>instance</code> -&gt; <code>SubType.prototype</code> -&gt; <code>SuperType.prototype</code> -&gt; <code>SuperType.getSuperValue()</code></p><h3 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h3><p>默认情况下，<mark>所有引用类型</mark>都继承自 <code>Object</code></p><ul><li><p><mark>任何函数</mark>的默认原型都是一个 <code>Object</code> 的实例</p></li><li><p>该实例有一个内部值针指向 <code>Object.prototype</code></p></li><li><p>自定义类型能够继承包括 <code>toString()</code>、<code>valueOf()</code> 在内的所有默认方法</p></li></ul><p><img src="/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/prototypeChain.png" alt="完整的继承原型链"></p><p>调用 <code>instance.toString()</code> 时，实际上调用的是保存在 <code>Object.prototype</code> 上的方法</p><h3 id="原型与继承关系"><a href="#原型与继承关系" class="headerlink" title="原型与继承关系"></a>原型与继承关系</h3><ul><li><p>如果一个实例的原型链中出现过相应的构造函数，则 <code>instanceof</code> 返回 <code>true</code></p></li><li><p>只要原型链中包含对应的原型，<code>isPrototypeOf()</code> 就返回 <code>true</code></p></li></ul><p>接<a href="#%E5%8E%9F%E5%9E%8B%E9%93%BE">前面代码</a>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SuperType</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SubType</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(instance));  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(instance));  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(instance));  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>子类覆盖父类的方法，或者增加父类没有的方法必须<strong>在原型赋值之后再加到原型上</strong></p><p>以<strong>对象字面量</strong>方式创建原型方法会破坏之前的原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSuperValue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span>;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 继承 SuperType</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// 在原型赋值之后将方法加到原型上</span><br><span class="hljs-comment">// 新方法</span><br><span class="hljs-comment">SubType.prototype.getSubValue = function () &#123;</span><br><span class="hljs-comment">    return this.subproperty;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// 覆盖已有的方法</span><br><span class="hljs-comment">SubType.prototype.getSuperValue = function () &#123;</span><br><span class="hljs-comment">    return false;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">let instance = new SubType();</span><br><span class="hljs-comment">console.log(instance.getSuperValue());  // false</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 通过对象字面量添加新方法，导致 SubType.prototype = new SuperType() 无效</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-title function_">getSubValue</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span>;<br>    &#125;,<br><br>    <span class="hljs-title function_">someOtherMethod</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-comment">// TypeError: instance.getSuperValue is not a function</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getSuperValue</span>());<br></code></pre></td></tr></table></figure><p>以<strong>对象字面量</strong>覆盖后的原型是一个 <code>Object</code> 的实例，不再是 <code>SuperType</code> 的实例。之前的原型链断开，<code>SubType</code> 和 <code>SuperType</code> 之间没关系了</p><h3 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><ul><li><p>原型中包含的引用值会在所有实例间共享</p></li><li><p>使用原型实现继承时，原型实际上变成了另一个类型的实例，表明原先的实例属性变成了原型属性</p></li><li><p>子类型在实例化时不能给父类型的构造函数传参</p></li></ul><h2 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h2><ul><li><p>若原型中的属性是<strong>基本类型</strong>（数字、字符串），实例修改时会<mark>在自身创建同名属性</mark>，不影响原型和其它实例</p></li><li><p>若原型中的属性是<strong>引用类型</strong>（数组、对象），实例修改时会<mark>直接操作原型中的引用值</mark>（实例本身没有该属性，会顺着原型链找到原型），导致<strong>所有实例的该属性被同时修改</strong></p></li></ul><p>为解决原型包含<strong>引用值</strong>导致的继承问题，<mark>在子类构造函数中调用父类构造函数</mark>，使用 <code>apply()</code> 和 <code>call()</code> 方法<strong>以新创建的对象为上下文执行构造函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">        继承 SuperType</span><br><span class="hljs-comment">        相当于新的 SubType 对象上运行了 SuperType() 函数中的所有初始化代码</span><br><span class="hljs-comment">        每个实例都会有自己的 colors 属性</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-comment">// [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1.<span class="hljs-property">colors</span>);<br><br><span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-comment">// [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance2.<span class="hljs-property">colors</span>);<br><br></code></pre></td></tr></table></figure><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>盗用构造函数可以在子类构造函数中向父类构造函数传参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 继承 SuperType 并传参</span><br>    <span class="hljs-comment">// 实际上会在 SubType 的实例上定义 name 属性</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;Nicholas&quot;</span>);<br><br>    <span class="hljs-comment">// 为确保 SuperType 构造函数不会覆盖 SubType 定义的属性</span><br>    <span class="hljs-comment">// 可以在调用父类构造函数之后再给子类实例添加额外的属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;  <span class="hljs-comment">// 实例属性</span><br>&#125;<br><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Nicholas</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">age</span>);  <span class="hljs-comment">// 29</span><br></code></pre></td></tr></table></figure><h3 id="盗用构造函数的问题"><a href="#盗用构造函数的问题" class="headerlink" title="盗用构造函数的问题"></a>盗用构造函数的问题</h3><ul><li><p>必须在构造函数中定义方法，函数不能重用</p></li><li><p>子类不能访问父类原型上定义的方法，所有类型只能使用构造函数模式</p></li></ul><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承综合了原型链和盗用构造函数，使用<strong>原型链</strong>继承原型上的<strong>属性和方法</strong>（共享原型方法），通过<strong>盗用构造函数</strong>继承<strong>实例属性</strong>（避免引用值共享）。既可以把方法定义在原型上实现重用，又可以让每个实例都有自己的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-comment">// 继承属性</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);  <span class="hljs-comment">// 子类构造函数，第二次调用 SuperType()</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 继承方法</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();  <span class="hljs-comment">// 创建子类原型，第一次调用 SuperType()</span><br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>);<br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-comment">// [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1.<span class="hljs-property">colors</span>);<br><span class="hljs-comment">// Nicholas</span><br>instance1.<span class="hljs-title function_">sayName</span>();<br><span class="hljs-comment">// 29</span><br>instance1.<span class="hljs-title function_">sayAge</span>();<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SuperType &#123;</span><br><span class="hljs-comment">      name: &#x27;Nicholas&#x27;,</span><br><span class="hljs-comment">      colors: [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ],</span><br><span class="hljs-comment">      age: 29</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SuperType &#123;</span><br><span class="hljs-comment">      name: undefined,</span><br><span class="hljs-comment">      colors: [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ],</span><br><span class="hljs-comment">      sayAge: [Function (anonymous)]</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br><span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>);<br><span class="hljs-comment">// [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance2.<span class="hljs-property">colors</span>);<br><span class="hljs-comment">// Greg</span><br>instance2.<span class="hljs-title function_">sayName</span>();<br><span class="hljs-comment">// 27</span><br>instance2.<span class="hljs-title function_">sayAge</span>();<br></code></pre></td></tr></table></figure><blockquote><p><strong>组合继承是 <code>JavaScript</code> 中使用最多的继承模式</strong></p><p>组合继承保留了 <code>instanceof</code> 操作符和 <code>isPrototypeOf()</code> 方法识别合成对象的能力</p></blockquote><p>但是，组合继承存在<strong>效率问题</strong>，<mark>父类构造函数始终会被调用两次</mark>：</p><ol><li><p>在创建子类原型时调用一次</p></li><li><p>在子类构造函数中调用一次</p></li></ol><p><img src="/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/combined_heritage.png" alt="组合继承"></p><p>由于调用了两次 <code>SuperType</code> 构造函数，所以有两组 <code>name</code> 和 <code>colors</code> 属性：一组在实例上，另一组在 <code>SubType</code> 的原型上</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>原型式继承适用于：</p><ul><li><p>在已有对象基础上再创建一个新对象</p></li><li><p>不需要单独创建构造函数，但仍然需要在对象间共享信息的场合</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// object() 函数会创建一个临时构造函数</span><br><span class="hljs-comment">// 将传入的对象赋值给这个构造函数的原型</span><br><span class="hljs-comment">// 本质上，object() 对传入的对象执行了一次浅复制</span><br><span class="hljs-comment">function object(o) &#123;</span><br><span class="hljs-comment">    function F() &#123;&#125;</span><br><span class="hljs-comment">    F.prototype = o;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 返回临时类型的一个实例</span><br><span class="hljs-comment">    return new F();</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">let person = &#123;</span><br><span class="hljs-comment">    name: &quot;Nicholas&quot;,</span><br><span class="hljs-comment">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">let anotherPerson = object(person);</span><br><span class="hljs-comment">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="hljs-comment">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">let yetAnotherPerson = object(person);</span><br><span class="hljs-comment">yetAnotherPerson.name = &quot;Linda&quot;;</span><br><span class="hljs-comment">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27; ]</span><br><span class="hljs-comment">console.log(person.friends);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>, <span class="hljs-string">&quot;Van&quot;</span>]<br>&#125;;<br><br><span class="hljs-comment">// ECMASCript 通过 Object.create() 方法将原型式继承的概念规范化</span><br><span class="hljs-keyword">let</span> anotherPerson = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(person);<br>anotherPerson.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Greg&quot;</span>;<br>anotherPerson.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Rob&quot;</span>);<br><br><span class="hljs-keyword">let</span> yetAnotherPerson = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(person);<br>yetAnotherPerson.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Linda&quot;</span>;<br>yetAnotherPerson.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Barbie&quot;</span>);<br><br><span class="hljs-comment">// [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">friends</span>);<br></code></pre></td></tr></table></figure><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式继承类似寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 可将 object() 函数替换为任何返回新对象的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">object</span>(<span class="hljs-params">o</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;<br><br>    <span class="hljs-comment">// 返回临时类型的一个实例</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br><br><span class="hljs-comment">// 函数参数为新对象的基准对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAnother</span>(<span class="hljs-params">original</span>) &#123;<br>    <span class="hljs-comment">// 通过调用函数创建一个新对象</span><br>    <span class="hljs-keyword">let</span> clone = <span class="hljs-title function_">object</span>(original);<br><br>    <span class="hljs-comment">// 给 clone 对象添加一个新方法（以某种方式增强对象）</span><br>    clone.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>    &#125;;<br><br>    <span class="hljs-comment">// 返回这个对象</span><br>    <span class="hljs-keyword">return</span> clone;<br>&#125;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>, <span class="hljs-string">&quot;Van&quot;</span>]<br>&#125;;<br><br><span class="hljs-keyword">let</span> anotherPerson = <span class="hljs-title function_">createAnother</span>(person);<br>anotherPerson.<span class="hljs-title function_">sayHi</span>();<br></code></pre></td></tr></table></figure><blockquote><p>寄生式继承适合主要关注对象，不在乎类型和构造函数的场景</p><p>通过寄生式继承给对象添加函数会导致函数难以重用</p></blockquote><h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><p>寄生式组合继承<mark>通过盗用构造函数继承属性，但使用<strong>混合式原型链</strong>继承方法</mark>（使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型）解决<a href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF">组合继承</a>的<strong>效率问题</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">object</span>(<span class="hljs-params">o</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br><br><span class="hljs-comment">// 函数接收子类构造函数和父类构造函数作为参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>) &#123;<br>    <span class="hljs-comment">// 创建父类原型的副本</span><br>    <span class="hljs-keyword">let</span> prototype = <span class="hljs-title function_">object</span>(superType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>    <span class="hljs-comment">// 给返回的 prototype 对象设置 constructor 属性</span><br>    <span class="hljs-comment">// 解决重写原型导致默认 constructor 丢失问题</span><br>    prototype.<span class="hljs-property">constructor</span> = subType;<br>    <span class="hljs-comment">// 将新创建的对象赋值给子类的原型</span><br>    subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-comment">// 只调用一次 SuperType 构造函数，避免属性重复</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-title class_">SubType</span>, <span class="hljs-title class_">SuperType</span>);<br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SubType &#123;</span><br><span class="hljs-comment">      name: &#x27;Nicholas&#x27;,</span><br><span class="hljs-comment">      colors: [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ],</span><br><span class="hljs-comment">      age: 29</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SuperType &#123;</span><br><span class="hljs-comment">      constructor: [Function: SubType],</span><br><span class="hljs-comment">      sayAge: [Function (anonymous)]</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br></code></pre></td></tr></table></figure><blockquote><p>使用寄生式组合继承原型链保持不变，<code>instanceof()</code> 和 <code>isPrototypeOf()</code> 正常有效</p><p>寄生式组合继承是<strong>引用类型继承的最佳模式</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-创建对象</title>
    <link href="/2025/10/22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <url>/2025/10/22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p><code>ECMAScript 6</code> 开始正式支持类和继承</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>按照惯例，构造函数名称的<strong>首字母</strong>都是<strong>大写</strong>的，非构造函数则以小写字母开头</p><p><strong><code>ECMAScript</code> 中的函数是对象</strong>，每次定义函数时，都会初始化一个对象</p><p>使用 <code>new</code> 操作符调用构造函数创建对象实例会执行如下操作：</p><blockquote><p>(1) 在内存中创建一个新对象</p><p>(2) 新对象内部的 <code>[[Protoype]]</code> 特性被赋值为构造函数的 <code>prototype</code> 属性</p><p>(3) 构造函数内部的 <code>this</code> 被赋值为这个新对象(即 <code>this</code> 指向新对象)</p><p>(4) 执行构造函数内部的代码(给新对象添加属性)</p><p>(5) 构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象</p></blockquote><h3 id="instanceof-操作符用于确定对象类型"><a href="#instanceof-操作符用于确定对象类型" class="headerlink" title="instanceof 操作符用于确定对象类型"></a><code>instanceof</code> 操作符用于确定对象类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数（Function）：是一种「可执行的对象」，它除了具备对象的所有特性（可存储属性、有原型等），还额外拥有「可调用性」（可以被执行，有参数和返回值）</span><br><span class="hljs-comment">// 函数是「能执行的对象」，对象是「函数创建的实例或数据集合」</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, job</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">job</span> = job;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Software Engineer&quot;</span>);<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&quot;Doctor&quot;</span>);<br><br><span class="hljs-comment">// Object 是所有对象的基类（原型链的顶端），几乎所有对象都直接或间接继承自 Object.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="实例化不传参数时，构造函数后面的括号可加可不加。只要有-new-操作符，就可以调用相应的构造函数"><a href="#实例化不传参数时，构造函数后面的括号可加可不加。只要有-new-操作符，就可以调用相应的构造函数" class="headerlink" title="实例化不传参数时，构造函数后面的括号可加可不加。只要有 new 操作符，就可以调用相应的构造函数"></a>实例化不传参数时，构造函数后面的括号可加可不加。只要有 <code>new</code> 操作符，就可以调用相应的构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Jake&quot;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>;<br></code></pre></td></tr></table></figure><h3 id="构造函数也是函数"><a href="#构造函数也是函数" class="headerlink" title="构造函数也是函数"></a>构造函数也是函数</h3><ul><li><p>任何函数只要使用 <code>new</code> 操作符调用就是构造函数，而不使用 <code>new</code> 操作符调用的函数就是普通函数</p></li><li><p>没有使用 <code>new</code> 操作符调用构造函数，结果会将属性和方法添加到 <code>window</code> 对象</p></li><li><p>在调用一个函数没有明确设置 <code>this</code> 值(没有作为对象的方法调用，或没有使用 <code>call()/apply()</code> 调用)，<code>this</code> 始终指向 <code>Global</code> 对象(浏览器中为 <code>window</code> 对象)</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 只有浏览器环境中才有 window 对象</span><br><span class="hljs-comment">// 在 Node.js 环境中执行会报错 ReferenceError: window is not defined</span><br><span class="hljs-variable language_">window</span> = <span class="hljs-variable language_">global</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, job</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">job</span> = job;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>    <span class="hljs-comment">// 与 sayName 逻辑上等价</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&quot;console.log(this.name)&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Software Engineer&quot;</span>);<br>person.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Nicholas</span><br><br><span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&quot;Doctor&quot;</span>);<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Greg</span><br><br><span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">    call() 是函数对象的一个方法，用于调用函数并指定函数执行时的 this 指向</span><br><span class="hljs-comment">    将对象 o 指定为 Person() 内部的 this 值</span><br><span class="hljs-comment">    所有属性和 sayName() 方法都会添加到对象 o</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(o, <span class="hljs-string">&quot;Kristen&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Nurse&quot;</span>);<br>o.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Kristen</span><br></code></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>每个函数都会创建一个 <code>prototype</code> 对象属性，包含应该由特定引用类型的实例共享的属性和方法</p><p>当通过构造函数创建实例时，实例会自动「关联」到该原型对象，从而可以共享原型对象中的属性和方法，避免重复定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-comment">// let Person = function() &#123;&#125;;  // 等价函数表达式</span><br><br><span class="hljs-comment">// 在构造函数中直接赋给对象实例的值，可以直接赋给它们的原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person1.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Nicholas</span><br><br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person2.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Nicholas</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">sayName</span> == person2.<span class="hljs-property">sayName</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// [Function: Person]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">取得对象的原型</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  name: &#x27;Nicholas&#x27;,</span><br><span class="hljs-comment">  age: 29,</span><br><span class="hljs-comment">  job: &#x27;Software Engineer&#x27;,</span><br><span class="hljs-comment">  sayName: [Function (anonymous)]</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person1));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person2));<br></code></pre></td></tr></table></figure><h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><p>只要创建一个函数，就会按照特定的规则为这个函数创建一个 <code>prototype</code> 属性（指向原型对象）。默认情况下，<strong>所有原型对象自动获得一个名为 <code>constructor</code> 的属性，指向与之关联的构造函数</strong></p><p><a href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">前面代码</a>中的 <code>Person.prototype.constructor</code> 指向 <code>Person</code></p><p>自定义构造函数时，原型对象默认只会获得 <code>constructor</code> 属性，其它所有方法都继承自 <code>Object</code></p><p>每次调用构造函数创建一个新实例，该实例的内部 <code>[[Prototype]]</code> 指针就会被赋值为构造函数的原型对象。浏览器会在每个对象上暴露可以访问原型对象的 <code>__proto__</code> 属性</p><p><strong>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有联系</strong></p><p>构造函数通过 <code>prototype</code> 指向原型对象，实例通过 <code>__proto__</code> 关联原型对象</p><p><img src="/2025/10/22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/person.prototype.png" alt="构造函数、原型对象和对象之间的关系"></p><ul><li><p><code>Person.prototype</code> 指向原型对象，而 <code>Person.prototpye.constructor</code> 指向 <code>Person</code> 构造函数</p></li><li><p>原型对象包含 <code>constructor</code> 属性和其他后来添加的属性</p></li><li><p>两个实例都没有属性和方法，但可以正常调用 <code>sayName()</code> 函数<br><br></p></li></ul><blockquote><p>使用 <code>Object.getPrototypeOf()</code> 可以取得一个对象的原型</p><p>为避免使用 <code>Object.setPrototypeOf()</code> 可能造成的性能下降，可以通过 <code>Object.create()</code> 创建一个新对象，同时为其指定原型</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> biped = &#123;<br>    <span class="hljs-attr">numLegs</span>: <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(biped);<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Matt&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Matt</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">numLegs</span>);  <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person) === biped);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h3><p>通过对象访问属性时，如果在对象实例上发现了给定的名称，则返回该名称对应的值。否则，会沿着指针进入原型对象，在原型对象上找到属性，再返回对应的值</p><p>只要给对象实例添加一个属性，这个属性就会<strong>遮蔽</strong>原型对象上的同名属性。使用 <code>delete</code> 操作符可以完全删除实例上的属性，让标识符解析过程能够继续搜索原型对象</p><p><code>hasOwnProperty()</code> 方法会在属性存在于调用它的对象实例上时返回 <code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>person1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Greg&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Greg</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Nicholas</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">delete</span> person1.<span class="hljs-property">name</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Nicholas</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><br><blockquote><p><code>ECMAScript</code> 的 <code>Object.getOWnPropertyDescriptor()</code> 方法只对实例属性有效</p><p>必须直接在原型对象上调用 <code>Object.getOwnPropertyDescriptor()</code> 获得原型属性的描述符</p></blockquote><h3 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a><code>in</code> 操作符</h3><p><code>in</code> 操作符会在可以通过对象访问指定属性时返回 <code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">in</span> person1);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>要确定原型上是否存在某个属性，可以同时使用 <code>hasOwnProperty()</code> 和 <code>in</code> 操作符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasPrototypeProperty</span>(<span class="hljs-params">object, name</span>) &#123;<br>    <span class="hljs-comment">// 通过对象可以访问时，in 操作符返回 true</span><br>    <span class="hljs-comment">// hasOwnProperty() 只有实例上存在属性时才返回 true</span><br>    <span class="hljs-comment">// in 操作符返回 true 且 hasOwnProperty() 返回 false 为原型属性</span><br>    <span class="hljs-keyword">return</span> !object.<span class="hljs-title function_">hasOwnProperty</span>(name) &amp;&amp; (name <span class="hljs-keyword">in</span> object);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasPrototypeProperty</span>(person, <span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// true</span><br><br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Greg&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasPrototypeProperty</span>(person, <span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><code>Object.keys()</code> 可以获得对象上所有可枚举的实例属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys);  <span class="hljs-comment">// [ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;sayName&#x27; ]</span><br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Rob&quot;</span>;<br>p1.<span class="hljs-property">age</span> = <span class="hljs-number">50</span>;<br><br><span class="hljs-keyword">let</span> p1keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(p1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1keys);  <span class="hljs-comment">// [ &#x27;name&#x27;, &#x27;age&#x27; ]</span><br><br><span class="hljs-comment">// 无论是否可以枚举，Object.getOWnPropertyNames() 都可以列出所有实例属性</span><br><span class="hljs-keyword">let</span> keys1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">// 返回的结果中包含一个不可枚举的属性 constructor</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys1);  <span class="hljs-comment">// [ &#x27;constructor&#x27;, &#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;sayName&#x27; ]</span><br></code></pre></td></tr></table></figure><p><code>Object.geOwnPropertySymbols()</code> 用于获取对象自身所有 <strong><code>Symbol</code> 类型属性</strong>（不包含继承的 <code>Symbol</code> 属性），与 <code>Object.getOwnPropertyNames()</code> 类似，但专门针对 <code>Symbol</code> 类型的属性（普通字符串属性不会被返回）</p><h3 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h3><p><code>for-in</code> 循环和 <code>Object.keys()</code> 的枚举顺序时不确定的，取决于 <code>JavaScript</code> 引擎，可能因浏览器而异</p><p><code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code> 和 <code>Object.assign()</code> <mark>先以升序枚举数值键</mark>，然后<mark>以插入顺序枚举字符串和符号键</mark>。</p><p>在对象字面量中定义的键以它们逗号分割的顺序（<strong>键值对的书写顺序</strong>）插入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> k1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;k1&#x27;</span>),<br>    k2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;k2&#x27;</span>);<br><br><span class="hljs-keyword">let</span> o = &#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;first&#x27;</span>,<br>    [k2]: <span class="hljs-string">&#x27;sym2&#x27;</span>,<br>    <span class="hljs-attr">second</span>: <span class="hljs-string">&#x27;second&#x27;</span>,<br>    <span class="hljs-number">0</span>: <span class="hljs-number">0</span><br>&#125;;<br><br>o[k1] = <span class="hljs-string">&#x27;sym2&#x27;</span>;<br>o[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>o.<span class="hljs-property">third</span> = <span class="hljs-string">&#x27;third&#x27;</span>;<br>o[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// [ &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;first&#x27;, &#x27;second&#x27;, &#x27;third&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(o));<br><br><span class="hljs-comment">// [ Symbol(k2), Symbol(k1) ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(o));<br></code></pre></td></tr></table></figure><h2 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h2><p>静态方法 <code>Object.values()</code> 和 <code>Object.entries()</code> 用于将对象内容转换为可迭代序列化的格式</p><ul><li><p>这两个方法接收一个对象</p></li><li><p><code>Object.values()</code> 返回<strong>对象值的数组</strong></p></li><li><p><code>Object.entries()</code> 返回<strong>键&#x2F;值对的数组</strong></p></li><li><p>非字符串属性会被转换为字符串输出</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>();<br><br><span class="hljs-keyword">const</span> o = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">qux</span>: &#123;&#125;,<br>    [sym]: <span class="hljs-string">&#x27;foo&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 符号属性 sym 会被忽略</span><br><span class="hljs-comment">// [ &#x27;bar&#x27;, 1, &#123;&#125; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(o));<br><br><span class="hljs-comment">// [ [ &#x27;foo&#x27;, &#x27;bar&#x27; ], [ &#x27;baz&#x27;, 1 ], [ &#x27;qux&#x27;, &#123;&#125; ] ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(o));<br><br><span class="hljs-comment">// 这两个方法执行对象的浅复制</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(o)[<span class="hljs-number">0</span>] === o.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">    Object.entries(o)[0]: [&#x27;foo&#x27;, &#x27;bar&#x27;]</span><br><span class="hljs-comment">    Object.entries(o)[0][1]: &#x27;bar&#x27;</span><br><span class="hljs-comment">    o.foo: &#x27;bar&#x27;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(o)[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] === o.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="其他原型语法"><a href="#其他原型语法" class="headerlink" title="其他原型语法"></a>其他原型语法</h3><p>为了减少代码冗余，通常直接通过一个包含所有属性和方法的对象字面量来重写原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-comment">// 防止 constructor 属性指向 Object 构造函数</span><br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">29</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> friend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(friend <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(friend <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(friend.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(friend.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 与 constructor: Person 等价操作</span><br><span class="hljs-comment">// Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class="hljs-comment">//     enumerable: false,</span><br><span class="hljs-comment">//     value: Person</span><br><span class="hljs-comment">// &#125;);</span><br></code></pre></td></tr></table></figure><h3 id="原型动态性"><a href="#原型动态性" class="headerlink" title="原型动态性"></a>原型动态性</h3><p>从原型上搜索值的过程是动态的，即使实例在修改原型之前已经存在，任何时候对原型所作的修改也会在实例上反映出来</p><p>原因：实例和原型之间使用指针链接，而不是保存的副本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-comment">// constructor: Person,</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">29</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> friend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-comment">// 创建 friend 实例后添加 sayHi() 方法</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>&#125;;<br><br><span class="hljs-comment">// friend 仍然可以访问 sayHi() 方法</span><br>friend.<span class="hljs-title function_">sayHi</span>();  <span class="hljs-comment">// hi</span><br></code></pre></td></tr></table></figure><p>重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-keyword">let</span> friend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">29</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// friend 指向的还是最初的原型，并没有 sayName() 属性</span><br>friend.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// TypeError: friend.sayName is not a function</span><br></code></pre></td></tr></table></figure><br><p><img src="/2025/10/22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/rewrite_prototype.png" alt="重写原型后的对应关系"></p><h3 id="原生对象原型"><a href="#原生对象原型" class="headerlink" title="原生对象原型"></a>原生对象原型</h3><p>所有原生引用类型的构造函数（包括 <code>Object</code>、<code>Array</code>、<code>String</code> 等）都在原型上定义了实例方法</p><p>可以像修改自定义对象原型一样修改原生对象原型，随时可以添加方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 String 原始值包装类型的实例添加一个 startsWith() 方法</span><br><span class="hljs-comment">// 当前环境下所有的字符串都可以使用这个方法</span><br><span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">startsWith</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">indexOf</span>(text) === <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">let</span> msg = <span class="hljs-string">&quot;Hello world!&quot;</span>;<br><span class="hljs-comment">// 读取 msg 的属性时，后台会自动创建 String 的包装实例（JavaScript 临时创建的对应的对象类型实例）</span><br><span class="hljs-comment">// 找到并调用 startsWith() 方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br></code></pre></td></tr></table></figure><blockquote><p>推荐创建一个自定义的类，继承原生类型<br>不推荐修改原生对象原型，直接修改原生对象类型可能引发命名冲突</p></blockquote><h3 id="原型的问题"><a href="#原型的问题" class="headerlink" title="原型的问题"></a>原型的问题</h3><p>原型弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值</p><p>原型最主要问题源自它的<strong>共享特性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">29</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>],<br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>person1.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Van&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">friends</span>);  <span class="hljs-comment">// [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">friends</span>);  <span class="hljs-comment">// [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">friends</span> === person2.<span class="hljs-property">friends</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>由于 <code>friends</code> 属性存在于 <code>Person.prototype</code> 而非 <code>person1</code> 上，新加的 “Van” 也会在 <code>person2.friends</code> 上反映出来</p><p>一般不同的实例应该有属于自己的属性副本，所以在实际开发中通常不单独使用原型模式</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-对象基本概念</title>
    <link href="/2025/10/21/JavaScript-%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2025/10/21/JavaScript-%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p><code>ECMA-262</code> 使用两个中括号把特性的名称括起来，将某个特性标识为内部特性，例如 <code>[[Enumerable]]</code></p><h2 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h2><ul><li><p>数据属性包含一个保存数据值的位置，从这个位置读取和写入值</p></li><li><p>调用 <code>Object.defineProperty()</code> 如果不指定 <code>configurable、enumerable 和 writable</code>，默认都为 <code>false</code></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义一个对象，包含伪私有成员 year_ 和公共成员 edition</span><br><span class="hljs-keyword">let</span> book = &#123;<br><span class="hljs-attr">year_</span>: <span class="hljs-number">2017</span>,  <span class="hljs-comment">// year_ 中的下划线表示该属性不希望在对象方法的外部被访问</span><br><span class="hljs-attr">edition</span>: <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><ul><li><p>访问器属性不包含数据值，包含一个获取（<code>getter</code>）函数和一个设置（<code>setter</code>）函数</p></li><li><p>只定义 <code>getter</code> 函数意味着属性是只读的，尝试修改属性会被忽略</p></li><li><p>只有一个 <code>setter</code> 函数的属性是不能读取的</p></li></ul><h2 id="Object-defineProperties-方法可以通过多个描述符一次性定义多个属性"><a href="#Object-defineProperties-方法可以通过多个描述符一次性定义多个属性" class="headerlink" title="Object.defineProperties() 方法可以通过多个描述符一次性定义多个属性"></a><code>Object.defineProperties()</code> 方法可以通过多个描述符一次性定义多个属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(book, &#123;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">        year_ 和 edition 是数据属性</span><br><span class="hljs-comment">    configurable、enumerable 和 writable 特性值都是 false</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        使用 Object.defineProperties 必须使用 Object 定义属性</span><br><span class="hljs-comment">        否则会报错 TypeError: Property description must be an object:</span><br><span class="hljs-comment">    */</span><br><span class="hljs-attr">year_</span>: &#123;<br><span class="hljs-attr">value</span>: <span class="hljs-number">2017</span><br>&#125;,<br><br><span class="hljs-attr">edition</span>: &#123;<br><span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;,<br><br><span class="hljs-comment">// 访问器属性</span><br><span class="hljs-attr">year</span>: &#123;<br><span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span>;<br>&#125;,<br><br><span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br><span class="hljs-keyword">if</span>(newValue &gt; <span class="hljs-number">2017</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span> = newValue;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">edition</span> += newValue - <span class="hljs-number">2017</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="使用-Object-getOwnPropertyDescriptor-方法可以取得指定属性的属性描述符"><a href="#使用-Object-getOwnPropertyDescriptor-方法可以取得指定属性的属性描述符" class="headerlink" title="使用 Object.getOwnPropertyDescriptor() 方法可以取得指定属性的属性描述符"></a>使用 <code>Object.getOwnPropertyDescriptor()</code> 方法可以取得指定属性的属性描述符</h2><p>该方法接收属性所在的对象和要取得其描述符的属性名</p><p><strong>访问器属性</strong>返回包含 <code>configurable、enumerable、get</code> 和 <code>set</code> 属性的对象</p><p><strong>数据属性</strong>返回包含 <code>configurable、enumerable、writable</code> 和 <code>value</code> 属性的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book = &#123;&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(book, &#123;<br>    <span class="hljs-attr">year_</span>: &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-number">2017</span><br>    &#125;,<br><br>    <span class="hljs-attr">edition</span>: &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>    &#125;,<br><br>    <span class="hljs-attr">year</span>: &#123;<br>        <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span>;<br>        &#125;,<br><br>        <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) &#123;<br>            <span class="hljs-keyword">if</span> (newValue &gt; <span class="hljs-number">2017</span>) &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span> = newValue;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">edition</span> += newValue - <span class="hljs-number">2017</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;);<br><br><span class="hljs-keyword">let</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(book, <span class="hljs-string">&#x27;year_&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">value</span>);  <span class="hljs-comment">// 2017</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">configurable</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> descriptor.<span class="hljs-property">get</span>);  <span class="hljs-comment">// undefined</span><br><br>descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(book, <span class="hljs-string">&#x27;year&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">value</span>);  <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">enumerable</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> descriptor.<span class="hljs-property">get</span>);  <span class="hljs-comment">// function</span><br><br><span class="hljs-comment">// Object.getOwnPropertyDescriptors() 会在每个自有属性上调用 Object.getOwnPropertyDescriptor() 并在一个新对象中返回它们</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(book));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  year_: &#123;</span><br><span class="hljs-comment">    value: 2017,</span><br><span class="hljs-comment">    writable: false,</span><br><span class="hljs-comment">    enumerable: false,</span><br><span class="hljs-comment">    configurable: false</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  edition: &#123; value: 1, writable: false, enumerable: false, configurable: false &#125;,</span><br><span class="hljs-comment">  year: &#123;</span><br><span class="hljs-comment">    get: [Function: get],</span><br><span class="hljs-comment">    set: [Function: set],</span><br><span class="hljs-comment">    enumerable: false,</span><br><span class="hljs-comment">    configurable: false</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="Object-assign-方法用于合并对象"><a href="#Object-assign-方法用于合并对象" class="headerlink" title="Object.assign() 方法用于合并对象"></a><code>Object.assign()</code> 方法用于合并对象</h2><p>该方法接收<strong>一个目标对象</strong>和<strong>一个或多个源对象</strong>作为参数，然后将每个源对象中可枚举（<code>Object.propertyIsEnumerable()</code> 返回 <code>true</code>） 和自有（<code>Object.hasOwnProperty()</code> 返回 <code>true</code>）属性复制到目标对象</p><p>该方法会复制以字符串和符号为键的属性</p><p>对每个符合条件的属性，该方法会使用源对象上的 <code>[[Get]]</code> 取得属性的值，然后使用目标对象上的 <code>[[Set]]</code> 设置属性的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">dest = &#123;<br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">val</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Invoked dest setter with param <span class="hljs-subst">$&#123;val&#125;</span>`</span>);<br>    &#125;<br>&#125;;<br><br>src = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Invoked src getter&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">调用 src 的获取方法</span><br><span class="hljs-comment">调用 dest 的设置方法并传入参数 &quot;foo&quot;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, src);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Invoked src getter</span><br><span class="hljs-comment">Invoked dest setter with param foo</span><br><span class="hljs-comment">&#123; a: [Setter] &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dest);<br></code></pre></td></tr></table></figure><hr><p><code>Object.assign()</code> 对每个源对象执行<strong>浅复制</strong>(1.直接复制对象的基本类型值 2.引用类型数据只复制内存地址，<strong>新旧对象共享同一份深层数据</strong>，修改深层数据会相互影响)。如果多个源对象有相同的属性，则使用最后一个复制的值</p><p>如果赋值期间出错，操作会中止并退出，同时抛出错误</p><h2 id="Object-is-判定相等"><a href="#Object-is-判定相等" class="headerlink" title="Object.is() 判定相等"></a><code>Object.is()</code> 判定相等</h2><p><code>Object.is()</code> 与 <code>===</code> 类似，但能正确处理特殊值</p><ul><li><p><code>Object.is(NaN, NaN)</code> 返回 <code>true</code>（而 <code>NaN === NaN</code> 返回 <code>false</code>）</p></li><li><p><code>Object.is(+0, -0)</code> 返回 <code>false</code>（而 <code>+0 === -0</code> 返回 <code>true</code>）</p></li></ul><h2 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h2><h3 id="简写属性名"><a href="#简写属性名" class="headerlink" title="简写属性名"></a>简写属性名</h3><p>简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 <code>ReferenceError</code></p><p>下面两段代码等价</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>;<br><br><span class="hljs-keyword">let</span> person = &#123;<br><span class="hljs-attr">name</span>: name<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);  <span class="hljs-comment">// &#123; name: &#x27;Matt&#x27; &#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>name<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);  <span class="hljs-comment">// &#123; name: &#x27;Matt&#x27; &#125;</span><br></code></pre></td></tr></table></figure><h3 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h3><p>可计算属性可以在对象字面量中完成动态属性赋值，不用先声明对象，再使用中括号语法来添加属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> nameKey = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-keyword">const</span> ageKey = <span class="hljs-string">&#x27;age&#x27;</span>;<br><span class="hljs-keyword">const</span> jobKey = <span class="hljs-string">&#x27;job&#x27;</span>;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>[nameKey]: <span class="hljs-string">&#x27;Matt&#x27;</span>,<br>[ageKey]: <span class="hljs-number">27</span>,<br>[jobKey]: <span class="hljs-string">&#x27;Software engineer&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#x27;Software engineer&#x27; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);<br></code></pre></td></tr></table></figure><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象解构就是使用与对象匹配的结构来实现对象属性赋值，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。</p><p>如果引用的属性不存在，则该变量的值就是 <code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Matt&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">name</span>: personName, <span class="hljs-attr">age</span>: personAge &#125; = person;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personName);  <span class="hljs-comment">// Matt</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personAge);  <span class="hljs-comment">// 27</span><br><br><span class="hljs-comment">// let &#123; name, age &#125; = person;</span><br><br><span class="hljs-comment">// console.log(name);  // Matt</span><br><span class="hljs-comment">// console.log(age);  // 27</span><br><br><span class="hljs-keyword">let</span> &#123; name, job &#125; = person;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);  <span class="hljs-comment">// Matt</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(job);  <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><ul><li><p>解构在内部使用函数 <code>ToObject()</code> 把数据结构转换为对象</p></li><li><p>在对象解构的上下文中，原始值会被当成对象</p></li><li><p><code>null</code> 和 <code>undefined</code> 不能被解构，否则会抛出错误</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; length &#125; = <span class="hljs-string">&#x27;foobar&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(length);  <span class="hljs-comment">// 6</span><br><br><span class="hljs-comment">// 通过对象解构赋值，从数字 4 的「包装对象」中提取 constructor 属性，并将其赋值给变量 c</span><br><span class="hljs-comment">// 对象的 constructor 属性指向创建该对象的构造函数</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">constructor</span>: c &#125; = <span class="hljs-number">4</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c === <span class="hljs-title class_">Number</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">let</span> &#123; _ &#125; = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// TypeError</span><br><span class="hljs-keyword">let</span> &#123; _0 &#125; = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure><p><strong>如果给事先声明的变量赋值，则赋值表达式必须包含在一对括号中</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> personName, personAge;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Matt&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span><br>&#125;;<br><br><span class="hljs-comment">// let &#123;name: personName, age: personAge&#125; = person;</span><br>(&#123;<span class="hljs-attr">name</span>: personName, <span class="hljs-attr">age</span>: personAge&#125; = person);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personName, personAge);  <span class="hljs-comment">// Matt, 27</span><br></code></pre></td></tr></table></figure><p>解构赋值可以使用嵌套解构，以匹配嵌套的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Matt&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span>,<br>    <span class="hljs-attr">job</span>: &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Software Engineer&#x27;</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 声明 title 变量并将 person.job.title 的值赋给它</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">job</span>: &#123; title &#125; &#125; = person;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(title);  <span class="hljs-comment">// Software Engineer</span><br></code></pre></td></tr></table></figure><ul><li><p>在源对象或目标对象外层属性没有定义的情况下不能使用嵌套解构</p></li><li><p>如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>popup.html 代码理解</title>
    <link href="/2025/10/21/popup-html-%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <url>/2025/10/21/popup-html-%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 声明文档类型为 HTML5，告诉浏览器以 HTML5 标准解析文档，避免进入 “怪异模式”（兼容旧版本 HTML 的解析方式）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 整个 HTML 文档的根容器，所有其他元素都嵌套在其中 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 用于定义文档的元数据、外部资源引用（脚本、样式等），不直接显示在页面上 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">用于响应式设计，适配移动设备（虽然扩展弹出页通常尺寸固定，但仍可能涉及缩放）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">width=device-width：让页面宽度等于设备宽度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">initial-scale=1：初始缩放比例为 1（不缩放）</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">defer=&quot;defer&quot;：表示脚本会延迟执行。浏览器会继续解析 HTML，同时下载脚本，直到 HTML 解析完成后再执行脚本</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">../js/popup.js，表示当前目录的上一级目录中的 js 文件夹）</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span>=<span class="hljs-string">&quot;defer&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/popup.js&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">引入外部 CSS 样式表 popup.css，用于美化页面样式</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">该路径等价于 ../css/popup.css</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">rel=&quot;stylesheet&quot; 表明这是一个样式表文件</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../js/../css/popup.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">包含页面的可见内容，是用户实际看到的部分</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">一个空的 &lt;div&gt; 容器，用于通过 JavaScript（popup.js）动态生成弹出页的内容（如按钮、列表、表单等）。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">id=&quot;chrome-extension-popup&quot; 为其指定唯一标识，方便脚本通过 document.getElementById 获取该元素并操作（如添加子元素、修改内容等）</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;chrome-extension-popup&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码理解</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manifest.json 代码理解</title>
    <link href="/2025/10/21/manifest-json-%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <url>/2025/10/21/manifest-json-%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<!-- 给一个 `Chrome` 扩展程序的 `manifest.json` 文件添加了理解注释 --><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-comment">// 定义扩展在浏览器工具栏中的按钮（即 “动作按钮”）</span><br>   <span class="hljs-attr">&quot;action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;default_icon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;icons/ic_16.png&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 按钮默认显示的图标（16x16）</span><br>      <span class="hljs-attr">&quot;default_popup&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;html/popup.html&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 点击按钮时弹出的页面（html/popup.html），通常用于展示功能界面（如提取结果）</span><br>      <span class="hljs-attr">&quot;default_title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Turbo Email Extractor&quot;</span>  <span class="hljs-comment">// 鼠标悬停在按钮上时显示的提示文字</span><br>   <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 定义扩展的背景服务</span><br>   <span class="hljs-attr">&quot;background&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// 指定背景服务的脚本文件, 用于处理扩展的后台逻辑（如监听事件、持久化数据等）</span><br>      <span class="hljs-comment">// service worker 是无界面的，生命周期由浏览器管理，不支持 DOM 操作</span><br>      <span class="hljs-comment">// DOM（Document Object Model，文档对象模型）操作指的是通过代码对 HTML 或 XML 文档的结构、内容和样式进行动态修改的过程</span><br>      <span class="hljs-attr">&quot;service_worker&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;js/background.js&quot;</span><br>   <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 定义内容脚本（注入到网页中的脚本，用于操作网页 DOM 或数据）</span><br>   <span class="hljs-attr">&quot;content_scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// 注入到匹配网页的样式表（css/contentScripts.css），用于修改网页样式</span><br>      <span class="hljs-attr">&quot;css&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;css/contentScripts.css&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// 注入到匹配网页的脚本（js/contentScripts.js），核心逻辑（如提取网页中的邮件地址）通常在这里实现</span><br>      <span class="hljs-attr">&quot;js&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;js/contentScripts.js&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// 匹配的网页 URL 规则，&lt;all_urls&gt; 表示所有 HTTP/HTTPS/FTP 等网页</span><br>      <span class="hljs-attr">&quot;matches&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;\u003Call_urls&gt;&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// 脚本注入时机，document_start 表示在网页 DOM 开始解析时注入（早于 document_ready）</span><br>      <span class="hljs-comment">// </span><br>      <span class="hljs-comment">// document_start:</span><br>      <span class="hljs-comment">// 浏览器刚刚开始解析 HTML 文档，尚未构建任何 DOM 节点，&lt;html&gt; 标签甚至都未被解析</span><br>      <span class="hljs-comment">// 此时，文档处于最早期的加载阶段，仅完成了资源的初始获取，尚未开始实质性的 DOM 树构建</span><br>      <span class="hljs-comment">// 适合执行不需要依赖 DOM 的初始化操作（如设置全局变量、注册事件监听框架等）</span><br>      <span class="hljs-comment">// </span><br>      <span class="hljs-comment">// document_ready:</span><br>      <span class="hljs-comment">// 对应 DOMContentLoaded 事件触发的时刻，即 HTML 文档完全解析并构建出完整的 DOM 树</span><br>      <span class="hljs-comment">// 此时无需等待样式表、图片、iframe 等外部资源加载完成</span><br>      <span class="hljs-comment">// DOM 树已完整可用，可以安全地操作任何 DOM 元素（如查询、修改、绑定事件等）</span><br>      <span class="hljs-comment">// 若存在阻塞 DOM 解析的脚本（如同步 &lt;script&gt;），会延迟 document_ready 的触发时间</span><br>      <span class="hljs-attr">&quot;run_at&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;document_start&quot;</span><br>   <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Extract emails from all web pages&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// host_permissions 声明扩展需要访问的主机权限，&lt;all_urls&gt; 表示允许访问所有 URL 的网页</span><br>   <span class="hljs-comment">// \u003C 表示 &#x27;&lt;&#x27; 的转义序列</span><br>   <span class="hljs-comment">// \u 后跟四位十六进制数字是 Unicode 转义序列格式，用于表示特定的 Unicode 字符</span><br>   <span class="hljs-comment">// 003C 对应 Unicode 字符集中小于号(&lt;)的代码点</span><br>   <span class="hljs-attr">&quot;host_permissions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;\u003Call_urls&gt;&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 定义扩展在不同场景下显示的图标</span><br>   <span class="hljs-attr">&quot;icons&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;128&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;icons/ic_128.png&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 安装时的提示、应用商店展示等</span><br>      <span class="hljs-attr">&quot;16&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;icons/ic_16.png&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 扩展管理页面、地址栏图标等</span><br>      <span class="hljs-attr">&quot;48&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;icons/ic_48.png&quot;</span>  <span class="hljs-comment">// 扩展详情页</span><br>   <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 扩展的公钥（用于标识扩展的唯一性，通常由浏览器自动生成，发布到应用商店时需要）</span><br>   <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwE/GAGNbengnDoGO4v5onC9CSpzyZm/i33QPKOxVw1OLY2cmqJgcX/t5NnWw7AzQchfwoB35+XqwJcaqkTLNNnM53FsrX938xqONasC17Be+Tih41jAjCkAnQWtokZxFv23vChuCOSlUmKHmwRLtag0/rJTbZvUED29irrZVDX0cedqhNFZlTJ/Sk9WDr26pl56cgMNxaVXB3vhpP7CHNb5C3yAHVJUPOOhxk2LAavb+sjSUXS8Q4DMBz2pAIYOoUAdrweuhU48pFU0RrzqgMtZxpnz15Sd26yk0FeIndKM+FFV5n7lV5C1q3DihHkxBCdnEgEmjdG3Hq4n+1UklGwIDAQAB&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;manifest_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Turbo Email Extractor&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">      声明扩展需要的功能权限</span><br><span class="hljs-comment">      tabs：允许操作浏览器标签页（如获取标签信息）</span><br><span class="hljs-comment">      activeTab：仅允许访问当前激活的标签页（临时权限，提高安全性）</span><br><span class="hljs-comment">      storage：允许使用浏览器的本地存储（chrome.storage）保存数据（如提取的邮件）</span><br><span class="hljs-comment">      background：允许访问背景服务（与 background 配置配合）</span><br><span class="hljs-comment">      webRequest：允许监听和拦截网页请求（可能用于从网络请求中提取邮件）</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-attr">&quot;permissions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;tabs&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;activeTab&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;storage&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;background&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;webRequest&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 扩展的自动更新地址（Chrome 扩展商店的标准更新接口）</span><br>   <span class="hljs-attr">&quot;update_url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://clients2.google.com/service/update2/crx&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.1&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 声明允许网页（而非扩展自身）访问的扩展资源</span><br>   <span class="hljs-attr">&quot;web_accessible_resources&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;matches&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;\u003Call_urls&gt;&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 允许哪些网页访问这些资源，&lt;all_urls&gt; 表示所有网页均可访问</span><br>      <span class="hljs-attr">&quot;resources&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;images/*&quot;</span> <span class="hljs-punctuation">]</span>  <span class="hljs-comment">// resources: 允许访问的资源路径（images/* 表示 images 目录下的所有文件，如图标、图片等）</span><br>   <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>代码理解</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
