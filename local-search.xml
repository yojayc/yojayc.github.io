<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript 笔记-代理模式</title>
    <link href="/2025/10/30/JavaScript-%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2025/10/30/JavaScript-%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="跟踪属性访问"><a href="#跟踪属性访问" class="headerlink" title="跟踪属性访问"></a>跟踪属性访问</h2><p>通过捕获 <code>get</code>、<code>set</code> 和 <code>has</code> 等操作，可以知道什么时候访问和查询过对象属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> user = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Jake&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(user, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property, receiver</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Getting <span class="hljs-subst">$&#123;property&#125;</span>`</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;,<br><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Setting <span class="hljs-subst">$&#123;property&#125;</span>=<span class="hljs-subst">$&#123;value&#125;</span>`</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br>proxy.<span class="hljs-property">name</span>;  <span class="hljs-comment">// Getting name</span><br>proxy.<span class="hljs-property">age</span> = <span class="hljs-number">27</span>;  <span class="hljs-comment">// Setting age=27</span><br></code></pre></td></tr></table></figure><h2 id="隐藏属性"><a href="#隐藏属性" class="headerlink" title="隐藏属性"></a>隐藏属性</h2><p>代理的内部实现对外部代码不可见，能方便地隐藏目标对象上的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hiddenProperties = [<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>];<br><br><span class="hljs-keyword">const</span> targetObject = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-attr">baz</span>: <span class="hljs-number">3</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(targetObject, &#123;<br>   <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property</span>) &#123;<br>       <span class="hljs-keyword">if</span>(hiddenProperties.<span class="hljs-title function_">includes</span>(property)) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>       &#125;<br>   &#125;,<br><br>   <span class="hljs-title function_">has</span>(<span class="hljs-params">target, property</span>) &#123;<br>       <span class="hljs-keyword">if</span>(hiddenProperties.<span class="hljs-title function_">includes</span>(property)) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>       <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(...<span class="hljs-variable language_">arguments</span>);<br>       &#125;<br>   &#125;<br>&#125;);<br><br><span class="hljs-comment">// 调用 get() 代理</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">bar</span>);  <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">baz</span>);  <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 调用 has() 代理</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span> <span class="hljs-keyword">in</span> proxy);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span> <span class="hljs-keyword">in</span> proxy);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;baz&#x27;</span> <span class="hljs-keyword">in</span> proxy);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="属性验证"><a href="#属性验证" class="headerlink" title="属性验证"></a>属性验证</h2><p>所有赋值操作都会触发 <code>set()</code> 捕获器，可以根据所赋的值决定允许还是拒绝赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">onlyNumbersGoHere</span>: <span class="hljs-number">0</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value</span>) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br><br>proxy.<span class="hljs-property">onlyNumbersGoere</span> = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">onlyNumbersGoere</span>);  <span class="hljs-comment">// 1</span><br><br>proxy.<span class="hljs-property">onlyNumbersGoere</span> = <span class="hljs-string">&#x27;2&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">onlyNumbersGoere</span>);  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h2 id="函数与构造函数参数验证"><a href="#函数与构造函数参数验证" class="headerlink" title="函数与构造函数参数验证"></a>函数与构造函数参数验证</h2><p>可以审查函数和构造函数参数，让函数只接收某种类型的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">median</span>(<span class="hljs-params">...nums</span>) &#123;<br>    <span class="hljs-keyword">return</span> nums.<span class="hljs-title function_">sort</span>()[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(nums.<span class="hljs-property">length</span> / <span class="hljs-number">2</span>)];<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(median, &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        target: 目标对象</span><br><span class="hljs-comment">        thisArg: 调用函数时的 this 参数</span><br><span class="hljs-comment">        argumentsList: 调用函数时的参数列表</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, argumentsList</span>) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">const</span> arg <span class="hljs-keyword">of</span> argumentsList) &#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> arg !== <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Non-number argument provided&#x27;</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>));  <span class="hljs-comment">// 4</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">proxy</span>(<span class="hljs-number">4</span>, <span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-number">1</span>));  <span class="hljs-comment">// Non-number argument provided</span><br></code></pre></td></tr></table></figure><p>可以要求实例化时必须给构造函数传参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">id_</span> = id;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">User</span>, &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        target: 目标构造函数</span><br><span class="hljs-comment">        argumentsList: 传给目标构造函数的参数列表</span><br><span class="hljs-comment">        newTarget: 最初被调用的构造函数</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, argumentsList, newTarget</span>) &#123;<br>        <span class="hljs-keyword">if</span>(argumentsList[<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;User cannot be instantiated without id&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(...<span class="hljs-variable language_">arguments</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>();  <span class="hljs-comment">// User cannot be instantiated without id</span><br></code></pre></td></tr></table></figure><h2 id="数据绑定与可观察对象"><a href="#数据绑定与可观察对象" class="headerlink" title="数据绑定与可观察对象"></a>数据绑定与可观察对象</h2><p>通过代理可以联系运行时原本不相关的部分，实现各种模式，让不同的代码互操作</p><p>比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> userList = [];<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span> = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">User</span>, &#123;<br>    <span class="hljs-title function_">construct</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> newUser = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(...<span class="hljs-variable language_">arguments</span>);<br>        userList.<span class="hljs-title function_">push</span>(newUser);<br><br>        <span class="hljs-keyword">return</span> newUser;<br>    &#125;<br>&#125;);<br><br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;Jacob&#x27;</span>);<br><span class="hljs-keyword">new</span> <span class="hljs-title function_">proxy</span>(<span class="hljs-string">&#x27;Jingleheimerschmidt&#x27;</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">[</span><br><span class="hljs-comment">  User &#123; name_: &#x27;John&#x27; &#125;,</span><br><span class="hljs-comment">  User &#123; name_: &#x27;Jacob&#x27; &#125;,</span><br><span class="hljs-comment">  User &#123; name_: &#x27;Jingleheimerschmidt&#x27; &#125;</span><br><span class="hljs-comment">]</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(userList);<br></code></pre></td></tr></table></figure><p>也可以把集合绑定到一个事件分派程序，每次插入新实例都会发送消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> userList = [];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">emit</span>(<span class="hljs-params">newValue</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newValue);<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(userList, &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        set拦截器对所有属性设置操作都会响应，包括length属性的更新</span><br><span class="hljs-comment">        每次push会触发两次emit调用：</span><br><span class="hljs-comment">            一次是新元素被添加时（输出 &#x27;John&#x27; 和 &#x27;Jacob&#x27;）</span><br><span class="hljs-comment">            一次是数组长度被更新时（输出 1 和 2）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        target: 目标对象</span><br><span class="hljs-comment">        property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">        value: 要赋给属性的值</span><br><span class="hljs-comment">        receiver: 接收最初赋值的对象</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123;<br>        <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);<br>        <span class="hljs-keyword">if</span>(result) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">                target: 目标对象</span><br><span class="hljs-comment">                property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">                receiver: 代理对象或继承代理对象的对象</span><br><span class="hljs-comment">            */</span><br>            <span class="hljs-title function_">emit</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, property, receiver));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// push 是数组的方法，在添加元素后，会返回数组的新长度</span><br><span class="hljs-comment">// John</span><br><span class="hljs-comment">// 1</span><br>proxy.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br><span class="hljs-comment">// Jacob</span><br><span class="hljs-comment">// 2</span><br>proxy.<span class="hljs-title function_">push</span>(<span class="hljs-string">&#x27;Jacob&#x27;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-代理捕获器与反射方法</title>
    <link href="/2025/10/30/JavaScript-%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%90%86%E6%8D%95%E8%8E%B7%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95/"/>
    <url>/2025/10/30/JavaScript-%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%90%86%E6%8D%95%E8%8E%B7%E5%99%A8%E4%B8%8E%E5%8F%8D%E5%B0%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在代理对象上执行的任何一种操作，<mark>只会调用一个捕获处理程序</mark>，不存在重复捕获。</p><p>只要在代理上调用，所有捕获器都会拦截它们对应的反射 <code>API</code> 操作。</p><h2 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h2><p>获取属性值的操作会调用 <code>get()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.get()</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">receiver: 代理对象或继承代理对象的对象</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, property, receiver</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br>proxy.<span class="hljs-property">foo</span>;  <span class="hljs-comment">// get()</span><br></code></pre></td></tr></table></figure><p><code>get()</code> 捕获器无返回值限制，会拦截 <code>proxy.property</code>、<code>proxy[property]</code>、<code>Object.create(proxy)[property]</code> 和 <code>Reflect.get(proxy, property, receiver)</code> 操作。</p><p>如果：</p><ul><li><p><code>target.property</code> <strong>不可写且不可配置</strong>，处理程序返回的值必须与 <code>target.property</code> 匹配</p></li><li><p><code>target.property</code> <strong>不可配置</strong>且 <code>[[Get]]</code> 为 <code>undefined</code>，处理程序的返回值也必须是 <code>undefined</code></p></li></ul><h2 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h2><p>设置属性值的操作会调用 <code>set()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.set()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">value: 要赋给属性的值</span><br><span class="hljs-comment">receiver: 接收最初赋值的对象</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, property, value, receiver</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;set()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br>proxy.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;bar&#x27;</span>;  <span class="hljs-comment">// set()</span><br></code></pre></td></tr></table></figure><p><code>set()</code> 捕获器返回 <code>true</code> 表示成功；返回 <code>false</code> 表示失败，严格模式会抛出 <code>TypeError</code>。会拦截 <code>proxy.property = value</code>、<code>proxy[property] = value</code>、<code>Object.create(proxy)[property] = value</code> 和 <code>Reflect.set(proxy, property, value, receiver)</code> 操作。</p><p>如果：</p><ul><li><p><code>target.property</code> <mark>不可写且不可配置</mark>，则不能修改目标属性的值</p></li><li><p><code>target.property</code> <mark>不可配置且 <code>[[Set]]</code> 特性为 <code>undefined</code></mark>，则不能修改目标属性的值</p></li></ul><h2 id="has"><a href="#has" class="headerlink" title="has()"></a>has()</h2><p>在 <code>in</code> 操作符中会调用 <code>has()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.has()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">has</span>(<span class="hljs-params">target, property</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;has()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-string">&#x27;foo&#x27;</span> <span class="hljs-keyword">in</span> proxy;  <span class="hljs-comment">// has()</span><br></code></pre></td></tr></table></figure><p><code>has()</code> 必须返回表示属性是否存在的布尔值，返回非布尔值会转为布尔值。会拦截 <code>property in proxy</code>、<code>property in Object.create(proxy)</code>、<code>with(proxy) {(property);}</code> 和 <code>Reflect.has(proxy, property)</code> 操作。</p><p>如果：</p><ul><li><p><code>target.property</code> <mark>存在且不可配置</mark>，处理程序必须返回 <code>true</code></p></li><li><p><code>target.property</code> <mark>存在且目标对象不可扩展</mark>，处理程序必须返回 <code>true</code></p></li></ul><h2 id="defineProperty"><a href="#defineProperty" class="headerlink" title="defineProperty()"></a>defineProperty()</h2><p>在 <code>Object.defineProperty()</code> 中会调用 <code>defineProperty()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.defineProperty()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">descriptor: 包含可选的 enumerable、configurable、writable、value、get 和 set 定义的对象</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">defineProperty</span>(<span class="hljs-params">target, property, descriptor</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;defineProperty()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// defineProperty()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(proxy, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;bar&#x27;</span> &#125;);<br></code></pre></td></tr></table></figure><p><code>defineProperty()</code> 必须返回表示属性是否存在的布尔值，返回非布尔值会转为布尔值。会拦截 <code>Object.defineProperty(proxy, property, descriptor)</code> 和 <code>Reflect.defineProperty(proxy, property, descriptor)</code> 操作。</p><p>如果：</p><ul><li><p>目标对象<mark>不可扩展</mark>，无法定义属性</p></li><li><p>目标对象有一个<mark>可配置的属性</mark>，不能添加同名的不可配置属性</p></li><li><p>目标对象有一个<mark>不可配置的属性</mark>，不能添加同名的可配置属性</p></li></ul><h2 id="getOwnPropertyDescriptor"><a href="#getOwnPropertyDescriptor" class="headerlink" title="getOwnPropertyDescriptor()"></a>getOwnPropertyDescriptor()</h2><p>在 <code>Object.getOwnPropertyDescriptor()</code> 中会调用 <code>getOwnPropertyDescriptor()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.getOwnPropertyDescriptor()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">getOwnPropertyDescriptor</span>(<span class="hljs-params">target, property</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;getOwnPropertyDescriptor()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// getOwnPropertyDescriptor()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(proxy, <span class="hljs-string">&#x27;foo&#x27;</span>);<br></code></pre></td></tr></table></figure><p><code>getOwnPropertyDescriptor()</code> <mark>必须返回对象</mark>，在属性不存在时返回 <code>undefined</code>。会拦截 <code>Object.getOwnPropertyDescriptor(proxy, property)</code> 和 <code>Reflect.getOwnPropertyDescriptor(proxy, property)</code> 操作。</p><p>如果：</p><ul><li><p><code>target.property</code> <mark>存在且不可配置</mark>，必须返回一个表示该属性存在的对象</p></li><li><p><code>target.property</code> <mark>存在且可配置</mark>，必须返回表示该属性可配置的对象</p></li><li><p><code>target.property</code> <mark>存在且 <code>target</code> 不可扩展</mark>，必须返回一个表示该属性存在的对象</p></li><li><p><code>target.property</code> <mark>不存在且 <code>target</code> 不可扩展</mark>，必须返回 <code>undefined</code> 表示该属性不存在</p></li><li><p><code>target.property</code> <mark>不存在</mark>，不能返回表示该属性可配置的对象</p></li></ul><h2 id="deleteProperty"><a href="#deleteProperty" class="headerlink" title="deleteProperty()"></a>deleteProperty()</h2><p>在 <code>delete</code> 操作符中会调用 <code>deleteProperty()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.deleteProperty()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">property: 引用的目标对象上的字符串键属性</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, property</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;deleteProperty()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// deleteProperty()</span><br><span class="hljs-keyword">delete</span> proxy.<span class="hljs-property">foo</span>;<br></code></pre></td></tr></table></figure><p><code>deleteProperty()</code> 必须返回表示属性是否存在的布尔值，返回非布尔值会转为布尔值。会拦截 <code>delete proxy.property</code>、<code>delete proxy[property]</code> 和 <code>Reflect.deleteProperty(proxy, property)</code> 操作。</p><ul><li>如果 <code>target.property</code> <mark>存在且不可配置</mark>，不能删除这个属性</li></ul><h2 id="ownKeys"><a href="#ownKeys" class="headerlink" title="ownKeys()"></a>ownKeys()</h2><p>在 <code>Object.keys()</code> 及类似方法中会调用 <code>ownKeys()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.ownKeys()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">ownKeys</span>(<span class="hljs-params">target</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ownKeys()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// ownKeys()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(proxy);<br></code></pre></td></tr></table></figure><p><code>ownKeys()</code> 必须返回包含字符串或符号的可枚举对象。会拦截 <code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code> 和 <code>Reflect.ownKeys(proxy)</code> 操作。</p><ul><li><p>必须返回包含 <code>target</code> 所有不可配置的自有属性的可枚举对象</p></li><li><p>如果 <code>target</code> 不可扩展，返回可枚举对象必须准确包含自有属性键</p></li></ul><h2 id="getPrototypeOf"><a href="#getPrototypeOf" class="headerlink" title="getPrototypeOf()"></a>getPrototypeOf()</h2><p>在 <code>Object.getPrototypeOf()</code> 中会调用 <code>getPrototypeOf()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.getPrototypeOf()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">getPrototypeOf</span>(<span class="hljs-params">target</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;getPrototypeOf()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">getPrototypeOf</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// getPrototypeOf()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(proxy);<br></code></pre></td></tr></table></figure><p><code>getPrototypeOf()</code> 必须返回对象或 <code>null</code>。会拦截 <code>Object.getPrototypeOf(proxy)</code>、<code>Reflect.getPrototypeOf(proxy)</code>、<code>proxy.__proto__</code>、<code>Object.prototype.isPrototypeOf(proxy)</code> 和 <code>proxy instanceof Object</code> 操作。</p><ul><li>如果 <code>target</code> 不可扩展，<code>Object.getPrototypeOf(proxy)</code> 唯一有效的返回值就是 <code>Object.getPrototypeOf(target)</code> 的返回值</li></ul><h2 id="setPrototypeOf"><a href="#setPrototypeOf" class="headerlink" title="setPrototypeOf()"></a>setPrototypeOf()</h2><p>在 <code>Object.setPrototypeOf()</code> 中会调用 <code>setPrototypeOf()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.setPrototypeOf()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">prototype: target 的替代原型，如果是顶级原型则为 null</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">setPrototypeOf</span>(<span class="hljs-params">target, prototype</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;setPrototypeOf()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">setPrototypeOf</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// setPrototypeOf()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(proxy, <span class="hljs-title class_">Object</span>);<br></code></pre></td></tr></table></figure><p><code>getPrototypeOf()</code> 必须返回表示原型赋值是否成功的布尔值，返回非布尔值会转为布尔值。会拦截 <code>Object.setPrototypeOf(proxy)</code> 和 <code>Reflect.setPrototypeOf(proxy)</code> 操作。</p><ul><li>如果 <code>target</code> 不可扩展，<code>Object.setPrototypeOf()</code> 唯一有效的 <code>prototype</code> 参数就是 <code>Object.getPrototypeOf(target)</code> 的返回值</li></ul><h2 id="isExtensible"><a href="#isExtensible" class="headerlink" title="isExtensible()"></a>isExtensible()</h2><p>在 <code>Object.isExtensible()</code> 中会调用 <code>isExtensible()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.isExtensible()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">isExtensible</span>(<span class="hljs-params">target</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;isExtensible()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">isExtensible</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// isExtensible()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isExtensible</span>(proxy);<br></code></pre></td></tr></table></figure><p><code>getPrototypeOf()</code> 必须返回表示 <code>target</code> 是否可扩展的布尔值，返回非布尔值会转为布尔值。会拦截 <code>Object.isExtensible(proxy)</code> 和 <code>Reflect.isExtensible(proxy)</code> 操作。</p><p>如果：</p><ul><li><p><code>target</code> 可扩展，必须返回 <code>true</code></p></li><li><p><code>target</code> 不可扩展，必须返回 <code>false</code></p></li></ul><h2 id="preventExtensions"><a href="#preventExtensions" class="headerlink" title="preventExtensions()"></a>preventExtensions()</h2><p>在 <code>Object.preventExtensions()</code> 中会调用 <code>preventExtensions()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.preventExtensions()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">preventExtensions</span>(<span class="hljs-params">target</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;preventExtensions()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">preventExtensions</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// preventExtensions()</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">preventExtensions</span>(proxy);<br></code></pre></td></tr></table></figure><p><code>preventExtensions()</code> 必须返回表示 <code>target</code> 是否已不可扩展的布尔值，返回非布尔值会转为布尔值。会拦截 <code>Object.preventExtensions(proxy)</code> 和 <code>Reflect.preventExtensions(proxy)</code> 操作。</p><ul><li>如果 <code>Object.isExtensible(proxy)</code> 是 <code>false</code>，必须返回 <code>true</code></li></ul><h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h2><p>在调用函数时会调用 <code>apply()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.apply()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">myTarget</span> = (<span class="hljs-params"></span>) =&gt; &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标对象</span><br><span class="hljs-comment">thisArg: 调用函数时的 this 参数</span><br><span class="hljs-comment">argumentsList: 调用函数时的参数列表</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, ...argumentsList</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;apply()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// apply()</span><br><span class="hljs-title function_">proxy</span>();<br></code></pre></td></tr></table></figure><p><code>apply()</code> 返回值无限制。会拦截 <code>proxy(...argumentsList)</code>、<code>Function.prototype.apply(thisArg, argumentsList)</code>、<code>Function.prototype.call(thisArg, ...argumentsList)</code> 和 <code>Reflect.apply(target, thisArgument, argumentsList)</code> 操作。</p><ul><li><code>target</code> 必须是一个函数对象</li></ul><h2 id="construt"><a href="#construt" class="headerlink" title="construt()"></a>construt()</h2><p>在 <code>new</code> 操作符中会调用 <code>construt()</code> 捕获器，对应反射 <code>API</code> 方法 <code>Reflect.construt()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myTarget = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(myTarget, &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">target: 目标构造函数</span><br><span class="hljs-comment">argumentsList: 传给目标构造函数的参数列表</span><br><span class="hljs-comment">newTarget: 最初被调用的构造函数</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-title function_">construct</span>(<span class="hljs-params">target, argumentsList, newTarget</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;construct()&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">construct</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// construct()</span><br><span class="hljs-keyword">new</span> proxy;<br></code></pre></td></tr></table></figure><p><code>construct()</code> 必须返回一个对象。会拦截 <code>new proxy(...argumentsList)</code> 和 <code>Reflect.construct(target, argumentsList, newTarget)</code> 操作。</p><ul><li><code>target</code> 必须可用作构造函数</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-代理基础</title>
    <link href="/2025/10/29/JavaScript-%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%90%86%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/10/29/JavaScript-%E7%AC%94%E8%AE%B0-%E4%BB%A3%E7%90%86%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><mark>代理是目标对象的抽象。</mark>目标对象既可以直接被操作，也可以通过代理来操作。但直接操作会绕过代理。</p><p>使用 <code>Proxy</code> 构造函数创建代理，该函数接收<strong>目标对象</strong>和<strong>处理程序对象</strong>作为参数。</p><h2 id="创建空代理"><a href="#创建空代理" class="headerlink" title="创建空代理"></a>创建空代理</h2><p>空代理除了作为一个抽象的目标对象，什么也不做。在任何可以使用目标对象的地方，都可以通过同样的方式来使用与之关联的代理对象。</p><p>可以向 <code>Proxy</code> 构造函数传递一个简单的对象字面量作为处理程序对象，来创建空代理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;target&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> handler = &#123;&#125;;<br><br><span class="hljs-comment">// 使用 Proxy 构造函数创建代理</span><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-comment">// id 属性会访问同一个值</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">id</span>);  <span class="hljs-comment">// target</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">id</span>);  <span class="hljs-comment">// target</span><br><br><span class="hljs-comment">// 给目标属性赋值会反映在两个对象上</span><br>target.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">id</span>);  <span class="hljs-comment">// foo</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">id</span>);  <span class="hljs-comment">// foo</span><br><br><span class="hljs-comment">// 在代理对象上执行的任何操作都会应用到目标对象</span><br>proxy.<span class="hljs-property">id</span> = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">id</span>);  <span class="hljs-comment">// bar</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">id</span>);  <span class="hljs-comment">// bar</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;id&#x27;</span>));  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&#x27;id&#x27;</span>));  <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// Proxy.prototype 是 undefined，不能使用 instanceof 操作符</span><br><span class="hljs-comment">// TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Proxy</span>);<br><span class="hljs-comment">// TypeError: Function has non-object prototype &#x27;undefined&#x27; in instanceof check</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Proxy</span>);<br><br><span class="hljs-comment">// 使用严格相等区分代理和目标</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target === proxy);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h2 id="定义捕获器"><a href="#定义捕获器" class="headerlink" title="定义捕获器"></a>定义捕获器</h2><ul><li><p>使用代理的主要目的是定义<strong>捕获器（trap）</strong></p></li><li><p>捕获器是在处理程序对象中定义的“基本操作的拦截器”</p></li><li><p>每个处理程序对象可以包含<strong>零个或多个捕获器</strong>，每个捕获器都对应一种基本操作，代理对象可以<strong>直接或间接调用</strong></p></li><li><p>代理可以在基本操作传播到目标对象之前先调用捕获器函数，<mark>拦截并修改相应的行为</mark></p></li></ul><blockquote><p>捕获器在操作系统中是程序流的一个同步中断，可以暂停程序流，转而执行一段子例程，再返回原始程序流</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 定义一个 get() 捕获器</span><br><span class="hljs-comment">// 在 ECMAScript 以某种形式调用 get() 时触发</span><br><span class="hljs-keyword">const</span> handler = &#123;<br><span class="hljs-comment">// 捕获器在处理程序对象中以方法名为键</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;handler override&#x27;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">    只有通过 代理对象 执行 get() 操作时</span><br><span class="hljs-comment">    才会触发定义的 get() 捕获器</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    只有在 代理对象 上执行</span><br><span class="hljs-comment">    proxy[property]、proxy.property 或 Object.create(proxy)[property]</span><br><span class="hljs-comment">    等操作才会触发基本的 get() 操作以获取属性</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// handler override</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target[<span class="hljs-string">&#x27;foo&#x27;</span>]);  <span class="hljs-comment">// bar </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy[<span class="hljs-string">&#x27;foo&#x27;</span>]);  <span class="hljs-comment">// handler override</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(target)[<span class="hljs-string">&#x27;foo&#x27;</span>]);  <span class="hljs-comment">// bar</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(proxy)[<span class="hljs-string">&#x27;foo&#x27;</span>]);  <span class="hljs-comment">// handler override</span><br></code></pre></td></tr></table></figure><h2 id="捕获器参数和反射-API"><a href="#捕获器参数和反射-API" class="headerlink" title="捕获器参数和反射 API"></a>捕获器参数和反射 API</h2><p>所有捕获器都可以访问相应的参数，<code>get()</code> 捕获器能接收到<mark>目标对象、要查询的属性和代理对象。</mark></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    // 目标对象、要查询的属性和代理对象</span><br><span class="hljs-comment">    get(trapTarget, property, receiver) &#123;</span><br><span class="hljs-comment">        console.log(trapTarget === target);</span><br><span class="hljs-comment">        console.log(property);</span><br><span class="hljs-comment">        console.log(receiver === proxy);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 重写被捕获方法</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">trapTarget, property, receiver</span>) &#123;<br>        <span class="hljs-keyword">return</span> trapTarget[property];<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    true</span><br><span class="hljs-comment">    foo</span><br><span class="hljs-comment">    true</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// proxy.foo;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br></code></pre></td></tr></table></figure><ul><li><p>可以通过调用全局 <code>Reflect</code> 对象（封装了原始行为）的同名方法来重写函数。<code>Reflect</code> 是一个内置的对象，它提供了一组静态方法，用于执行各种与对象操作相关的通用功能，动态地检查或修改对象的结构和行为。</p></li><li><p>处理程序对象中所有可捕获的方法都有与捕获器拦截的方法相同的名称和函数签名，而且有和被拦截方法相同行为的相应的反射（<code>Reflect</code>）<code>API</code> 方法。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 使用反射 API 定义空代理对象</span><br><span class="hljs-keyword">const</span> handler = &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    get() &#123;</span><br><span class="hljs-comment">        return Reflect.get(...arguments);</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-attr">get</span>: <span class="hljs-title class_">Reflect</span>.<span class="hljs-property">get</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br></code></pre></td></tr></table></figure><p>不需要定义处理程序对象就可以创建一个可以捕获所有方法，并将每个方法转发给对应反射 <code>API</code> 的空代理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, <span class="hljs-title class_">Reflect</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br></code></pre></td></tr></table></figure><p>可以在反射 <code>API</code> 样板代码的基础上用最少的代码修改捕获的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    <span class="hljs-attr">baz</span>: <span class="hljs-string">&#x27;qux&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">trapTarget, property, receiver</span>) &#123;<br>        <span class="hljs-keyword">let</span> decoration = <span class="hljs-string">&#x27;&#x27;</span>;<br><br>        <span class="hljs-keyword">if</span>(property === <span class="hljs-string">&#x27;foo&#x27;</span>) &#123;<br>            decoration = <span class="hljs-string">&#x27;!!!&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>) + decoration;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, <span class="hljs-title class_">Reflect</span>);<br><br><span class="hljs-comment">// 只有通过代理执行时才会触发捕获器</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar!!!</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">baz</span>);  <span class="hljs-comment">// qux</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">baz</span>);  <span class="hljs-comment">// qux</span><br></code></pre></td></tr></table></figure><h2 id="捕获器的限制"><a href="#捕获器的限制" class="headerlink" title="捕获器的限制"></a>捕获器的限制</h2><p>每个捕获的方法都知道<mark>目标对象上下文、捕获函数签名</mark>，捕获处理程序的行为<mark>必须遵循</mark>“<strong>捕获器不变式</strong>”（trap invariant）。</p><p>如果目标对象有一个不可配置且不可写的数据属性，捕获器返回一个与该属性不同的值，会抛出 <code>TypeError</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(target, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,<br>    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;);<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;qux&#x27;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    TypeError: &#x27;get&#x27; on proxy: property &#x27;foo&#x27; is a read-only and non-configurable</span><br><span class="hljs-comment">    data property on the proxy target but the proxy did not return its actual</span><br><span class="hljs-comment">    value (expected &#x27;bar&#x27; but got &#x27;qux&#x27;)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);<br></code></pre></td></tr></table></figure><h2 id="撤销代理"><a href="#撤销代理" class="headerlink" title="撤销代理"></a>撤销代理</h2><p><code>Proxy</code> 的 <code>revocable()</code> 方法支持撤销代理对象与目标对象的关联，且操作不可逆。撤销代理后再调用代理会抛出 <code>TypeError</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;intercepted&#x27;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 在实例化时同时生成代理对象和撤销函数</span><br><span class="hljs-keyword">const</span> &#123; proxy, revoke &#125; = <span class="hljs-title class_">Proxy</span>.<span class="hljs-title function_">revocable</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// intercepted</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// bar</span><br><br><span class="hljs-comment">// 撤销代理</span><br><span class="hljs-title function_">revoke</span>();<br><br><span class="hljs-comment">// TypeError: Cannot perform &#x27;get&#x27; on a proxy that has been revoked</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">foo</span>);<br></code></pre></td></tr></table></figure><h2 id="反射-API"><a href="#反射-API" class="headerlink" title="反射 API"></a>反射 API</h2><p>以下是优先使用反射 <code>API</code> 的情况</p><h3 id="反射-API-与对象-API"><a href="#反射-API-与对象-API" class="headerlink" title="反射 API 与对象 API"></a>反射 API 与对象 API</h3><p><code>Object</code> 的方法适用于通用程序，反射方法适用于细粒度的对象控制与操作</p><ul><li><p>反射 <code>API</code> 并不限于捕获处理程序</p></li><li><p>大多数反射 <code>API</code> 方法在 <code>Object</code> 类型上有对应的方法</p></li></ul><h3 id="状态标记"><a href="#状态标记" class="headerlink" title="状态标记"></a>状态标记</h3><p>反射方法返回称作“<strong>状态标记</strong>”的布尔值，表示执行的操作是否成功</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o = &#123;&#125;;<br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(o, <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;failure&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 使用 Reflect.defineProperty() 重构上面的代码</span><br><span class="hljs-keyword">const</span> o = &#123;&#125;;<br><br><span class="hljs-comment">// 属性定义错误时，Reflect.defineProperty() 返回 false</span><br><span class="hljs-keyword">if</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">defineProperty</span>(o, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125;)) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;success&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;failure&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Reflect.defineProperty()</code>、<code>Reflect.preventExtensions()</code>、<code>Reflect.setPrototypeOf()</code>、<code>Reflect.set()</code> 和 <code>Reflect.deleteProperty()</code> 都会提供状态标记</p><h3 id="替代操作符"><a href="#替代操作符" class="headerlink" title="替代操作符"></a>替代操作符</h3><p><code>Reflect.get()</code>（可以替代对象属性访问操作符）、<code>Reflect.set()</code>（可以替代 <code>=</code> 赋值操作符）、<code>Reflect.has()</code>（可以替代 <code>in</code> 操作符或 <code>with()</code>）、<code>Reflect.deleteProperty()</code>（可以替代 <code>delete</code> 操作符）和 <code>Reflect.construct()</code>（可以替代 <code>new</code> 操作符）等反射方法<strong>提供只有通过操作符才能完成的操作</strong></p><h3 id="安全地使用函数"><a href="#安全地使用函数" class="headerlink" title="安全地使用函数"></a>安全地使用函数</h3><p>为了绕过使用 <code>apply</code> 方法调用函数时，被调函数也定义了 <code>apply</code> 属性的情况（直接使用 <code>对象.apply(...)</code> 调用函数时，会优先访问函数自身的 <code>apply</code> 属性），可使用定义在 <code>Function</code> 原型上的 <code>apply</code> 方法（强制使用 <code>JavaScript</code> 引擎内置的函数调用逻辑，无论被调函数是否有 <code>apply</code> 属性，都能保证正确执行目标函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">apply</span>.<span class="hljs-title function_">call</span>(myFunc, thisVal, argumentList);<br><br><span class="hljs-comment">// 避免被调函数也定义了 apply 属性</span><br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>(myFunc, thisVal, argumentList);<br></code></pre></td></tr></table></figure><h2 id="代理另一个代理"><a href="#代理另一个代理" class="headerlink" title="代理另一个代理"></a>代理另一个代理</h2><p>可以通过一个代理去代理另一个代理，在一个目标对象上构建多层拦截网</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> firstProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;first proxy&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-keyword">const</span> secondProxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(firstProxy, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;second proxy&#x27;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">second proxy</span><br><span class="hljs-comment">first proxy</span><br><span class="hljs-comment">bar</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(secondProxy.<span class="hljs-property">foo</span>);<br></code></pre></td></tr></table></figure><h2 id="代理的问题"><a href="#代理的问题" class="headerlink" title="代理的问题"></a>代理的问题</h2><p>代理作为对象的虚拟层可以正常使用，但某些情况下不能与现有的机制协同</p><h3 id="潜在问题来源-——-this-值"><a href="#潜在问题来源-——-this-值" class="headerlink" title="潜在问题来源 —— this 值"></a>潜在问题来源 —— this 值</h3><p>如果代理的目标对象依赖于<strong>对象标识</strong>（判断两个对象是否是同一个实例的机制，两个变量是否指向内存中的同一个对象），可能会碰到问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>    <span class="hljs-title function_">thisValEqualsProxy</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 方法中的 this 通常指向调用这个方法的对象</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span> === proxy;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 空代理</span><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(target.<span class="hljs-title function_">thisValEqualsProxy</span>());  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-title function_">thisValEqualsProxy</span>());  <span class="hljs-comment">// true</span><br><br><br><span class="hljs-keyword">const</span> wm = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><br><span class="hljs-comment">// 依赖 User 实例的对象标识</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">userId</span>) &#123;<br>        <span class="hljs-comment">// WeakMap 的键只能是对象，键的唯一性完全依赖对象标识</span><br>        wm.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, userId);<br>    &#125;<br><br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">id</span>(<span class="hljs-params">userId</span>) &#123;<br>        wm.<span class="hljs-title function_">set</span>(<span class="hljs-variable language_">this</span>, userId);<br>    &#125;<br><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">id</span>() &#123;<br>        <span class="hljs-keyword">return</span> wm.<span class="hljs-title function_">get</span>(<span class="hljs-variable language_">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">123</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(user.<span class="hljs-property">id</span>);  <span class="hljs-comment">// 123</span><br><br><span class="hljs-comment">// 代理对象尝试从自身获取该实例</span><br><span class="hljs-comment">// 代理对象 userInstanceProxy 从未作为键存入 WeakMap</span><br><span class="hljs-comment">// const userInstanceProxy = new Proxy(user, &#123;&#125;);</span><br><span class="hljs-comment">// console.log(userInstanceProxy.id);  // undefined</span><br><br><span class="hljs-comment">// 代理 User 类本身</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserClassProxy</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(<span class="hljs-title class_">User</span>, &#123;&#125;);<br><span class="hljs-comment">// 以代理实例作为 WeakMap 的键</span><br><span class="hljs-keyword">const</span> proxyUser = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserClassProxy</span>(<span class="hljs-number">456</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxyUser.<span class="hljs-property">id</span>);  <span class="hljs-comment">// 456</span><br></code></pre></td></tr></table></figure><h3 id="代理与内部槽位"><a href="#代理与内部槽位" class="headerlink" title="代理与内部槽位"></a>代理与内部槽位</h3><p>有些 <code>ECMAScript</code> 内置类型可能会依赖代理无法控制的机制，导致在代理上调用某些方法出错。</p><p>比如，<code>Date</code> 类型方法的执行依赖 <code>this</code> 值的内部槽位 <code>[[NumberDate]]</code>，但代理对象不存在该内部槽位，代理拦截后会抛出 <code>TypeError</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Date</span>);  <span class="hljs-comment">// true</span><br><br>proxy.<span class="hljs-title function_">getDate</span>();  <span class="hljs-comment">// TypeError: this is not a Date object</span><br></code></pre></td></tr></table></figure><blockquote><p>内部槽位是 <code>ECMA</code> 规范定义的、对象内部用于存储状态或特性的特殊“容器”，不是对象的属性，无法直接访问或修改。内部槽位仅在引擎层面存在，用于实现语言的核心功能</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript笔记-类</title>
    <link href="/2025/10/26/JavaScript%E7%AC%94%E8%AE%B0-%E7%B1%BB/"/>
    <url>/2025/10/26/JavaScript%E7%AC%94%E8%AE%B0-%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p><code>ECMAScript 6</code> 引入的 <code>class</code> 关键字具有正式定义类的能力，但<mark>实际上使用的仍然是原型和构造函数的概念</mark></p><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>有两种主要方式定义类：类声明和类表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 类声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><br><span class="hljs-comment">// 类表达式</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Animal</span> = <span class="hljs-keyword">class</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>函数表达式和类表达式在求值前都不能引用</p></li><li><p>类定义不能提升，但函数定义可以</p></li><li><p>函数受<strong>函数作用域</strong>限制，类受<strong>块作用域</strong>限制</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">FunctionDeclaration</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassDeclaration</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// [Function: FunctionDeclaration]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">FunctionDeclaration</span>);<br><span class="hljs-comment">// ReferenceError: ClassDeclaration is not defined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ClassDeclaration</span>);<br></code></pre></td></tr></table></figure><ul><li><p>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但<mark>都不是必须的</mark></p></li><li><p>空的类定义同样有效</p></li><li><p>默认情况下，类定义中的代码都在严格模式下执行</p></li><li><p><mark>类名的首字母大写</mark>，以区别于通过它创建的实例</p></li><li><p><mark>类表达式的名称是可选的</mark>。把类表达式赋值给变量后，可以<mark>通过 <code>name</code> 属性取得类表达式的名称字符串</mark>，但<mark>不能在类表达式作用域外访问该标识符</mark></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonName</span> &#123;<br>    <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">name</span>, <span class="hljs-title class_">PersonName</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>p.<span class="hljs-title function_">identify</span>();  <span class="hljs-comment">// PersonName PersonName</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// PersonName</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">PersonName</span>);  <span class="hljs-comment">// ReferenceError: PersonName is not defined</span><br></code></pre></td></tr></table></figure><h2 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h2><ul><li><p><code>constructor</code> 关键字用于在类定义块内部创建类的构造函数</p></li><li><p><code>constructor</code> 会告诉解释器在使用 <code>new</code> 操作符创建类的新实例时，调用该函数</p></li><li><p>不定义构造函数相当于将构造函数定义为<strong>空函数</strong></p></li></ul><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>使用 <code>new</code> 调用类的构造函数会执行<a href="../../22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">创建对象</a>的过程</p><p>类实例化时传入的参数会用作构造函数的参数</p><p>默认情况下，类构造函数会在执行后返回 <code>this</code> 对象，被用作实例化的对象</p><p>如果返回的不是 <code>this</code> 对象，而是其他对象，对这个对象使用 <code>instanceof</code> 操作符返回结果为 <code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">override</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><br>        <span class="hljs-keyword">if</span>(override) &#123;<br>            <span class="hljs-comment">// 返回的不是 this 对象</span><br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>            &#125;;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(),<br>    <span class="hljs-comment">// 未返回 this 对象，p2 的原型指针没有被修改</span><br>    p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);  <span class="hljs-comment">// Person &#123; foo: &#x27;foo&#x27; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> p1);  <span class="hljs-comment">// object</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);  <span class="hljs-comment">// &#123; bar: &#x27;bar&#x27; &#125;</span><br><span class="hljs-comment">// 无法通过 instanceof 操作符检测出跟类有关联</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> p2);  <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><p>调用类构造函数必须使用 <code>new</code> 操作符，不使用 <code>new</code> 会抛出错误</p><p>普通构造函数如果不使用 <code>new</code> 调用，就会以全局的 <code>this</code>（通常是 <code>window</code>）作为内部对象</p><p>实例化后，类构造函数会成为普通的实例方法（仍需使用 <code>new</code> 调用），可以在实例上引用它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-comment">// TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;</span><br><span class="hljs-comment">// p1.constructor();</span><br><br><span class="hljs-comment">// 使用类构造函数的引用创建一个新实例</span><br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> p1.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>);<br></code></pre></td></tr></table></figure><h3 id="把类当成特殊函数"><a href="#把类当成特殊函数" class="headerlink" title="把类当成特殊函数"></a>把类当成特殊函数</h3><p><code>ECMAScript</code> 类是一种特殊的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// [class Person]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// function</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-comment">// 类标识符的 prototype 属性有一个 constructor 属性指向类自身</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>类中定义的 <code>constructor</code> 方法<strong>不会</strong>被当成构造函数，对它使用 <code>instanceof</code> 操作符返回 <code>false</code>。如果在创建实例时直接<mark>将类构造函数当成普通构造函数</mark>，<code>instanceof</code> 操作符的返回值会<strong>反转</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>.<span class="hljs-property">constructor</span>);  <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 直接将类构造函数当成普通构造函数使用</span><br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>.<span class="hljs-property">constructor</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>类可以像其他对象或函数引用一样作为参数传递</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 类可以像函数一样在任何地方定义，比如数组中</span><br><span class="hljs-keyword">let</span> classList = [<br>    <span class="hljs-keyword">class</span> &#123;<br>        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">id_</span> = id;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`instance <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.id_&#125;</span>`</span>);<br>        &#125;<br>    &#125;<br>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createInstance</span>(<span class="hljs-params">classDefinition, id</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">classDefinition</span>(id);<br>&#125;<br><br><span class="hljs-comment">// classList[0] 是作为参数传递的类</span><br><span class="hljs-keyword">let</span> foo = <span class="hljs-title function_">createInstance</span>(classList[<span class="hljs-number">0</span>], <span class="hljs-number">3141</span>);  <span class="hljs-comment">// instance 3141</span><br></code></pre></td></tr></table></figure><p>类可以像立即调用函数表达式一样立即实例化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 类表达式的类名是可选的</span><br><span class="hljs-comment">// let p = new class Foo &#123;</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">class</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>    &#125;<br>&#125;(<span class="hljs-string">&#x27;bar&#x27;</span>);  <span class="hljs-comment">// bar</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);  <span class="hljs-comment">// Foo &#123;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在构造函数内部，可以为新创建的实例（<code>this</code>）添加“自有”属性。构造函数执行完也可以给实例继续添加新成员</p><p><mark>每个实例都对应一个唯一的成员对象，所有成员都不会在原型上共享</mark></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 为新创建的实例(this)添加&quot;自有&quot;属性</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            箭头函数，调用时会打印 this.name</span><br><span class="hljs-comment">            箭头函数没有自己的 this，它的 this 继承自定义时所在的上下文（即构造函数执行时的 this）</span><br><span class="hljs-comment">            箭头函数的 this 始终绑定创建时的实例，而普通函数的 this 会随调用方式变化</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">nicknames</span> = [<span class="hljs-string">&#x27;Jake&#x27;</span>, <span class="hljs-string">&#x27;J-Dog&#x27;</span>]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 每个实例都对应一个唯一的成员对象，所有成员都不会在原型上共享</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(),<br>    p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>p1.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// [String: &#x27;Jack&#x27;]</span><br>p2.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// [String: &#x27;Jack&#x27;]</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span> === p2.<span class="hljs-property">name</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">sayName</span> === p2.<span class="hljs-property">sayName</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">nicknames</span> === p2.<span class="hljs-property">nicknames</span>);  <span class="hljs-comment">// false</span><br><br>p1.<span class="hljs-property">name</span> = p1.<span class="hljs-property">nicknames</span>[<span class="hljs-number">0</span>];<br>p2.<span class="hljs-property">name</span> = p2.<span class="hljs-property">nicknames</span>[<span class="hljs-number">1</span>];<br><br>p1.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Jake</span><br>p2.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// J-Dog</span><br></code></pre></td></tr></table></figure><h3 id="原型方法与访问器"><a href="#原型方法与访问器" class="headerlink" title="原型方法与访问器"></a>原型方法与访问器</h3><ul><li><p>类体内直接声明的方法会自动绑定到原型对象上，无需手动操作 prototype</p></li><li><p>可以把<strong>方法</strong>定义在类构造函数或类块中，不能在类块中给原型添加<strong>原始值或对象</strong>作为成员数据</p></li><li><p>可以使用字符串、符号或计算的值作为类方法的键</p></li><li><p>类定义支持获取和设置访问器</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> symbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;symbolKey&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-comment">// 不能在类块中给原型添加原始值或对象作为成员数据</span><br><span class="hljs-comment">// name: &#x27;Jake&#x27;  // SyntaxError: Unexpected identifier &#x27;name&#x27;</span><br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 添加到 this 的所有内容会存在于不同的实例</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">locate</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;instance&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在类块中定义的所有内容都会定义在类的原型上</span><br>    <span class="hljs-title function_">locate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;prototype&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">stringKey</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;invoked stringKey&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 使用符号作为键</span><br>    [symbolKey]() &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;invoked symbolKey&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 使用计算的值作为键</span><br>    [<span class="hljs-string">&#x27;computed&#x27;</span> + <span class="hljs-string">&#x27;Key&#x27;</span>]() &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;invoked computedKey&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置访问器</span><br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">newName</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span> = newName;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取访问器</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>p.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// instance</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// prototype</span><br><br>p.<span class="hljs-title function_">stringKey</span>();  <span class="hljs-comment">// invoked stringKey</span><br>p[symbolKey]();  <span class="hljs-comment">// invoked symbolKey</span><br>p.<span class="hljs-title function_">computedKey</span>();  <span class="hljs-comment">// invoked computedKey</span><br><br>p.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jake&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Jake</span><br></code></pre></td></tr></table></figure><h3 id="静态类方法"><a href="#静态类方法" class="headerlink" title="静态类方法"></a>静态类方法</h3><p>静态方法通常用于执行不特定于实例的操作，也不要求存在类的实例，<strong>每个类只能有一个静态成员</strong>（类级别的属性）</p><p>静态类成员在类定义中使用 <code>static</code> 关键字作为前缀，使用 <code>this</code> 引用类自身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 添加到 this 的所有内容都会存在于不同的实例上</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">locate</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;instance&#x27;</span>, <span class="hljs-variable language_">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义在类的原型对象上</span><br>    <span class="hljs-title function_">locate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;prototype&#x27;</span>, <span class="hljs-variable language_">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义在类本身上</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">locate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-variable language_">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>p.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// instance Person &#123; locate: [Function (anonymous)] &#125;</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// prototype &#123;&#125;</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// class [class Person]</span><br></code></pre></td></tr></table></figure><p>静态类方法适合作为实例工厂</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">age</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age_</span> = age;<br>    &#125;<br><br>    <span class="hljs-comment">// sayAge() 没有 return 语句，默认返回 undefined</span><br>    <span class="hljs-comment">// 类实例调用 sayAge() 时会先打印年龄，再打印返回的年龄值</span><br>    <span class="hljs-title function_">sayAge</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age_</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义在类本身上</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 使用随机年龄创建并返回一个 Person 实例</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()*<span class="hljs-number">100</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Person &#123; age_: 83 &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-title function_">create</span>());<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">29</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    29</span><br><span class="hljs-comment">    undefined</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">sayAge</span>());<br></code></pre></td></tr></table></figure><h3 id="非函数原型和类成员"><a href="#非函数原型和类成员" class="headerlink" title="非函数原型和类成员"></a>非函数原型和类成员</h3><p><code>ECMAScript 2022</code> 允许直接在类体中定义数据成员，无需在 <code>constructor</code> 中定义</p><p>在类定义外部，可以在原型或类上手动添加成员数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// ES2022 允许直接在类体中定义数据成员，无需在 constructor 中定义</span><br>    age = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-comment">// 在构造函数中通过 this 定义数据成员</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-comment">// this.age = age;</span><br>    &#125;<br><br>    <span class="hljs-title function_">sayJob</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;Person.greeting&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.job&#125;</span>`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Alice</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">age</span>);  <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// 在类定义外部手动添加成员数据</span><br><span class="hljs-comment">// 在类上定义数据成员</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property">greeting</span> = <span class="hljs-string">&#x27;My job is&#x27;</span>;<br><span class="hljs-comment">// 在原型上定义数据成员</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&#x27;Software Engineer&#x27;</span>;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Jake&#x27;</span>);<br>p1.<span class="hljs-title function_">sayJob</span>();  <span class="hljs-comment">// My job is Software Engineer</span><br></code></pre></td></tr></table></figure><h3 id="迭代器与生成器方法"><a href="#迭代器与生成器方法" class="headerlink" title="迭代器与生成器方法"></a>迭代器与生成器方法</h3><p>类定义语法支持在原型和类本身上定义生成器方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">nicknames</span> = [<span class="hljs-string">&#x27;cJack&#x27;</span>, <span class="hljs-string">&#x27;cJake&#x27;</span>, <span class="hljs-string">&#x27;cJ-Dog&#x27;</span>];<br>    &#125;<br><br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    添加一个默认的迭代器，把类实例变成可迭代对象</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    方法名前的 * 表示这是一个 生成器函数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    [Symbol.iterator] 是一个特殊的 内置 Symbol 属性，当一个对象定义了该方法时，就表示它是 “可迭代的”</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    yield* 是 Generator 函数中的语法，用于 “委托” 另一个可迭代对象的迭代过程。它会自动遍历被委托的对象，并逐个返回其迭代结果</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    *[Symbol.iterator]() &#123;</span><br><span class="hljs-comment">        yield *this.nicknames.entries();</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    entries() 方法会返回一个数组迭代器对象，用于遍历其 “键值对”</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 只返回迭代器实例效果与返回可迭代对象相同</span><br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">nicknames</span>.<span class="hljs-title function_">entries</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 在原型上定义生成器方法</span><br>    *<span class="hljs-title function_">creatNicknameIterator</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Jack&#x27;</span>;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Jake&#x27;</span>;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;J-Dog&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 在类上定义生成器方法</span><br>    <span class="hljs-keyword">static</span> *<span class="hljs-title function_">createJobIterator</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Butcher&#x27;</span>;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Baker&#x27;</span>;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Candlestick maker&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> jobIter = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">createJobIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jobIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Butcher</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jobIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Baker</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jobIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Candlestick maker</span><br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">let</span> nicknameIter = p.<span class="hljs-title function_">creatNicknameIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nicknameIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Jack</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nicknameIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Jake</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nicknameIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// J-Dog</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [idx, nickname] <span class="hljs-keyword">of</span> p) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        cJack</span><br><span class="hljs-comment">        cJake</span><br><span class="hljs-comment">        cJ-Dog</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nickname);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><code>ECMAScript 6</code> 原生支持类继承机制，但<mark>背后依旧使用原型链</mark></p><h3 id="继承基础"><a href="#继承基础" class="headerlink" title="继承基础"></a>继承基础</h3><p><code>ES6</code> 支持<strong>单继承</strong>。使用 <code>extends</code> 关键字，可以继承任何拥有 <strong><code>[[Construct]]</code></strong> 和<strong>原型</strong>的对象。不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-params">id</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id, <span class="hljs-variable language_">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">identifyClass</span>(<span class="hljs-params">id</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id, <span class="hljs-variable language_">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 继承类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;&#125;<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Bus</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Vehicle</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">let</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>();<br><br><span class="hljs-comment">// 派生类通过原型链访问类和原型上定义的方法</span><br>b.<span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-string">&#x27;bus&#x27;</span>);  <span class="hljs-comment">// bus, Bus &#123;&#125;</span><br>v.<span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>);  <span class="hljs-comment">// vehicle, Vehicle &#123;&#125;</span><br><br><span class="hljs-title class_">Bus</span>.<span class="hljs-title function_">identifyClass</span>(<span class="hljs-string">&#x27;bus&#x27;</span>);  <span class="hljs-comment">// bus [class Bus extends Vehicle]</span><br><span class="hljs-title class_">Vehicle</span>.<span class="hljs-title function_">identifyClass</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>);  <span class="hljs-comment">// vehicle [class Vehicle]</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engineer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;&#125;<br><br><span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Engineer</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Engineer</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// extends 也可以在类表达式中使用</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Bar</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Foo</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数、HomeObject-和-super"><a href="#构造函数、HomeObject-和-super" class="headerlink" title="构造函数、HomeObject 和 super()"></a>构造函数、HomeObject 和 super()</h3><p>可以使用 <code>super</code> 关键字引用派生类方法的原型</p><ul><li><p><code>super</code> 关键字只能在派生类中使用</p></li><li><p>仅限类构造函数、实例方法和静态方法内部使用</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">hasEngine</span> = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 在调用 super() 之前引用 this 会报错</span><br>        <span class="hljs-comment">// ReferenceError: Must call super constructor in derived class before accessing &#x27;this&#x27; or returning from derived constructor</span><br>        <span class="hljs-variable language_">super</span>();  <span class="hljs-comment">// 相当于 super.constructor()</span><br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Vehicle</span>);  <span class="hljs-comment">// true</span><br>        <span class="hljs-comment">// 派生类的方法</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-comment">// Bus &#123; hasEngine: true &#125;</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 静态方法中可以通过 super 调用父类的静态方法</span><br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">identify</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    true</span><br><span class="hljs-comment">    Bus &#123; hasEngine: true &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>();<br><span class="hljs-title class_">Bus</span>.<span class="hljs-title function_">identify</span>();  <span class="hljs-comment">// vehicle</span><br></code></pre></td></tr></table></figure><ul><li><p><code>ES6</code> 给类构造函数和静态方法添加了内部指针 <code>[[HomeObject]]</code>（无法直接查看），指向定义该方法的对象。</p></li><li><p>该指针自动赋值，<code>[[HomeObject]]</code> 的原型始终定义为 <code>super</code></p></li></ul><br><p>使用 <code>super</code> 注意事项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">licensePlate</span>) &#123;<br>        <span class="hljs-comment">// super 只能在 派生类 构造函数和静态方法中使用</span><br>        <span class="hljs-comment">// super();  // SyntaxError: &#x27;super&#x27; keyword unexpected here</span><br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">licensePlate</span> = licensePlate;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">licensePlate</span>) &#123;<br>        <span class="hljs-comment">// 不能单独引用 super 关键字</span><br>        <span class="hljs-comment">// 要么调用构造函数，要么引用静态方法</span><br>        <span class="hljs-comment">// console.log(super);  // SyntaxError: &#x27;super&#x27; keyword unexpected here</span><br><br>        <span class="hljs-comment">// 需要手动给父类构造函数传参</span><br>        <span class="hljs-variable language_">super</span>(licensePlate);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// super() 会调用父类构造函数，并将返回的实例赋值给 this</span><br>        <span class="hljs-variable language_">super</span>();<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Vehicle</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Van</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-comment">// 在派生类中显式定义构造函数，必须在其中调用 super() 或返回一个对象</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// super();</span><br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 未定义类构造函数，实例化派生类时会调用父类构造函数，并传入所有传给派生类的参数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus1</span>();  <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>(<span class="hljs-string">&#x27;1337H4X&#x27;</span>));  <span class="hljs-comment">// Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus2</span>(<span class="hljs-string">&#x27;1337H4X&#x27;</span>));  <span class="hljs-comment">// Bus2 &#123; licensePlate: &#x27;1337H4X&#x27; </span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Van</span>());  <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p>通过在实例化时检测 <code>new.target</code>（<code>new.target</code> 保存通过 <code>new</code> 关键字调用的类或函数） 是不是抽象基类，可以阻止对抽象基类的实例化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 抽象基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> === <span class="hljs-title class_">Vehicle</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Inheriting class must define foo()&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;success!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Van</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;&#125;<br><br><span class="hljs-comment">// [class Bus extends Vehicle]</span><br><span class="hljs-comment">// success!</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>();<br><span class="hljs-comment">// [class Vehicle]</span><br><span class="hljs-comment">// Error: Vehicle cannot be directly instantiated</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>();<br></code></pre></td></tr></table></figure><h3 id="继承内置类型"><a href="#继承内置类型" class="headerlink" title="继承内置类型"></a>继承内置类型</h3><p>可以扩展内置类型，覆盖 <code>Symbol.species</code> 访问器（决定在创建返回实例时使用的类）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>    <span class="hljs-title function_">shuffle</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">const</span> j = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (i + <span class="hljs-number">1</span>));<br>            [<span class="hljs-variable language_">this</span>[i], <span class="hljs-variable language_">this</span>[j]] = [<span class="hljs-variable language_">this</span>[j], <span class="hljs-variable language_">this</span>[i]];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 默认返回 SuperArray 类实例</span><br>    <span class="hljs-comment">// 返回 Array 类实例</span><br>    <span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperArray</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SuperArray</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <span class="hljs-comment">// SuperArray(5) [ 1, 2, 3, 4, 5 ]</span><br>a.<span class="hljs-title function_">shuffle</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <span class="hljs-comment">// SuperArray(5) [ 1, 5, 3, 2, 4 ]</span><br><br><span class="hljs-keyword">let</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperArray</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    内置类型的方法会返回新实例</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    filter 用于根据条件筛选元素，返回一个新数组</span><br><span class="hljs-comment">    !! 是双重非运算符，用于将数值转为布尔类型</span><br><span class="hljs-comment">    第一个 ! 将数值转换为布尔值的反值</span><br><span class="hljs-comment">    第二个 ! 对第一步的结果取反，得到原 value 对应的真实布尔值</span><br><span class="hljs-comment">    条件等价于 &quot;x 是奇数&quot;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">let</span> a2 = a1.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !!(x%<span class="hljs-number">2</span>))<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a1);  <span class="hljs-comment">// SuperArray(5) [ 1, 2, 3, 4, 5 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2);  <span class="hljs-comment">// [ 1, 3, 5 ]</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SuperArray</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SuperArray</span>);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="多类继承"><a href="#多类继承" class="headerlink" title="多类继承"></a>多类继承</h3><p><code>ES6</code> 没有显式支持多类继承，但通过现有特性可<strong>模拟多类继承</strong></p><p>定义一组“可嵌套”的函数，每个函数分别接收一个超类（被其他类继承的 “父类”）作为参数，将<strong>混入类</strong>定义为该参数的子类，并返回这个类。可以<mark>连续调用组合函数，组成超类表达式</mark></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">FooMixin</span> = (<span class="hljs-params">Superclass</span>) =&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Superclass</span> &#123;<br>    <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">BarMixin</span> = (<span class="hljs-params">Superclass</span>) =&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Superclass</span> &#123;<br>    <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">BazMinxin</span> = (<span class="hljs-params">Superclass</span>) =&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Superclass</span> &#123;<br>    <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;baz&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 接收一个基础类 BaseClass 和任意数量的混入类 Mixins，返回一个融合了所有混入类功能的新类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mix</span>(<span class="hljs-params">BaseClass, ...Mixins</span>) &#123;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">        使用 reduce 迭代 Mixins 数组，将每个混入类依次应用到累积结果上</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        reduce 是 JavaScript 数组的一个高阶函数，用于将数组元素 “累积” 为单个值（也可用于复杂的数组转换）</span><br><span class="hljs-comment">        它通过迭代数组，对每个元素执行回调函数，并将结果传递给下一次迭代，最终得到一个汇总结果</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        迭代过程：</span><br><span class="hljs-comment">        每个 current（当前混入类）是一个函数，它接收上一步的 accumulator（累积的类）作为参数</span><br><span class="hljs-comment">        返回一个继承自 accumulator 并添加了自身功能的新类</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Mixins</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, current</span>) =&gt;</span><br>        <span class="hljs-title function_">current</span>(accumulator),  <span class="hljs-comment">// 当前混入类接收累积类作为参数，返回新的融合类</span><br>        <span class="hljs-title class_">BaseClass</span>);  <span class="hljs-comment">// 初始值：从基础类开始</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">FooMixin</span>(<span class="hljs-title class_">BarMixin</span>(<span class="hljs-title class_">BazMinxin</span>(<span class="hljs-title class_">Vehicle</span>))) &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">mix</span>(<span class="hljs-title class_">Vehicle</span>, <span class="hljs-title class_">FooMixin</span>, <span class="hljs-title class_">BarMixin</span>, <span class="hljs-title class_">BazMinxin</span>) &#123;&#125;<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>();  <span class="hljs-comment">// 与 let b = new Bus1(); 结果相同</span><br>b.<span class="hljs-title function_">foo</span>();  <span class="hljs-comment">// foo</span><br>b.<span class="hljs-title function_">bar</span>();  <span class="hljs-comment">// bar</span><br>b.<span class="hljs-title function_">baz</span>();  <span class="hljs-comment">// baz</span><br></code></pre></td></tr></table></figure><blockquote><p>很多 <code>JavaScript</code> 框架（<code>React</code>）已抛弃混入模式，转向组合模式（把方法提取到独立的类和辅助对象，再把它们组合起来，但不使用继承）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-继承</title>
    <link href="/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/"/>
    <url>/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>很多面向对象语言都支持<strong>接口继承</strong>和<strong>实现继承</strong>。前者只继承<strong>方法签名</strong>，后者继承<strong>实际的方法</strong>。</p><p><code>ECMAScript</code> 中的函数没有签名，所以<strong>只支持实现继承</strong>，并且通过原型链实现。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链的基本思想是<mark>通过原型继承多个引用类型的属性和方法</mark>，在实例和原型之间构造一条原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 实例属性</span><br>&#125;<br><br><span class="hljs-comment">// 原型方法</span><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSuperValue</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span>;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SubType 通过创建 SuperType 的实例并将其赋值给自己的原型实现对 SuperType 的继承</span><br><span class="hljs-comment">    SuperType 实例可以访问的所有属性和方法也会存在于 SubType.prototype</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    SubType.prototype 现在是 SuperType 的一个实例</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();<br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSubValue</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span>;<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getSuperValue</span>());  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><br><p><img src="/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/SubType_SuperType.png" alt="原型之间的关系"><br><br></p><blockquote><p>在读取实例上的属性时，首先在实例上搜索这个属性。如果没找到，则会继承搜索实例的原型</p><p>通过原型链实现继承后，可以继承向上搜索，搜索原型的原型</p><p>对属性和方法的搜索会一直持续到原型链的末端</p></blockquote><p>调用 <code>instance.getSuperValue()</code> 的搜索过程:<br><code>instance</code> -&gt; <code>SubType.prototype</code> -&gt; <code>SuperType.prototype</code> -&gt; <code>SuperType.getSuperValue()</code></p><h3 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h3><p>默认情况下，<mark>所有引用类型</mark>都继承自 <code>Object</code></p><ul><li><p><mark>任何函数</mark>的默认原型都是一个 <code>Object</code> 的实例</p></li><li><p>该实例有一个内部值针指向 <code>Object.prototype</code></p></li><li><p>自定义类型能够继承包括 <code>toString()</code>、<code>valueOf()</code> 在内的所有默认方法</p></li></ul><p><img src="/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/prototypeChain.png" alt="完整的继承原型链"></p><p>调用 <code>instance.toString()</code> 时，实际上调用的是保存在 <code>Object.prototype</code> 上的方法</p><h3 id="原型与继承关系"><a href="#原型与继承关系" class="headerlink" title="原型与继承关系"></a>原型与继承关系</h3><ul><li><p>如果一个实例的原型链中出现过相应的构造函数，则 <code>instanceof</code> 返回 <code>true</code></p></li><li><p>只要原型链中包含对应的原型，<code>isPrototypeOf()</code> 就返回 <code>true</code></p></li></ul><p>接<a href="#%E5%8E%9F%E5%9E%8B%E9%93%BE">前面代码</a>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SuperType</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SubType</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(instance));  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(instance));  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(instance));  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>子类覆盖父类的方法，或者增加父类没有的方法必须<strong>在原型赋值之后再加到原型上</strong></p><p>以<strong>对象字面量</strong>方式创建原型方法会破坏之前的原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSuperValue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span>;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 继承 SuperType</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// 在原型赋值之后将方法加到原型上</span><br><span class="hljs-comment">// 新方法</span><br><span class="hljs-comment">SubType.prototype.getSubValue = function () &#123;</span><br><span class="hljs-comment">    return this.subproperty;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// 覆盖已有的方法</span><br><span class="hljs-comment">SubType.prototype.getSuperValue = function () &#123;</span><br><span class="hljs-comment">    return false;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">let instance = new SubType();</span><br><span class="hljs-comment">console.log(instance.getSuperValue());  // false</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 通过对象字面量添加新方法，导致 SubType.prototype = new SuperType() 无效</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-title function_">getSubValue</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span>;<br>    &#125;,<br><br>    <span class="hljs-title function_">someOtherMethod</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-comment">// TypeError: instance.getSuperValue is not a function</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getSuperValue</span>());<br></code></pre></td></tr></table></figure><p>以<strong>对象字面量</strong>覆盖后的原型是一个 <code>Object</code> 的实例，不再是 <code>SuperType</code> 的实例。之前的原型链断开，<code>SubType</code> 和 <code>SuperType</code> 之间没关系了</p><h3 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><ul><li><p>原型中包含的引用值会在所有实例间共享</p></li><li><p>使用原型实现继承时，原型实际上变成了另一个类型的实例，表明原先的实例属性变成了原型属性</p></li><li><p>子类型在实例化时不能给父类型的构造函数传参</p></li></ul><h2 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h2><ul><li><p>若原型中的属性是<strong>基本类型</strong>（数字、字符串），实例修改时会<mark>在自身创建同名属性</mark>，不影响原型和其它实例</p></li><li><p>若原型中的属性是<strong>引用类型</strong>（数组、对象），实例修改时会<mark>直接操作原型中的引用值</mark>（实例本身没有该属性，会顺着原型链找到原型），导致<strong>所有实例的该属性被同时修改</strong></p></li></ul><p>为解决原型包含<strong>引用值</strong>导致的继承问题，<mark>在子类构造函数中调用父类构造函数</mark>，使用 <code>apply()</code> 和 <code>call()</code> 方法<strong>以新创建的对象为上下文执行构造函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">        继承 SuperType</span><br><span class="hljs-comment">        相当于新的 SubType 对象上运行了 SuperType() 函数中的所有初始化代码</span><br><span class="hljs-comment">        每个实例都会有自己的 colors 属性</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-comment">// [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1.<span class="hljs-property">colors</span>);<br><br><span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-comment">// [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance2.<span class="hljs-property">colors</span>);<br><br></code></pre></td></tr></table></figure><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>盗用构造函数可以在子类构造函数中向父类构造函数传参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 继承 SuperType 并传参</span><br>    <span class="hljs-comment">// 实际上会在 SubType 的实例上定义 name 属性</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;Nicholas&quot;</span>);<br><br>    <span class="hljs-comment">// 为确保 SuperType 构造函数不会覆盖 SubType 定义的属性</span><br>    <span class="hljs-comment">// 可以在调用父类构造函数之后再给子类实例添加额外的属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;  <span class="hljs-comment">// 实例属性</span><br>&#125;<br><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Nicholas</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">age</span>);  <span class="hljs-comment">// 29</span><br></code></pre></td></tr></table></figure><h3 id="盗用构造函数的问题"><a href="#盗用构造函数的问题" class="headerlink" title="盗用构造函数的问题"></a>盗用构造函数的问题</h3><ul><li><p>必须在构造函数中定义方法，函数不能重用</p></li><li><p>子类不能访问父类原型上定义的方法，所有类型只能使用构造函数模式</p></li></ul><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承综合了原型链和盗用构造函数，使用<strong>原型链</strong>继承原型上的<strong>属性和方法</strong>（共享原型方法），通过<strong>盗用构造函数</strong>继承<strong>实例属性</strong>（避免引用值共享）。既可以把方法定义在原型上实现重用，又可以让每个实例都有自己的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-comment">// 继承属性</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);  <span class="hljs-comment">// 子类构造函数，第二次调用 SuperType()</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 继承方法</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();  <span class="hljs-comment">// 创建子类原型，第一次调用 SuperType()</span><br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>);<br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-comment">// [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1.<span class="hljs-property">colors</span>);<br><span class="hljs-comment">// Nicholas</span><br>instance1.<span class="hljs-title function_">sayName</span>();<br><span class="hljs-comment">// 29</span><br>instance1.<span class="hljs-title function_">sayAge</span>();<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SuperType &#123;</span><br><span class="hljs-comment">      name: &#x27;Nicholas&#x27;,</span><br><span class="hljs-comment">      colors: [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ],</span><br><span class="hljs-comment">      age: 29</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SuperType &#123;</span><br><span class="hljs-comment">      name: undefined,</span><br><span class="hljs-comment">      colors: [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ],</span><br><span class="hljs-comment">      sayAge: [Function (anonymous)]</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br><span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>);<br><span class="hljs-comment">// [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance2.<span class="hljs-property">colors</span>);<br><span class="hljs-comment">// Greg</span><br>instance2.<span class="hljs-title function_">sayName</span>();<br><span class="hljs-comment">// 27</span><br>instance2.<span class="hljs-title function_">sayAge</span>();<br></code></pre></td></tr></table></figure><blockquote><p><strong>组合继承是 <code>JavaScript</code> 中使用最多的继承模式</strong></p><p>组合继承保留了 <code>instanceof</code> 操作符和 <code>isPrototypeOf()</code> 方法识别合成对象的能力</p></blockquote><p>但是，组合继承存在<strong>效率问题</strong>，<mark>父类构造函数始终会被调用两次</mark>：</p><ol><li><p>在创建子类原型时调用一次</p></li><li><p>在子类构造函数中调用一次</p></li></ol><p><img src="/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/combined_heritage.png" alt="组合继承"></p><p>由于调用了两次 <code>SuperType</code> 构造函数，所以有两组 <code>name</code> 和 <code>colors</code> 属性：一组在实例上，另一组在 <code>SubType</code> 的原型上</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>原型式继承适用于：</p><ul><li><p>在已有对象基础上再创建一个新对象</p></li><li><p>不需要单独创建构造函数，但仍然需要在对象间共享信息的场合</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// object() 函数会创建一个临时构造函数</span><br><span class="hljs-comment">// 将传入的对象赋值给这个构造函数的原型</span><br><span class="hljs-comment">// 本质上，object() 对传入的对象执行了一次浅复制</span><br><span class="hljs-comment">function object(o) &#123;</span><br><span class="hljs-comment">    function F() &#123;&#125;</span><br><span class="hljs-comment">    F.prototype = o;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 返回临时类型的一个实例</span><br><span class="hljs-comment">    return new F();</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">let person = &#123;</span><br><span class="hljs-comment">    name: &quot;Nicholas&quot;,</span><br><span class="hljs-comment">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">let anotherPerson = object(person);</span><br><span class="hljs-comment">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="hljs-comment">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">let yetAnotherPerson = object(person);</span><br><span class="hljs-comment">yetAnotherPerson.name = &quot;Linda&quot;;</span><br><span class="hljs-comment">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27; ]</span><br><span class="hljs-comment">console.log(person.friends);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>, <span class="hljs-string">&quot;Van&quot;</span>]<br>&#125;;<br><br><span class="hljs-comment">// ECMASCript 通过 Object.create() 方法将原型式继承的概念规范化</span><br><span class="hljs-keyword">let</span> anotherPerson = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(person);<br>anotherPerson.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Greg&quot;</span>;<br>anotherPerson.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Rob&quot;</span>);<br><br><span class="hljs-keyword">let</span> yetAnotherPerson = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(person);<br>yetAnotherPerson.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Linda&quot;</span>;<br>yetAnotherPerson.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Barbie&quot;</span>);<br><br><span class="hljs-comment">// [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">friends</span>);<br></code></pre></td></tr></table></figure><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式继承类似寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 可将 object() 函数替换为任何返回新对象的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">object</span>(<span class="hljs-params">o</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;<br><br>    <span class="hljs-comment">// 返回临时类型的一个实例</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br><br><span class="hljs-comment">// 函数参数为新对象的基准对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAnother</span>(<span class="hljs-params">original</span>) &#123;<br>    <span class="hljs-comment">// 通过调用函数创建一个新对象</span><br>    <span class="hljs-keyword">let</span> clone = <span class="hljs-title function_">object</span>(original);<br><br>    <span class="hljs-comment">// 给 clone 对象添加一个新方法（以某种方式增强对象）</span><br>    clone.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>    &#125;;<br><br>    <span class="hljs-comment">// 返回这个对象</span><br>    <span class="hljs-keyword">return</span> clone;<br>&#125;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>, <span class="hljs-string">&quot;Van&quot;</span>]<br>&#125;;<br><br><span class="hljs-keyword">let</span> anotherPerson = <span class="hljs-title function_">createAnother</span>(person);<br>anotherPerson.<span class="hljs-title function_">sayHi</span>();<br></code></pre></td></tr></table></figure><blockquote><p>寄生式继承适合主要关注对象，不在乎类型和构造函数的场景</p><p>通过寄生式继承给对象添加函数会导致函数难以重用</p></blockquote><h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><p>寄生式组合继承<mark>通过盗用构造函数继承属性，但使用<strong>混合式原型链</strong>继承方法</mark>（使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型）解决<a href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF">组合继承</a>的<strong>效率问题</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">object</span>(<span class="hljs-params">o</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br><br><span class="hljs-comment">// 函数接收子类构造函数和父类构造函数作为参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>) &#123;<br>    <span class="hljs-comment">// 创建父类原型的副本</span><br>    <span class="hljs-keyword">let</span> prototype = <span class="hljs-title function_">object</span>(superType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>    <span class="hljs-comment">// 给返回的 prototype 对象设置 constructor 属性</span><br>    <span class="hljs-comment">// 解决重写原型导致默认 constructor 丢失问题</span><br>    prototype.<span class="hljs-property">constructor</span> = subType;<br>    <span class="hljs-comment">// 将新创建的对象赋值给子类的原型</span><br>    subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-comment">// 只调用一次 SuperType 构造函数，避免属性重复</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-title class_">SubType</span>, <span class="hljs-title class_">SuperType</span>);<br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SubType &#123;</span><br><span class="hljs-comment">      name: &#x27;Nicholas&#x27;,</span><br><span class="hljs-comment">      colors: [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ],</span><br><span class="hljs-comment">      age: 29</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SuperType &#123;</span><br><span class="hljs-comment">      constructor: [Function: SubType],</span><br><span class="hljs-comment">      sayAge: [Function (anonymous)]</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br></code></pre></td></tr></table></figure><blockquote><p>使用寄生式组合继承原型链保持不变，<code>instanceof()</code> 和 <code>isPrototypeOf()</code> 正常有效</p><p>寄生式组合继承是<strong>引用类型继承的最佳模式</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-创建对象</title>
    <link href="/2025/10/22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <url>/2025/10/22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p><code>ECMAScript 6</code> 开始正式支持类和继承</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>按照惯例，构造函数名称的<strong>首字母</strong>都是<strong>大写</strong>的，非构造函数则以小写字母开头</p><p><strong><code>ECMAScript</code> 中的函数是对象</strong>，每次定义函数时，都会初始化一个对象</p><p>使用 <code>new</code> 操作符调用构造函数创建对象实例会执行如下操作：</p><blockquote><p>(1) 在内存中创建一个新对象</p><p>(2) 新对象内部的 <code>[[Protoype]]</code> 特性被赋值为构造函数的 <code>prototype</code> 属性</p><p>(3) 构造函数内部的 <code>this</code> 被赋值为这个新对象(即 <code>this</code> 指向新对象)</p><p>(4) 执行构造函数内部的代码(给新对象添加属性)</p><p>(5) 构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象</p></blockquote><h3 id="instanceof-操作符用于确定对象类型"><a href="#instanceof-操作符用于确定对象类型" class="headerlink" title="instanceof 操作符用于确定对象类型"></a><code>instanceof</code> 操作符用于确定对象类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数（Function）：是一种「可执行的对象」，它除了具备对象的所有特性（可存储属性、有原型等），还额外拥有「可调用性」（可以被执行，有参数和返回值）</span><br><span class="hljs-comment">// 函数是「能执行的对象」，对象是「函数创建的实例或数据集合」</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, job</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">job</span> = job;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Software Engineer&quot;</span>);<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&quot;Doctor&quot;</span>);<br><br><span class="hljs-comment">// Object 是所有对象的基类（原型链的顶端），几乎所有对象都直接或间接继承自 Object.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="实例化不传参数时，构造函数后面的括号可加可不加。只要有-new-操作符，就可以调用相应的构造函数"><a href="#实例化不传参数时，构造函数后面的括号可加可不加。只要有-new-操作符，就可以调用相应的构造函数" class="headerlink" title="实例化不传参数时，构造函数后面的括号可加可不加。只要有 new 操作符，就可以调用相应的构造函数"></a>实例化不传参数时，构造函数后面的括号可加可不加。只要有 <code>new</code> 操作符，就可以调用相应的构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Jake&quot;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>;<br></code></pre></td></tr></table></figure><h3 id="构造函数也是函数"><a href="#构造函数也是函数" class="headerlink" title="构造函数也是函数"></a>构造函数也是函数</h3><ul><li><p>任何函数只要使用 <code>new</code> 操作符调用就是构造函数，而不使用 <code>new</code> 操作符调用的函数就是普通函数</p></li><li><p>没有使用 <code>new</code> 操作符调用构造函数，结果会将属性和方法添加到 <code>window</code> 对象</p></li><li><p>在调用一个函数没有明确设置 <code>this</code> 值(没有作为对象的方法调用，或没有使用 <code>call()/apply()</code> 调用)，<code>this</code> 始终指向 <code>Global</code> 对象(浏览器中为 <code>window</code> 对象)</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 只有浏览器环境中才有 window 对象</span><br><span class="hljs-comment">// 在 Node.js 环境中执行会报错 ReferenceError: window is not defined</span><br><span class="hljs-variable language_">window</span> = <span class="hljs-variable language_">global</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, job</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">job</span> = job;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>    <span class="hljs-comment">// 与 sayName 逻辑上等价</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&quot;console.log(this.name)&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Software Engineer&quot;</span>);<br>person.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Nicholas</span><br><br><span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&quot;Doctor&quot;</span>);<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Greg</span><br><br><span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">    call() 是函数对象的一个方法，用于调用函数并指定函数执行时的 this 指向</span><br><span class="hljs-comment">    将对象 o 指定为 Person() 内部的 this 值</span><br><span class="hljs-comment">    所有属性和 sayName() 方法都会添加到对象 o</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(o, <span class="hljs-string">&quot;Kristen&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Nurse&quot;</span>);<br>o.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Kristen</span><br></code></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>每个函数都会创建一个 <code>prototype</code> 对象属性，包含应该由特定引用类型的实例共享的属性和方法</p><p>当通过构造函数创建实例时，实例会自动「关联」到该原型对象，从而可以共享原型对象中的属性和方法，避免重复定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-comment">// let Person = function() &#123;&#125;;  // 等价函数表达式</span><br><br><span class="hljs-comment">// 在构造函数中直接赋给对象实例的值，可以直接赋给它们的原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person1.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Nicholas</span><br><br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person2.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Nicholas</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">sayName</span> == person2.<span class="hljs-property">sayName</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// [Function: Person]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">取得对象的原型</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  name: &#x27;Nicholas&#x27;,</span><br><span class="hljs-comment">  age: 29,</span><br><span class="hljs-comment">  job: &#x27;Software Engineer&#x27;,</span><br><span class="hljs-comment">  sayName: [Function (anonymous)]</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person1));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person2));<br></code></pre></td></tr></table></figure><h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><p>只要创建一个函数，就会按照特定的规则为这个函数创建一个 <code>prototype</code> 属性（指向原型对象）。默认情况下，<strong>所有原型对象自动获得一个名为 <code>constructor</code> 的属性，指向与之关联的构造函数</strong></p><p><a href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">前面代码</a>中的 <code>Person.prototype.constructor</code> 指向 <code>Person</code></p><p>自定义构造函数时，原型对象默认只会获得 <code>constructor</code> 属性，其它所有方法都继承自 <code>Object</code></p><p>每次调用构造函数创建一个新实例，该实例的内部 <code>[[Prototype]]</code> 指针就会被赋值为构造函数的原型对象。浏览器会在每个对象上暴露可以访问原型对象的 <code>__proto__</code> 属性</p><p><strong>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有联系</strong></p><p>构造函数通过 <code>prototype</code> 指向原型对象，实例通过 <code>__proto__</code> 关联原型对象</p><p><img src="/2025/10/22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/person.prototype.png" alt="构造函数、原型对象和对象之间的关系"></p><ul><li><p><code>Person.prototype</code> 指向原型对象，而 <code>Person.prototpye.constructor</code> 指向 <code>Person</code> 构造函数</p></li><li><p>原型对象包含 <code>constructor</code> 属性和其他后来添加的属性</p></li><li><p>两个实例都没有属性和方法，但可以正常调用 <code>sayName()</code> 函数<br><br></p></li></ul><blockquote><p>使用 <code>Object.getPrototypeOf()</code> 可以取得一个对象的原型</p><p>为避免使用 <code>Object.setPrototypeOf()</code> 可能造成的性能下降，可以通过 <code>Object.create()</code> 创建一个新对象，同时为其指定原型</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> biped = &#123;<br>    <span class="hljs-attr">numLegs</span>: <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(biped);<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Matt&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Matt</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">numLegs</span>);  <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person) === biped);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h3><p>通过对象访问属性时，如果在对象实例上发现了给定的名称，则返回该名称对应的值。否则，会沿着指针进入原型对象，在原型对象上找到属性，再返回对应的值</p><p>只要给对象实例添加一个属性，这个属性就会<strong>遮蔽</strong>原型对象上的同名属性。使用 <code>delete</code> 操作符可以完全删除实例上的属性，让标识符解析过程能够继续搜索原型对象</p><p><code>hasOwnProperty()</code> 方法会在属性存在于调用它的对象实例上时返回 <code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>person1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Greg&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Greg</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Nicholas</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">delete</span> person1.<span class="hljs-property">name</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Nicholas</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><br><blockquote><p><code>ECMAScript</code> 的 <code>Object.getOWnPropertyDescriptor()</code> 方法只对实例属性有效</p><p>必须直接在原型对象上调用 <code>Object.getOwnPropertyDescriptor()</code> 获得原型属性的描述符</p></blockquote><h3 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a><code>in</code> 操作符</h3><p><code>in</code> 操作符会在可以通过对象访问指定属性时返回 <code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">in</span> person1);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>要确定原型上是否存在某个属性，可以同时使用 <code>hasOwnProperty()</code> 和 <code>in</code> 操作符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasPrototypeProperty</span>(<span class="hljs-params">object, name</span>) &#123;<br>    <span class="hljs-comment">// 通过对象可以访问时，in 操作符返回 true</span><br>    <span class="hljs-comment">// hasOwnProperty() 只有实例上存在属性时才返回 true</span><br>    <span class="hljs-comment">// in 操作符返回 true 且 hasOwnProperty() 返回 false 为原型属性</span><br>    <span class="hljs-keyword">return</span> !object.<span class="hljs-title function_">hasOwnProperty</span>(name) &amp;&amp; (name <span class="hljs-keyword">in</span> object);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasPrototypeProperty</span>(person, <span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// true</span><br><br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Greg&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasPrototypeProperty</span>(person, <span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><code>Object.keys()</code> 可以获得对象上所有可枚举的实例属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys);  <span class="hljs-comment">// [ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;sayName&#x27; ]</span><br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Rob&quot;</span>;<br>p1.<span class="hljs-property">age</span> = <span class="hljs-number">50</span>;<br><br><span class="hljs-keyword">let</span> p1keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(p1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1keys);  <span class="hljs-comment">// [ &#x27;name&#x27;, &#x27;age&#x27; ]</span><br><br><span class="hljs-comment">// 无论是否可以枚举，Object.getOWnPropertyNames() 都可以列出所有实例属性</span><br><span class="hljs-keyword">let</span> keys1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">// 返回的结果中包含一个不可枚举的属性 constructor</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys1);  <span class="hljs-comment">// [ &#x27;constructor&#x27;, &#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;sayName&#x27; ]</span><br></code></pre></td></tr></table></figure><p><code>Object.geOwnPropertySymbols()</code> 用于获取对象自身所有 <strong><code>Symbol</code> 类型属性</strong>（不包含继承的 <code>Symbol</code> 属性），与 <code>Object.getOwnPropertyNames()</code> 类似，但专门针对 <code>Symbol</code> 类型的属性（普通字符串属性不会被返回）</p><h3 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h3><p><code>for-in</code> 循环和 <code>Object.keys()</code> 的枚举顺序时不确定的，取决于 <code>JavaScript</code> 引擎，可能因浏览器而异</p><p><code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code> 和 <code>Object.assign()</code> <mark>先以升序枚举数值键</mark>，然后<mark>以插入顺序枚举字符串和符号键</mark>。</p><p>在对象字面量中定义的键以它们逗号分割的顺序（<strong>键值对的书写顺序</strong>）插入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> k1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;k1&#x27;</span>),<br>    k2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;k2&#x27;</span>);<br><br><span class="hljs-keyword">let</span> o = &#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;first&#x27;</span>,<br>    [k2]: <span class="hljs-string">&#x27;sym2&#x27;</span>,<br>    <span class="hljs-attr">second</span>: <span class="hljs-string">&#x27;second&#x27;</span>,<br>    <span class="hljs-number">0</span>: <span class="hljs-number">0</span><br>&#125;;<br><br>o[k1] = <span class="hljs-string">&#x27;sym2&#x27;</span>;<br>o[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>o.<span class="hljs-property">third</span> = <span class="hljs-string">&#x27;third&#x27;</span>;<br>o[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// [ &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;first&#x27;, &#x27;second&#x27;, &#x27;third&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(o));<br><br><span class="hljs-comment">// [ Symbol(k2), Symbol(k1) ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(o));<br></code></pre></td></tr></table></figure><h2 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h2><p>静态方法 <code>Object.values()</code> 和 <code>Object.entries()</code> 用于将对象内容转换为可迭代序列化的格式</p><ul><li><p>这两个方法接收一个对象</p></li><li><p><code>Object.values()</code> 返回<strong>对象值的数组</strong></p></li><li><p><code>Object.entries()</code> 返回<strong>键&#x2F;值对的数组</strong></p></li><li><p>非字符串属性会被转换为字符串输出</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>();<br><br><span class="hljs-keyword">const</span> o = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">qux</span>: &#123;&#125;,<br>    [sym]: <span class="hljs-string">&#x27;foo&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 符号属性 sym 会被忽略</span><br><span class="hljs-comment">// [ &#x27;bar&#x27;, 1, &#123;&#125; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(o));<br><br><span class="hljs-comment">// [ [ &#x27;foo&#x27;, &#x27;bar&#x27; ], [ &#x27;baz&#x27;, 1 ], [ &#x27;qux&#x27;, &#123;&#125; ] ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(o));<br><br><span class="hljs-comment">// 这两个方法执行对象的浅复制</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(o)[<span class="hljs-number">0</span>] === o.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">    Object.entries(o)[0]: [&#x27;foo&#x27;, &#x27;bar&#x27;]</span><br><span class="hljs-comment">    Object.entries(o)[0][1]: &#x27;bar&#x27;</span><br><span class="hljs-comment">    o.foo: &#x27;bar&#x27;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(o)[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] === o.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="其他原型语法"><a href="#其他原型语法" class="headerlink" title="其他原型语法"></a>其他原型语法</h3><p>为了减少代码冗余，通常直接通过一个包含所有属性和方法的对象字面量来重写原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-comment">// 防止 constructor 属性指向 Object 构造函数</span><br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">29</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> friend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(friend <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(friend <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(friend.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(friend.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 与 constructor: Person 等价操作</span><br><span class="hljs-comment">// Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class="hljs-comment">//     enumerable: false,</span><br><span class="hljs-comment">//     value: Person</span><br><span class="hljs-comment">// &#125;);</span><br></code></pre></td></tr></table></figure><h3 id="原型动态性"><a href="#原型动态性" class="headerlink" title="原型动态性"></a>原型动态性</h3><p>从原型上搜索值的过程是动态的，即使实例在修改原型之前已经存在，任何时候对原型所作的修改也会在实例上反映出来</p><p>原因：实例和原型之间使用指针链接，而不是保存的副本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-comment">// constructor: Person,</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">29</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> friend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-comment">// 创建 friend 实例后添加 sayHi() 方法</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>&#125;;<br><br><span class="hljs-comment">// friend 仍然可以访问 sayHi() 方法</span><br>friend.<span class="hljs-title function_">sayHi</span>();  <span class="hljs-comment">// hi</span><br></code></pre></td></tr></table></figure><p>重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-keyword">let</span> friend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">29</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// friend 指向的还是最初的原型，并没有 sayName() 属性</span><br>friend.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// TypeError: friend.sayName is not a function</span><br></code></pre></td></tr></table></figure><br><p><img src="/2025/10/22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/rewrite_prototype.png" alt="重写原型后的对应关系"></p><h3 id="原生对象原型"><a href="#原生对象原型" class="headerlink" title="原生对象原型"></a>原生对象原型</h3><p>所有原生引用类型的构造函数（包括 <code>Object</code>、<code>Array</code>、<code>String</code> 等）都在原型上定义了实例方法</p><p>可以像修改自定义对象原型一样修改原生对象原型，随时可以添加方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 String 原始值包装类型的实例添加一个 startsWith() 方法</span><br><span class="hljs-comment">// 当前环境下所有的字符串都可以使用这个方法</span><br><span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">startsWith</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">indexOf</span>(text) === <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">let</span> msg = <span class="hljs-string">&quot;Hello world!&quot;</span>;<br><span class="hljs-comment">// 读取 msg 的属性时，后台会自动创建 String 的包装实例（JavaScript 临时创建的对应的对象类型实例）</span><br><span class="hljs-comment">// 找到并调用 startsWith() 方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br></code></pre></td></tr></table></figure><blockquote><p>推荐创建一个自定义的类，继承原生类型<br>不推荐修改原生对象原型，直接修改原生对象类型可能引发命名冲突</p></blockquote><h3 id="原型的问题"><a href="#原型的问题" class="headerlink" title="原型的问题"></a>原型的问题</h3><p>原型弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值</p><p>原型最主要问题源自它的<strong>共享特性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">29</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>],<br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>person1.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Van&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">friends</span>);  <span class="hljs-comment">// [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">friends</span>);  <span class="hljs-comment">// [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">friends</span> === person2.<span class="hljs-property">friends</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>由于 <code>friends</code> 属性存在于 <code>Person.prototype</code> 而非 <code>person1</code> 上，新加的 “Van” 也会在 <code>person2.friends</code> 上反映出来</p><p>一般不同的实例应该有属于自己的属性副本，所以在实际开发中通常不单独使用原型模式</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-对象基本概念</title>
    <link href="/2025/10/21/JavaScript-%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2025/10/21/JavaScript-%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p><code>ECMA-262</code> 使用两个中括号把特性的名称括起来，将某个特性标识为内部特性，例如 <code>[[Enumerable]]</code></p><h2 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h2><ul><li><p>数据属性包含一个保存数据值的位置，从这个位置读取和写入值</p></li><li><p>调用 <code>Object.defineProperty()</code> 如果不指定 <code>configurable、enumerable 和 writable</code>，默认都为 <code>false</code></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义一个对象，包含伪私有成员 year_ 和公共成员 edition</span><br><span class="hljs-keyword">let</span> book = &#123;<br><span class="hljs-attr">year_</span>: <span class="hljs-number">2017</span>,  <span class="hljs-comment">// year_ 中的下划线表示该属性不希望在对象方法的外部被访问</span><br><span class="hljs-attr">edition</span>: <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><ul><li><p>访问器属性不包含数据值，包含一个获取（<code>getter</code>）函数和一个设置（<code>setter</code>）函数</p></li><li><p>只定义 <code>getter</code> 函数意味着属性是只读的，尝试修改属性会被忽略</p></li><li><p>只有一个 <code>setter</code> 函数的属性是不能读取的</p></li></ul><h2 id="Object-defineProperties-方法可以通过多个描述符一次性定义多个属性"><a href="#Object-defineProperties-方法可以通过多个描述符一次性定义多个属性" class="headerlink" title="Object.defineProperties() 方法可以通过多个描述符一次性定义多个属性"></a><code>Object.defineProperties()</code> 方法可以通过多个描述符一次性定义多个属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(book, &#123;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">        year_ 和 edition 是数据属性</span><br><span class="hljs-comment">    configurable、enumerable 和 writable 特性值都是 false</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        使用 Object.defineProperties 必须使用 Object 定义属性</span><br><span class="hljs-comment">        否则会报错 TypeError: Property description must be an object:</span><br><span class="hljs-comment">    */</span><br><span class="hljs-attr">year_</span>: &#123;<br><span class="hljs-attr">value</span>: <span class="hljs-number">2017</span><br>&#125;,<br><br><span class="hljs-attr">edition</span>: &#123;<br><span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;,<br><br><span class="hljs-comment">// 访问器属性</span><br><span class="hljs-attr">year</span>: &#123;<br><span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span>;<br>&#125;,<br><br><span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br><span class="hljs-keyword">if</span>(newValue &gt; <span class="hljs-number">2017</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span> = newValue;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">edition</span> += newValue - <span class="hljs-number">2017</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="使用-Object-getOwnPropertyDescriptor-方法可以取得指定属性的属性描述符"><a href="#使用-Object-getOwnPropertyDescriptor-方法可以取得指定属性的属性描述符" class="headerlink" title="使用 Object.getOwnPropertyDescriptor() 方法可以取得指定属性的属性描述符"></a>使用 <code>Object.getOwnPropertyDescriptor()</code> 方法可以取得指定属性的属性描述符</h2><p>该方法接收属性所在的对象和要取得其描述符的属性名</p><p><strong>访问器属性</strong>返回包含 <code>configurable、enumerable、get</code> 和 <code>set</code> 属性的对象</p><p><strong>数据属性</strong>返回包含 <code>configurable、enumerable、writable</code> 和 <code>value</code> 属性的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book = &#123;&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(book, &#123;<br>    <span class="hljs-attr">year_</span>: &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-number">2017</span><br>    &#125;,<br><br>    <span class="hljs-attr">edition</span>: &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>    &#125;,<br><br>    <span class="hljs-attr">year</span>: &#123;<br>        <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span>;<br>        &#125;,<br><br>        <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) &#123;<br>            <span class="hljs-keyword">if</span> (newValue &gt; <span class="hljs-number">2017</span>) &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span> = newValue;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">edition</span> += newValue - <span class="hljs-number">2017</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;);<br><br><span class="hljs-keyword">let</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(book, <span class="hljs-string">&#x27;year_&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">value</span>);  <span class="hljs-comment">// 2017</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">configurable</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> descriptor.<span class="hljs-property">get</span>);  <span class="hljs-comment">// undefined</span><br><br>descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(book, <span class="hljs-string">&#x27;year&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">value</span>);  <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">enumerable</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> descriptor.<span class="hljs-property">get</span>);  <span class="hljs-comment">// function</span><br><br><span class="hljs-comment">// Object.getOwnPropertyDescriptors() 会在每个自有属性上调用 Object.getOwnPropertyDescriptor() 并在一个新对象中返回它们</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(book));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  year_: &#123;</span><br><span class="hljs-comment">    value: 2017,</span><br><span class="hljs-comment">    writable: false,</span><br><span class="hljs-comment">    enumerable: false,</span><br><span class="hljs-comment">    configurable: false</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  edition: &#123; value: 1, writable: false, enumerable: false, configurable: false &#125;,</span><br><span class="hljs-comment">  year: &#123;</span><br><span class="hljs-comment">    get: [Function: get],</span><br><span class="hljs-comment">    set: [Function: set],</span><br><span class="hljs-comment">    enumerable: false,</span><br><span class="hljs-comment">    configurable: false</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="Object-assign-方法用于合并对象"><a href="#Object-assign-方法用于合并对象" class="headerlink" title="Object.assign() 方法用于合并对象"></a><code>Object.assign()</code> 方法用于合并对象</h2><p>该方法接收<strong>一个目标对象</strong>和<strong>一个或多个源对象</strong>作为参数，然后将每个源对象中可枚举（<code>Object.propertyIsEnumerable()</code> 返回 <code>true</code>） 和自有（<code>Object.hasOwnProperty()</code> 返回 <code>true</code>）属性复制到目标对象</p><p>该方法会复制以字符串和符号为键的属性</p><p>对每个符合条件的属性，该方法会使用源对象上的 <code>[[Get]]</code> 取得属性的值，然后使用目标对象上的 <code>[[Set]]</code> 设置属性的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">dest = &#123;<br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">val</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Invoked dest setter with param <span class="hljs-subst">$&#123;val&#125;</span>`</span>);<br>    &#125;<br>&#125;;<br><br>src = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Invoked src getter&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">调用 src 的获取方法</span><br><span class="hljs-comment">调用 dest 的设置方法并传入参数 &quot;foo&quot;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, src);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Invoked src getter</span><br><span class="hljs-comment">Invoked dest setter with param foo</span><br><span class="hljs-comment">&#123; a: [Setter] &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dest);<br></code></pre></td></tr></table></figure><hr><p><code>Object.assign()</code> 对每个源对象执行<strong>浅复制</strong>(1.直接复制对象的基本类型值 2.引用类型数据只复制内存地址，<strong>新旧对象共享同一份深层数据</strong>，修改深层数据会相互影响)。如果多个源对象有相同的属性，则使用最后一个复制的值</p><p>如果赋值期间出错，操作会中止并退出，同时抛出错误</p><h2 id="Object-is-判定相等"><a href="#Object-is-判定相等" class="headerlink" title="Object.is() 判定相等"></a><code>Object.is()</code> 判定相等</h2><p><code>Object.is()</code> 与 <code>===</code> 类似，但能正确处理特殊值</p><ul><li><p><code>Object.is(NaN, NaN)</code> 返回 <code>true</code>（而 <code>NaN === NaN</code> 返回 <code>false</code>）</p></li><li><p><code>Object.is(+0, -0)</code> 返回 <code>false</code>（而 <code>+0 === -0</code> 返回 <code>true</code>）</p></li></ul><h2 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h2><h3 id="简写属性名"><a href="#简写属性名" class="headerlink" title="简写属性名"></a>简写属性名</h3><p>简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 <code>ReferenceError</code></p><p>下面两段代码等价</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>;<br><br><span class="hljs-keyword">let</span> person = &#123;<br><span class="hljs-attr">name</span>: name<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);  <span class="hljs-comment">// &#123; name: &#x27;Matt&#x27; &#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>name<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);  <span class="hljs-comment">// &#123; name: &#x27;Matt&#x27; &#125;</span><br></code></pre></td></tr></table></figure><h3 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h3><p>可计算属性可以在对象字面量中完成动态属性赋值，不用先声明对象，再使用中括号语法来添加属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> nameKey = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-keyword">const</span> ageKey = <span class="hljs-string">&#x27;age&#x27;</span>;<br><span class="hljs-keyword">const</span> jobKey = <span class="hljs-string">&#x27;job&#x27;</span>;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>[nameKey]: <span class="hljs-string">&#x27;Matt&#x27;</span>,<br>[ageKey]: <span class="hljs-number">27</span>,<br>[jobKey]: <span class="hljs-string">&#x27;Software engineer&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#x27;Software engineer&#x27; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);<br></code></pre></td></tr></table></figure><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象解构就是使用与对象匹配的结构来实现对象属性赋值，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。</p><p>如果引用的属性不存在，则该变量的值就是 <code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Matt&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">name</span>: personName, <span class="hljs-attr">age</span>: personAge &#125; = person;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personName);  <span class="hljs-comment">// Matt</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personAge);  <span class="hljs-comment">// 27</span><br><br><span class="hljs-comment">// let &#123; name, age &#125; = person;</span><br><br><span class="hljs-comment">// console.log(name);  // Matt</span><br><span class="hljs-comment">// console.log(age);  // 27</span><br><br><span class="hljs-keyword">let</span> &#123; name, job &#125; = person;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);  <span class="hljs-comment">// Matt</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(job);  <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><ul><li><p>解构在内部使用函数 <code>ToObject()</code> 把数据结构转换为对象</p></li><li><p>在对象解构的上下文中，原始值会被当成对象</p></li><li><p><code>null</code> 和 <code>undefined</code> 不能被解构，否则会抛出错误</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; length &#125; = <span class="hljs-string">&#x27;foobar&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(length);  <span class="hljs-comment">// 6</span><br><br><span class="hljs-comment">// 通过对象解构赋值，从数字 4 的「包装对象」中提取 constructor 属性，并将其赋值给变量 c</span><br><span class="hljs-comment">// 对象的 constructor 属性指向创建该对象的构造函数</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">constructor</span>: c &#125; = <span class="hljs-number">4</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c === <span class="hljs-title class_">Number</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">let</span> &#123; _ &#125; = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// TypeError</span><br><span class="hljs-keyword">let</span> &#123; _0 &#125; = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure><p><strong>如果给事先声明的变量赋值，则赋值表达式必须包含在一对括号中</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> personName, personAge;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Matt&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span><br>&#125;;<br><br><span class="hljs-comment">// let &#123;name: personName, age: personAge&#125; = person;</span><br>(&#123;<span class="hljs-attr">name</span>: personName, <span class="hljs-attr">age</span>: personAge&#125; = person);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personName, personAge);  <span class="hljs-comment">// Matt, 27</span><br></code></pre></td></tr></table></figure><p>解构赋值可以使用嵌套解构，以匹配嵌套的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Matt&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span>,<br>    <span class="hljs-attr">job</span>: &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Software Engineer&#x27;</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 声明 title 变量并将 person.job.title 的值赋给它</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">job</span>: &#123; title &#125; &#125; = person;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(title);  <span class="hljs-comment">// Software Engineer</span><br></code></pre></td></tr></table></figure><ul><li><p>在源对象或目标对象外层属性没有定义的情况下不能使用嵌套解构</p></li><li><p>如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>popup.html 代码理解</title>
    <link href="/2025/10/21/popup-html-%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <url>/2025/10/21/popup-html-%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 声明文档类型为 HTML5，告诉浏览器以 HTML5 标准解析文档，避免进入 “怪异模式”（兼容旧版本 HTML 的解析方式）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 整个 HTML 文档的根容器，所有其他元素都嵌套在其中 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 用于定义文档的元数据、外部资源引用（脚本、样式等），不直接显示在页面上 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">用于响应式设计，适配移动设备（虽然扩展弹出页通常尺寸固定，但仍可能涉及缩放）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">width=device-width：让页面宽度等于设备宽度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">initial-scale=1：初始缩放比例为 1（不缩放）</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">defer=&quot;defer&quot;：表示脚本会延迟执行。浏览器会继续解析 HTML，同时下载脚本，直到 HTML 解析完成后再执行脚本</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">../js/popup.js，表示当前目录的上一级目录中的 js 文件夹）</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span>=<span class="hljs-string">&quot;defer&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/popup.js&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">引入外部 CSS 样式表 popup.css，用于美化页面样式</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">该路径等价于 ../css/popup.css</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">rel=&quot;stylesheet&quot; 表明这是一个样式表文件</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../js/../css/popup.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">包含页面的可见内容，是用户实际看到的部分</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">一个空的 &lt;div&gt; 容器，用于通过 JavaScript（popup.js）动态生成弹出页的内容（如按钮、列表、表单等）。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">id=&quot;chrome-extension-popup&quot; 为其指定唯一标识，方便脚本通过 document.getElementById 获取该元素并操作（如添加子元素、修改内容等）</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;chrome-extension-popup&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码理解</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manifest.json 代码理解</title>
    <link href="/2025/10/21/manifest-json-%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <url>/2025/10/21/manifest-json-%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<!-- 给一个 `Chrome` 扩展程序的 `manifest.json` 文件添加了理解注释 --><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-comment">// 定义扩展在浏览器工具栏中的按钮（即 “动作按钮”）</span><br>   <span class="hljs-attr">&quot;action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;default_icon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;icons/ic_16.png&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 按钮默认显示的图标（16x16）</span><br>      <span class="hljs-attr">&quot;default_popup&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;html/popup.html&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 点击按钮时弹出的页面（html/popup.html），通常用于展示功能界面（如提取结果）</span><br>      <span class="hljs-attr">&quot;default_title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Turbo Email Extractor&quot;</span>  <span class="hljs-comment">// 鼠标悬停在按钮上时显示的提示文字</span><br>   <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 定义扩展的背景服务</span><br>   <span class="hljs-attr">&quot;background&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// 指定背景服务的脚本文件, 用于处理扩展的后台逻辑（如监听事件、持久化数据等）</span><br>      <span class="hljs-comment">// service worker 是无界面的，生命周期由浏览器管理，不支持 DOM 操作</span><br>      <span class="hljs-comment">// DOM（Document Object Model，文档对象模型）操作指的是通过代码对 HTML 或 XML 文档的结构、内容和样式进行动态修改的过程</span><br>      <span class="hljs-attr">&quot;service_worker&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;js/background.js&quot;</span><br>   <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 定义内容脚本（注入到网页中的脚本，用于操作网页 DOM 或数据）</span><br>   <span class="hljs-attr">&quot;content_scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// 注入到匹配网页的样式表（css/contentScripts.css），用于修改网页样式</span><br>      <span class="hljs-attr">&quot;css&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;css/contentScripts.css&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// 注入到匹配网页的脚本（js/contentScripts.js），核心逻辑（如提取网页中的邮件地址）通常在这里实现</span><br>      <span class="hljs-attr">&quot;js&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;js/contentScripts.js&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// 匹配的网页 URL 规则，&lt;all_urls&gt; 表示所有 HTTP/HTTPS/FTP 等网页</span><br>      <span class="hljs-attr">&quot;matches&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;\u003Call_urls&gt;&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// 脚本注入时机，document_start 表示在网页 DOM 开始解析时注入（早于 document_ready）</span><br>      <span class="hljs-comment">// </span><br>      <span class="hljs-comment">// document_start:</span><br>      <span class="hljs-comment">// 浏览器刚刚开始解析 HTML 文档，尚未构建任何 DOM 节点，&lt;html&gt; 标签甚至都未被解析</span><br>      <span class="hljs-comment">// 此时，文档处于最早期的加载阶段，仅完成了资源的初始获取，尚未开始实质性的 DOM 树构建</span><br>      <span class="hljs-comment">// 适合执行不需要依赖 DOM 的初始化操作（如设置全局变量、注册事件监听框架等）</span><br>      <span class="hljs-comment">// </span><br>      <span class="hljs-comment">// document_ready:</span><br>      <span class="hljs-comment">// 对应 DOMContentLoaded 事件触发的时刻，即 HTML 文档完全解析并构建出完整的 DOM 树</span><br>      <span class="hljs-comment">// 此时无需等待样式表、图片、iframe 等外部资源加载完成</span><br>      <span class="hljs-comment">// DOM 树已完整可用，可以安全地操作任何 DOM 元素（如查询、修改、绑定事件等）</span><br>      <span class="hljs-comment">// 若存在阻塞 DOM 解析的脚本（如同步 &lt;script&gt;），会延迟 document_ready 的触发时间</span><br>      <span class="hljs-attr">&quot;run_at&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;document_start&quot;</span><br>   <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Extract emails from all web pages&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// host_permissions 声明扩展需要访问的主机权限，&lt;all_urls&gt; 表示允许访问所有 URL 的网页</span><br>   <span class="hljs-comment">// \u003C 表示 &#x27;&lt;&#x27; 的转义序列</span><br>   <span class="hljs-comment">// \u 后跟四位十六进制数字是 Unicode 转义序列格式，用于表示特定的 Unicode 字符</span><br>   <span class="hljs-comment">// 003C 对应 Unicode 字符集中小于号(&lt;)的代码点</span><br>   <span class="hljs-attr">&quot;host_permissions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;\u003Call_urls&gt;&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 定义扩展在不同场景下显示的图标</span><br>   <span class="hljs-attr">&quot;icons&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;128&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;icons/ic_128.png&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 安装时的提示、应用商店展示等</span><br>      <span class="hljs-attr">&quot;16&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;icons/ic_16.png&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 扩展管理页面、地址栏图标等</span><br>      <span class="hljs-attr">&quot;48&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;icons/ic_48.png&quot;</span>  <span class="hljs-comment">// 扩展详情页</span><br>   <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 扩展的公钥（用于标识扩展的唯一性，通常由浏览器自动生成，发布到应用商店时需要）</span><br>   <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwE/GAGNbengnDoGO4v5onC9CSpzyZm/i33QPKOxVw1OLY2cmqJgcX/t5NnWw7AzQchfwoB35+XqwJcaqkTLNNnM53FsrX938xqONasC17Be+Tih41jAjCkAnQWtokZxFv23vChuCOSlUmKHmwRLtag0/rJTbZvUED29irrZVDX0cedqhNFZlTJ/Sk9WDr26pl56cgMNxaVXB3vhpP7CHNb5C3yAHVJUPOOhxk2LAavb+sjSUXS8Q4DMBz2pAIYOoUAdrweuhU48pFU0RrzqgMtZxpnz15Sd26yk0FeIndKM+FFV5n7lV5C1q3DihHkxBCdnEgEmjdG3Hq4n+1UklGwIDAQAB&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;manifest_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Turbo Email Extractor&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">      声明扩展需要的功能权限</span><br><span class="hljs-comment">      tabs：允许操作浏览器标签页（如获取标签信息）</span><br><span class="hljs-comment">      activeTab：仅允许访问当前激活的标签页（临时权限，提高安全性）</span><br><span class="hljs-comment">      storage：允许使用浏览器的本地存储（chrome.storage）保存数据（如提取的邮件）</span><br><span class="hljs-comment">      background：允许访问背景服务（与 background 配置配合）</span><br><span class="hljs-comment">      webRequest：允许监听和拦截网页请求（可能用于从网络请求中提取邮件）</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-attr">&quot;permissions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;tabs&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;activeTab&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;storage&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;background&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;webRequest&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 扩展的自动更新地址（Chrome 扩展商店的标准更新接口）</span><br>   <span class="hljs-attr">&quot;update_url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://clients2.google.com/service/update2/crx&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.1&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 声明允许网页（而非扩展自身）访问的扩展资源</span><br>   <span class="hljs-attr">&quot;web_accessible_resources&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;matches&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;\u003Call_urls&gt;&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 允许哪些网页访问这些资源，&lt;all_urls&gt; 表示所有网页均可访问</span><br>      <span class="hljs-attr">&quot;resources&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;images/*&quot;</span> <span class="hljs-punctuation">]</span>  <span class="hljs-comment">// resources: 允许访问的资源路径（images/* 表示 images 目录下的所有文件，如图标、图片等）</span><br>   <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>代码理解</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
