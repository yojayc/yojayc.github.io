<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript笔记-类</title>
    <link href="/2025/10/26/JavaScript%E7%AC%94%E8%AE%B0-%E7%B1%BB/"/>
    <url>/2025/10/26/JavaScript%E7%AC%94%E8%AE%B0-%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p><code>ECMAScript 6</code> 引入的 <code>class</code> 关键字具有正式定义类的能力，但<mark>实际上使用的仍然是原型和构造函数的概念<mark></p><h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><p>有两种主要方式定义类：类声明和类表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 类声明</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><br><span class="hljs-comment">// 类表达式</span><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Animal</span> = <span class="hljs-keyword">class</span> &#123;&#125;;<br></code></pre></td></tr></table></figure><ul><li><p>函数表达式和类表达式在求值前都不能引用</p></li><li><p>类定义不能提升，但函数定义可以</p></li><li><p>函数受<strong>函数作用域</strong>限制，类受<strong>块作用域</strong>限制</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">FunctionDeclaration</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassDeclaration</span> &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// [Function: FunctionDeclaration]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">FunctionDeclaration</span>);<br><span class="hljs-comment">// ReferenceError: ClassDeclaration is not defined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">ClassDeclaration</span>);<br></code></pre></td></tr></table></figure><ul><li><p>类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但<mark>都不是必须的<mark></p></li><li><p>空的类定义同样有效</p></li><li><p>默认情况下，类定义中的代码都在严格模式下执行</p></li><li><p><mark>类名的首字母大写<mark>，以区别于通过它创建的实例</p></li><li><p><mark>类表达式的名称是可选的<mark>。把类表达式赋值给变量后，可以<mark>通过 <code>name</code> 属性取得类表达式的名称字符串<mark>，但<mark>不能在类表达式作用域外访问该标识符<mark></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Person</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonName</span> &#123;<br>    <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">name</span>, <span class="hljs-title class_">PersonName</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>p.<span class="hljs-title function_">identify</span>();  <span class="hljs-comment">// PersonName PersonName</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// PersonName</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">PersonName</span>);  <span class="hljs-comment">// ReferenceError: PersonName is not defined</span><br></code></pre></td></tr></table></figure><h2 id="类构造函数"><a href="#类构造函数" class="headerlink" title="类构造函数"></a>类构造函数</h2><ul><li><p><code>constructor</code> 关键字用于在类定义块内部创建类的构造函数</p></li><li><p><code>constructor</code> 会告诉解释器在使用 <code>new</code> 操作符创建类的新实例时，调用该函数</p></li><li><p>不定义构造函数相当于将构造函数定义为<strong>空函数</strong></p></li></ul><h3 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h3><p>使用 <code>new</code> 调用类的构造函数会执行<a href="../../22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">创建对象</a>的过程</p><p>类实例化时传入的参数会用作构造函数的参数</p><p>默认情况下，类构造函数会在执行后返回 <code>this</code> 对象，被用作实例化的对象</p><p>如果返回的不是 <code>this</code> 对象，而是其他对象，对这个对象使用 <code>instanceof</code> 操作符返回结果为 <code>false</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">override</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span> = <span class="hljs-string">&#x27;foo&#x27;</span>;<br><br>        <span class="hljs-keyword">if</span>(override) &#123;<br>            <span class="hljs-comment">// 返回的不是 this 对象</span><br>            <span class="hljs-keyword">return</span> &#123;<br>                <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bar&#x27;</span><br>            &#125;;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(),<br>    <span class="hljs-comment">// 未返回 this 对象，p2 的原型指针没有被修改</span><br>    p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1);  <span class="hljs-comment">// Person &#123; foo: &#x27;foo&#x27; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> p1);  <span class="hljs-comment">// object</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2);  <span class="hljs-comment">// &#123; bar: &#x27;bar&#x27; &#125;</span><br><span class="hljs-comment">// 无法通过 instanceof 操作符检测出跟类有关联</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> p2);  <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure><p>调用类构造函数必须使用 <code>new</code> 操作符，不使用 <code>new</code> 会抛出错误</p><p>普通构造函数如果不使用 <code>new</code> 调用，就会以全局的 <code>this</code>（通常是 <code>window</code>）作为内部对象</p><p>实例化后，类构造函数会成为普通的实例方法（仍需使用 <code>new</code> 调用），可以在实例上引用它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-comment">// TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;</span><br><span class="hljs-comment">// p1.constructor();</span><br><br><span class="hljs-comment">// 使用类构造函数的引用创建一个新实例</span><br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> p1.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>);<br></code></pre></td></tr></table></figure><h3 id="把类当成特殊函数"><a href="#把类当成特殊函数" class="headerlink" title="把类当成特殊函数"></a>把类当成特殊函数</h3><p><code>ECMAScript</code> 类是一种特殊的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// [class Person]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// function</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);  <span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-comment">// 类标识符的 prototype 属性有一个 constructor 属性指向类自身</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>类中定义的 <code>constructor</code> 方法<strong>不会</strong>被当成构造函数，对它使用 <code>instanceof</code> 操作符返回 <code>false</code>。如果在创建实例时直接<mark>将类构造函数当成普通构造函数<mark>，<code>instanceof</code> 操作符的返回值会<strong>反转</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>.<span class="hljs-property">constructor</span>);  <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 直接将类构造函数当成普通构造函数使用</span><br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>.<span class="hljs-property">constructor</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>类可以像其他对象或函数引用一样作为参数传递</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 类可以像函数一样在任何地方定义，比如数组中</span><br><span class="hljs-keyword">let</span> classList = [<br>    <span class="hljs-keyword">class</span> &#123;<br>        <span class="hljs-title function_">constructor</span>(<span class="hljs-params">id</span>) &#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">id_</span> = id;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`instance <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.id_&#125;</span>`</span>);<br>        &#125;<br>    &#125;<br>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createInstance</span>(<span class="hljs-params">classDefinition, id</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">classDefinition</span>(id);<br>&#125;<br><br><span class="hljs-comment">// classList[0] 是作为参数传递的类</span><br><span class="hljs-keyword">let</span> foo = <span class="hljs-title function_">createInstance</span>(classList[<span class="hljs-number">0</span>], <span class="hljs-number">3141</span>);  <span class="hljs-comment">// instance 3141</span><br></code></pre></td></tr></table></figure><p>类可以像立即调用函数表达式一样立即实例化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 类表达式的类名是可选的</span><br><span class="hljs-comment">// let p = new class Foo &#123;</span><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-keyword">class</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>    &#125;<br>&#125;(<span class="hljs-string">&#x27;bar&#x27;</span>);  <span class="hljs-comment">// bar</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);  <span class="hljs-comment">// Foo &#123;&#125;</span><br></code></pre></td></tr></table></figure><h2 id="实例、原型和类成员"><a href="#实例、原型和类成员" class="headerlink" title="实例、原型和类成员"></a>实例、原型和类成员</h2><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>在构造函数内部，可以为新创建的实例（<code>this</code>）添加“自有”属性。构造函数执行完也可以给实例继续添加新成员</p><p><mark>每个实例都对应一个唯一的成员对象，所有成员都不会在原型上共享<mark></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 为新创建的实例(this)添加&quot;自有&quot;属性</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;Jack&#x27;</span>);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            箭头函数，调用时会打印 this.name</span><br><span class="hljs-comment">            箭头函数没有自己的 this，它的 this 继承自定义时所在的上下文（即构造函数执行时的 this）</span><br><span class="hljs-comment">            箭头函数的 this 始终绑定创建时的实例，而普通函数的 this 会随调用方式变化</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">nicknames</span> = [<span class="hljs-string">&#x27;Jake&#x27;</span>, <span class="hljs-string">&#x27;J-Dog&#x27;</span>]<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 每个实例都对应一个唯一的成员对象，所有成员都不会在原型上共享</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(),<br>    p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>p1.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// [String: &#x27;Jack&#x27;]</span><br>p2.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// [String: &#x27;Jack&#x27;]</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">name</span> === p2.<span class="hljs-property">name</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">sayName</span> === p2.<span class="hljs-property">sayName</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-property">nicknames</span> === p2.<span class="hljs-property">nicknames</span>);  <span class="hljs-comment">// false</span><br><br>p1.<span class="hljs-property">name</span> = p1.<span class="hljs-property">nicknames</span>[<span class="hljs-number">0</span>];<br>p2.<span class="hljs-property">name</span> = p2.<span class="hljs-property">nicknames</span>[<span class="hljs-number">1</span>];<br><br>p1.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Jake</span><br>p2.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// J-Dog</span><br></code></pre></td></tr></table></figure><h3 id="原型方法与访问器"><a href="#原型方法与访问器" class="headerlink" title="原型方法与访问器"></a>原型方法与访问器</h3><ul><li><p>类体内直接声明的方法会自动绑定到原型对象上，无需手动操作 prototype</p></li><li><p>可以把<strong>方法</strong>定义在类构造函数或类块中，不能在类块中给原型添加<strong>原始值或对象</strong>作为成员数据</p></li><li><p>可以使用字符串、符号或计算的值作为类方法的键</p></li><li><p>类定义支持获取和设置访问器</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> symbolKey = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;symbolKey&#x27;</span>);<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-comment">// 不能在类块中给原型添加原始值或对象作为成员数据</span><br><span class="hljs-comment">// name: &#x27;Jake&#x27;  // SyntaxError: Unexpected identifier &#x27;name&#x27;</span><br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 添加到 this 的所有内容会存在于不同的实例</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">locate</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;instance&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 在类块中定义的所有内容都会定义在类的原型上</span><br>    <span class="hljs-title function_">locate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;prototype&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-title function_">stringKey</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;invoked stringKey&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 使用符号作为键</span><br>    [symbolKey]() &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;invoked symbolKey&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 使用计算的值作为键</span><br>    [<span class="hljs-string">&#x27;computed&#x27;</span> + <span class="hljs-string">&#x27;Key&#x27;</span>]() &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;invoked computedKey&#x27;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 设置访问器</span><br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">name</span>(<span class="hljs-params">newName</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span> = newName;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取访问器</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">name</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name_</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>p.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// instance</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// prototype</span><br><br>p.<span class="hljs-title function_">stringKey</span>();  <span class="hljs-comment">// invoked stringKey</span><br>p[symbolKey]();  <span class="hljs-comment">// invoked symbolKey</span><br>p.<span class="hljs-title function_">computedKey</span>();  <span class="hljs-comment">// invoked computedKey</span><br><br>p.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Jake&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Jake</span><br></code></pre></td></tr></table></figure><h3 id="静态类方法"><a href="#静态类方法" class="headerlink" title="静态类方法"></a>静态类方法</h3><p>静态方法通常用于执行不特定于实例的操作，也不要求存在类的实例，<strong>每个类只能有一个静态成员</strong>（类级别的属性）</p><p>静态类成员在类定义中使用 <code>static</code> 关键字作为前缀，使用 <code>this</code> 引用类自身</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 添加到 this 的所有内容都会存在于不同的实例上</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">locate</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;instance&#x27;</span>, <span class="hljs-variable language_">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义在类的原型对象上</span><br>    <span class="hljs-title function_">locate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;prototype&#x27;</span>, <span class="hljs-variable language_">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义在类本身上</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">locate</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-variable language_">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>p.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// instance Person &#123; locate: [Function (anonymous)] &#125;</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// prototype &#123;&#125;</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">locate</span>();  <span class="hljs-comment">// class [class Person]</span><br></code></pre></td></tr></table></figure><p>静态类方法适合作为实例工厂</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">age</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">age_</span> = age;<br>    &#125;<br><br>    <span class="hljs-comment">// sayAge() 没有 return 语句，默认返回 undefined</span><br>    <span class="hljs-comment">// 类实例调用 sayAge() 时会先打印年龄，再打印返回的年龄值</span><br>    <span class="hljs-title function_">sayAge</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age_</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 定义在类本身上</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">create</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 使用随机年龄创建并返回一个 Person 实例</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()*<span class="hljs-number">100</span>));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Person &#123; age_: 83 &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-title function_">create</span>());<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">29</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    29</span><br><span class="hljs-comment">    undefined</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1.<span class="hljs-title function_">sayAge</span>());<br></code></pre></td></tr></table></figure><h3 id="非函数原型和类成员"><a href="#非函数原型和类成员" class="headerlink" title="非函数原型和类成员"></a>非函数原型和类成员</h3><p><code>ECMAScript 2022</code> 允许直接在类体中定义数据成员，无需在 <code>constructor</code> 中定义</p><p>在类定义外部，可以在原型或类上手动添加成员数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-comment">// ES2022 允许直接在类体中定义数据成员，无需在 constructor 中定义</span><br>    age = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) &#123;<br>        <span class="hljs-comment">// 在构造函数中通过 this 定义数据成员</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>        <span class="hljs-comment">// this.age = age;</span><br>    &#125;<br><br>    <span class="hljs-title function_">sayJob</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;Person.greeting&#125;</span> <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>.job&#125;</span>`</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Alice</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">age</span>);  <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// 在类定义外部手动添加成员数据</span><br><span class="hljs-comment">// 在类上定义数据成员</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property">greeting</span> = <span class="hljs-string">&#x27;My job is&#x27;</span>;<br><span class="hljs-comment">// 在原型上定义数据成员</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&#x27;Software Engineer&#x27;</span>;<br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Jake&#x27;</span>);<br>p1.<span class="hljs-title function_">sayJob</span>();  <span class="hljs-comment">// My job is Software Engineer</span><br></code></pre></td></tr></table></figure><h3 id="迭代器与生成器方法"><a href="#迭代器与生成器方法" class="headerlink" title="迭代器与生成器方法"></a>迭代器与生成器方法</h3><p>类定义语法支持在原型和类本身上定义生成器方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">nicknames</span> = [<span class="hljs-string">&#x27;cJack&#x27;</span>, <span class="hljs-string">&#x27;cJake&#x27;</span>, <span class="hljs-string">&#x27;cJ-Dog&#x27;</span>];<br>    &#125;<br><br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    添加一个默认的迭代器，把类实例变成可迭代对象</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    方法名前的 * 表示这是一个 生成器函数</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    [Symbol.iterator] 是一个特殊的 内置 Symbol 属性，当一个对象定义了该方法时，就表示它是 “可迭代的”</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    yield* 是 Generator 函数中的语法，用于 “委托” 另一个可迭代对象的迭代过程。它会自动遍历被委托的对象，并逐个返回其迭代结果</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    *[Symbol.iterator]() &#123;</span><br><span class="hljs-comment">        yield *this.nicknames.entries();</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    entries() 方法会返回一个数组迭代器对象，用于遍历其 “键值对”</span><br><span class="hljs-comment">    */</span><br><br>    <span class="hljs-comment">// 只返回迭代器实例效果与返回可迭代对象相同</span><br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">nicknames</span>.<span class="hljs-title function_">entries</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 在原型上定义生成器方法</span><br>    *<span class="hljs-title function_">creatNicknameIterator</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Jack&#x27;</span>;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Jake&#x27;</span>;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;J-Dog&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 在类上定义生成器方法</span><br>    <span class="hljs-keyword">static</span> *<span class="hljs-title function_">createJobIterator</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Butcher&#x27;</span>;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Baker&#x27;</span>;<br>        <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Candlestick maker&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> jobIter = <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">createJobIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jobIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Butcher</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jobIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Baker</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(jobIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Candlestick maker</span><br><br><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">let</span> nicknameIter = p.<span class="hljs-title function_">creatNicknameIterator</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nicknameIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Jack</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nicknameIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// Jake</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nicknameIter.<span class="hljs-title function_">next</span>().<span class="hljs-property">value</span>);  <span class="hljs-comment">// J-Dog</span><br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> [idx, nickname] <span class="hljs-keyword">of</span> p) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        cJack</span><br><span class="hljs-comment">        cJake</span><br><span class="hljs-comment">        cJ-Dog</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(nickname);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p><code>ECMAScript 6</code> 原生支持类继承机制，但<mark>背后依旧使用原型链<mark></p><h3 id="继承基础"><a href="#继承基础" class="headerlink" title="继承基础"></a>继承基础</h3><p><code>ES6</code> 支持<strong>单继承</strong>。使用 <code>extends</code> 关键字，可以继承任何拥有 <strong><code>[[Construct]]</code></strong> 和<strong>原型</strong>的对象。不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-params">id</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id, <span class="hljs-variable language_">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">identifyClass</span>(<span class="hljs-params">id</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(id, <span class="hljs-variable language_">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 继承类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;&#125;<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Bus</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Vehicle</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">let</span> v = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>();<br><br><span class="hljs-comment">// 派生类通过原型链访问类和原型上定义的方法</span><br>b.<span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-string">&#x27;bus&#x27;</span>);  <span class="hljs-comment">// bus, Bus &#123;&#125;</span><br>v.<span class="hljs-title function_">identifyPrototype</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>);  <span class="hljs-comment">// vehicle, Vehicle &#123;&#125;</span><br><br><span class="hljs-title class_">Bus</span>.<span class="hljs-title function_">identifyClass</span>(<span class="hljs-string">&#x27;bus&#x27;</span>);  <span class="hljs-comment">// bus [class Bus extends Vehicle]</span><br><span class="hljs-title class_">Vehicle</span>.<span class="hljs-title function_">identifyClass</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>);  <span class="hljs-comment">// vehicle [class Vehicle]</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engineer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;&#125;<br><br><span class="hljs-keyword">let</span> e = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Engineer</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Engineer</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// extends 也可以在类表达式中使用</span><br><span class="hljs-keyword">let</span> <span class="hljs-title class_">Bar</span> = <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Foo</span> &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="构造函数、HomeObject-和-super"><a href="#构造函数、HomeObject-和-super" class="headerlink" title="构造函数、HomeObject 和 super()"></a>构造函数、HomeObject 和 super()</h3><p>可以使用 <code>super</code> 关键字引用派生类方法的原型</p><ul><li><p><code>super</code> 关键字只能在派生类中使用</p></li><li><p>仅限类构造函数、实例方法和静态方法内部使用</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">hasEngine</span> = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;vehicle&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 在调用 super() 之前引用 this 会报错</span><br>        <span class="hljs-comment">// ReferenceError: Must call super constructor in derived class before accessing &#x27;this&#x27; or returning from derived constructor</span><br>        <span class="hljs-variable language_">super</span>();  <span class="hljs-comment">// 相当于 super.constructor()</span><br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Vehicle</span>);  <span class="hljs-comment">// true</span><br>        <span class="hljs-comment">// 派生类的方法</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);  <span class="hljs-comment">// Bus &#123; hasEngine: true &#125;</span><br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-title function_">identify</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 静态方法中可以通过 super 调用父类的静态方法</span><br>        <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">identify</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    true</span><br><span class="hljs-comment">    Bus &#123; hasEngine: true &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>();<br><span class="hljs-title class_">Bus</span>.<span class="hljs-title function_">identify</span>();  <span class="hljs-comment">// vehicle</span><br></code></pre></td></tr></table></figure><ul><li><p><code>ES6</code> 给类构造函数和静态方法添加了内部指针 <code>[[HomeObject]]</code>（无法直接查看），指向定义该方法的对象。</p></li><li><p>该指针自动赋值，<code>[[HomeObject]]</code> 的原型始终定义为 <code>super</code></p></li></ul><br><p>使用 <code>super</code> 注意事项：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">licensePlate</span>) &#123;<br>        <span class="hljs-comment">// super 只能在 派生类 构造函数和静态方法中使用</span><br>        <span class="hljs-comment">// super();  // SyntaxError: &#x27;super&#x27; keyword unexpected here</span><br><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">licensePlate</span> = licensePlate;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">licensePlate</span>) &#123;<br>        <span class="hljs-comment">// 不能单独引用 super 关键字</span><br>        <span class="hljs-comment">// 要么调用构造函数，要么引用静态方法</span><br>        <span class="hljs-comment">// console.log(super);  // SyntaxError: &#x27;super&#x27; keyword unexpected here</span><br><br>        <span class="hljs-comment">// 需要手动给父类构造函数传参</span><br>        <span class="hljs-variable language_">super</span>(licensePlate);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// super() 会调用父类构造函数，并将返回的实例赋值给 this</span><br>        <span class="hljs-variable language_">super</span>();<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Vehicle</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Van</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-comment">// 在派生类中显式定义构造函数，必须在其中调用 super() 或返回一个对象</span><br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// super();</span><br>        <span class="hljs-keyword">return</span> &#123;&#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 未定义类构造函数，实例化派生类时会调用父类构造函数，并传入所有传给派生类的参数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;&#125;<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus1</span>();  <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>(<span class="hljs-string">&#x27;1337H4X&#x27;</span>));  <span class="hljs-comment">// Bus &#123; licensePlate: &#x27;1337H4X&#x27; &#125;</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus2</span>(<span class="hljs-string">&#x27;1337H4X&#x27;</span>));  <span class="hljs-comment">// Bus2 &#123; licensePlate: &#x27;1337H4X&#x27; </span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Van</span>());  <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure><h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><p>通过在实例化时检测 <code>new.target</code>（<code>new.target</code> 保存通过 <code>new</code> 关键字调用的类或函数） 是不是抽象基类，可以阻止对抽象基类的实例化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 抽象基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span>);<br><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> === <span class="hljs-title class_">Vehicle</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!<span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Inheriting class must define foo()&#x27;</span>);<br>        &#125;<br><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;success!&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;<br>    <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><br><span class="hljs-comment">// 派生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Van</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vehicle</span> &#123;&#125;<br><br><span class="hljs-comment">// [class Bus extends Vehicle]</span><br><span class="hljs-comment">// success!</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>();<br><span class="hljs-comment">// [class Vehicle]</span><br><span class="hljs-comment">// Error: Vehicle cannot be directly instantiated</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>();<br></code></pre></td></tr></table></figure><h3 id="继承内置类型"><a href="#继承内置类型" class="headerlink" title="继承内置类型"></a>继承内置类型</h3><p>可以扩展内置类型，覆盖 <code>Symbol.species</code> 访问器（决定在创建返回实例时使用的类）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SuperArray</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Array</span> &#123;<br>    <span class="hljs-title function_">shuffle</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">const</span> j = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">floor</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>() * (i + <span class="hljs-number">1</span>));<br>            [<span class="hljs-variable language_">this</span>[i], <span class="hljs-variable language_">this</span>[j]] = [<span class="hljs-variable language_">this</span>[j], <span class="hljs-variable language_">this</span>[i]];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 默认返回 SuperArray 类实例</span><br>    <span class="hljs-comment">// 返回 Array 类实例</span><br>    <span class="hljs-keyword">static</span> get [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">species</span>]() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Array</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperArray</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SuperArray</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <span class="hljs-comment">// SuperArray(5) [ 1, 2, 3, 4, 5 ]</span><br>a.<span class="hljs-title function_">shuffle</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <span class="hljs-comment">// SuperArray(5) [ 1, 5, 3, 2, 4 ]</span><br><br><span class="hljs-keyword">let</span> a1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperArray</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    内置类型的方法会返回新实例</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    filter 用于根据条件筛选元素，返回一个新数组</span><br><span class="hljs-comment">    !! 是双重非运算符，用于将数值转为布尔类型</span><br><span class="hljs-comment">    第一个 ! 将数值转换为布尔值的反值</span><br><span class="hljs-comment">    第二个 ! 对第一步的结果取反，得到原 value 对应的真实布尔值</span><br><span class="hljs-comment">    条件等价于 &quot;x 是奇数&quot;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">let</span> a2 = a1.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !!(x%<span class="hljs-number">2</span>))<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a1);  <span class="hljs-comment">// SuperArray(5) [ 1, 2, 3, 4, 5 ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2);  <span class="hljs-comment">// [ 1, 3, 5 ]</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SuperArray</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SuperArray</span>);  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="多类继承"><a href="#多类继承" class="headerlink" title="多类继承"></a>多类继承</h3><p><code>ES6</code> 没有显式支持多类继承，但通过现有特性可<strong>模拟多类继承</strong></p><p>定义一组“可嵌套”的函数，每个函数分别接收一个超类（被其他类继承的 “父类”）作为参数，将<strong>混入类</strong>定义为该参数的子类，并返回这个类。可以<mark>连续调用组合函数，组成超类表达式<mark></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vehicle</span> &#123;&#125;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">FooMixin</span> = (<span class="hljs-params">Superclass</span>) =&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Superclass</span> &#123;<br>    <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">BarMixin</span> = (<span class="hljs-params">Superclass</span>) =&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Superclass</span> &#123;<br>    <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> <span class="hljs-title function_">BazMinxin</span> = (<span class="hljs-params">Superclass</span>) =&gt; <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> <span class="hljs-title class_">Superclass</span> &#123;<br>    <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;baz&#x27;</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 接收一个基础类 BaseClass 和任意数量的混入类 Mixins，返回一个融合了所有混入类功能的新类</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mix</span>(<span class="hljs-params">BaseClass, ...Mixins</span>) &#123;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">        使用 reduce 迭代 Mixins 数组，将每个混入类依次应用到累积结果上</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        reduce 是 JavaScript 数组的一个高阶函数，用于将数组元素 “累积” 为单个值（也可用于复杂的数组转换）</span><br><span class="hljs-comment">        它通过迭代数组，对每个元素执行回调函数，并将结果传递给下一次迭代，最终得到一个汇总结果</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        迭代过程：</span><br><span class="hljs-comment">        每个 current（当前混入类）是一个函数，它接收上一步的 accumulator（累积的类）作为参数</span><br><span class="hljs-comment">        返回一个继承自 accumulator 并添加了自身功能的新类</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Mixins</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">accumulator, current</span>) =&gt;</span><br>        <span class="hljs-title function_">current</span>(accumulator),  <span class="hljs-comment">// 当前混入类接收累积类作为参数，返回新的融合类</span><br>        <span class="hljs-title class_">BaseClass</span>);  <span class="hljs-comment">// 初始值：从基础类开始</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">FooMixin</span>(<span class="hljs-title class_">BarMixin</span>(<span class="hljs-title class_">BazMinxin</span>(<span class="hljs-title class_">Vehicle</span>))) &#123;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bus1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">mix</span>(<span class="hljs-title class_">Vehicle</span>, <span class="hljs-title class_">FooMixin</span>, <span class="hljs-title class_">BarMixin</span>, <span class="hljs-title class_">BazMinxin</span>) &#123;&#125;<br><br><span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bus</span>();  <span class="hljs-comment">// 与 let b = new Bus1(); 结果相同</span><br>b.<span class="hljs-title function_">foo</span>();  <span class="hljs-comment">// foo</span><br>b.<span class="hljs-title function_">bar</span>();  <span class="hljs-comment">// bar</span><br>b.<span class="hljs-title function_">baz</span>();  <span class="hljs-comment">// baz</span><br></code></pre></td></tr></table></figure><blockquote><p>很多 <code>JavaScript</code> 框架（<code>React</code>）已抛弃混入模式，转向组合模式（把方法提取到独立的类和辅助对象，再把它们组合起来，但不使用继承）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-继承</title>
    <link href="/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/"/>
    <url>/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<p>很多面向对象语言都支持<strong>接口继承</strong>和<strong>实现继承</strong>。前者只继承<strong>方法签名</strong>，后者继承<strong>实际的方法</strong>。</p><p><code>ECMAScript</code> 中的函数没有签名，所以<strong>只支持实现继承</strong>，并且通过原型链实现。</p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>原型链的基本思想是<mark>通过原型继承多个引用类型的属性和方法<mark>，在实例和原型之间构造一条原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 实例属性</span><br>&#125;<br><br><span class="hljs-comment">// 原型方法</span><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSuperValue</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span>;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SubType 通过创建 SuperType 的实例并将其赋值给自己的原型实现对 SuperType 的继承</span><br><span class="hljs-comment">    SuperType 实例可以访问的所有属性和方法也会存在于 SubType.prototype</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    SubType.prototype 现在是 SuperType 的一个实例</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();<br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSubValue</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span>;<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getSuperValue</span>());  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><br><p><img src="/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/SubType_SuperType.png" alt="原型之间的关系"><br><br></p><blockquote><p>在读取实例上的属性时，首先在实例上搜索这个属性。如果没找到，则会继承搜索实例的原型</p><p>通过原型链实现继承后，可以继承向上搜索，搜索原型的原型</p><p>对属性和方法的搜索会一直持续到原型链的末端</p></blockquote><p>调用 <code>instance.getSuperValue()</code> 的搜索过程:<br><code>instance</code> -&gt; <code>SubType.prototype</code> -&gt; <code>SuperType.prototype</code> -&gt; <code>SuperType.getSuperValue()</code></p><h3 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h3><p>默认情况下，<mark>所有引用类型<mark>都继承自 <code>Object</code></p><ul><li><p><mark>任何函数<mark>的默认原型都是一个 <code>Object</code> 的实例</p></li><li><p>该实例有一个内部值针指向 <code>Object.prototype</code></p></li><li><p>自定义类型能够继承包括 <code>toString()</code>、<code>valueOf()</code> 在内的所有默认方法</p></li></ul><p><img src="/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/prototypeChain.png" alt="完整的继承原型链"></p><p>调用 <code>instance.toString()</code> 时，实际上调用的是保存在 <code>Object.prototype</code> 上的方法</p><h3 id="原型与继承关系"><a href="#原型与继承关系" class="headerlink" title="原型与继承关系"></a>原型与继承关系</h3><ul><li><p>如果一个实例的原型链中出现过相应的构造函数，则 <code>instanceof</code> 返回 <code>true</code></p></li><li><p>只要原型链中包含对应的原型，<code>isPrototypeOf()</code> 就返回 <code>true</code></p></li></ul><p>接<a href="#%E5%8E%9F%E5%9E%8B%E9%93%BE">前面代码</a>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SuperType</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">SubType</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(instance));  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(instance));  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(instance));  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>子类覆盖父类的方法，或者增加父类没有的方法必须<strong>在原型赋值之后再加到原型上</strong></p><p>以<strong>对象字面量</strong>方式创建原型方法会破坏之前的原型链</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSuperValue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span>;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 继承 SuperType</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// 在原型赋值之后将方法加到原型上</span><br><span class="hljs-comment">// 新方法</span><br><span class="hljs-comment">SubType.prototype.getSubValue = function () &#123;</span><br><span class="hljs-comment">    return this.subproperty;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// 覆盖已有的方法</span><br><span class="hljs-comment">SubType.prototype.getSuperValue = function () &#123;</span><br><span class="hljs-comment">    return false;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">let instance = new SubType();</span><br><span class="hljs-comment">console.log(instance.getSuperValue());  // false</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 通过对象字面量添加新方法，导致 SubType.prototype = new SuperType() 无效</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-title function_">getSubValue</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span>;<br>    &#125;,<br><br>    <span class="hljs-title function_">someOtherMethod</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-comment">// TypeError: instance.getSuperValue is not a function</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getSuperValue</span>());<br></code></pre></td></tr></table></figure><p>以<strong>对象字面量</strong>覆盖后的原型是一个 <code>Object</code> 的实例，不再是 <code>SuperType</code> 的实例。之前的原型链断开，<code>SubType</code> 和 <code>SuperType</code> 之间没关系了</p><h3 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><ul><li><p>原型中包含的引用值会在所有实例间共享</p></li><li><p>使用原型实现继承时，原型实际上变成了另一个类型的实例，表明原先的实例属性变成了原型属性</p></li><li><p>子类型在实例化时不能给父类型的构造函数传参</p></li></ul><h2 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h2><ul><li><p>若原型中的属性是<strong>基本类型</strong>（数字、字符串），实例修改时会<mark>在自身创建同名属性<mark>，不影响原型和其它实例</p></li><li><p>若原型中的属性是<strong>引用类型</strong>（数组、对象），实例修改时会<mark>直接操作原型中的引用值<mark>（实例本身没有该属性，会顺着原型链找到原型），导致<strong>所有实例的该属性被同时修改</strong></p></li></ul><p>为解决原型包含<strong>引用值</strong>导致的继承问题，<mark>在子类构造函数中调用父类构造函数<mark>，使用 <code>apply()</code> 和 <code>call()</code> 方法<strong>以新创建的对象为上下文执行构造函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">        继承 SuperType</span><br><span class="hljs-comment">        相当于新的 SubType 对象上运行了 SuperType() 函数中的所有初始化代码</span><br><span class="hljs-comment">        每个实例都会有自己的 colors 属性</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-comment">// [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1.<span class="hljs-property">colors</span>);<br><br><span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-comment">// [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance2.<span class="hljs-property">colors</span>);<br><br></code></pre></td></tr></table></figure><h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>盗用构造函数可以在子类构造函数中向父类构造函数传参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 继承 SuperType 并传参</span><br>    <span class="hljs-comment">// 实际上会在 SubType 的实例上定义 name 属性</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">&quot;Nicholas&quot;</span>);<br><br>    <span class="hljs-comment">// 为确保 SuperType 构造函数不会覆盖 SubType 定义的属性</span><br>    <span class="hljs-comment">// 可以在调用父类构造函数之后再给子类实例添加额外的属性</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;  <span class="hljs-comment">// 实例属性</span><br>&#125;<br><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Nicholas</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-property">age</span>);  <span class="hljs-comment">// 29</span><br></code></pre></td></tr></table></figure><h3 id="盗用构造函数的问题"><a href="#盗用构造函数的问题" class="headerlink" title="盗用构造函数的问题"></a>盗用构造函数的问题</h3><ul><li><p>必须在构造函数中定义方法，函数不能重用</p></li><li><p>子类不能访问父类原型上定义的方法，所有类型只能使用构造函数模式</p></li></ul><h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><p>组合继承综合了原型链和盗用构造函数，使用<strong>原型链</strong>继承原型上的<strong>属性和方法</strong>（共享原型方法），通过<strong>盗用构造函数</strong>继承<strong>实例属性</strong>（避免引用值共享）。既可以把方法定义在原型上实现重用，又可以让每个实例都有自己的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-comment">// 继承属性</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);  <span class="hljs-comment">// 子类构造函数，第二次调用 SuperType()</span><br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-comment">// 继承方法</span><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();  <span class="hljs-comment">// 创建子类原型，第一次调用 SuperType()</span><br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>);<br>instance1.<span class="hljs-property">colors</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;black&quot;</span>);<br><span class="hljs-comment">// [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1.<span class="hljs-property">colors</span>);<br><span class="hljs-comment">// Nicholas</span><br>instance1.<span class="hljs-title function_">sayName</span>();<br><span class="hljs-comment">// 29</span><br>instance1.<span class="hljs-title function_">sayAge</span>();<br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SuperType &#123;</span><br><span class="hljs-comment">      name: &#x27;Nicholas&#x27;,</span><br><span class="hljs-comment">      colors: [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;black&#x27; ],</span><br><span class="hljs-comment">      age: 29</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance1);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SuperType &#123;</span><br><span class="hljs-comment">      name: undefined,</span><br><span class="hljs-comment">      colors: [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ],</span><br><span class="hljs-comment">      sayAge: [Function (anonymous)]</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><br><span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>);<br><span class="hljs-comment">// [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance2.<span class="hljs-property">colors</span>);<br><span class="hljs-comment">// Greg</span><br>instance2.<span class="hljs-title function_">sayName</span>();<br><span class="hljs-comment">// 27</span><br>instance2.<span class="hljs-title function_">sayAge</span>();<br></code></pre></td></tr></table></figure><blockquote><p><strong>组合继承是 <code>JavaScript</code> 中使用最多的继承模式</strong></p><p>组合继承保留了 <code>instanceof</code> 操作符和 <code>isPrototypeOf()</code> 方法识别合成对象的能力</p></blockquote><p>但是，组合继承存在<strong>效率问题</strong>，<mark>父类构造函数始终会被调用两次<mark>：</p><ol><li><p>在创建子类原型时调用一次</p></li><li><p>在子类构造函数中调用一次</p></li></ol><p><img src="/2025/10/25/JavaScript-%E7%AC%94%E8%AE%B0-%E7%BB%A7%E6%89%BF/combined_heritage.png" alt="组合继承"></p><p>由于调用了两次 <code>SuperType</code> 构造函数，所以有两组 <code>name</code> 和 <code>colors</code> 属性：一组在实例上，另一组在 <code>SubType</code> 的原型上</p><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>原型式继承适用于：</p><ul><li><p>在已有对象基础上再创建一个新对象</p></li><li><p>不需要单独创建构造函数，但仍然需要在对象间共享信息的场合</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// object() 函数会创建一个临时构造函数</span><br><span class="hljs-comment">// 将传入的对象赋值给这个构造函数的原型</span><br><span class="hljs-comment">// 本质上，object() 对传入的对象执行了一次浅复制</span><br><span class="hljs-comment">function object(o) &#123;</span><br><span class="hljs-comment">    function F() &#123;&#125;</span><br><span class="hljs-comment">    F.prototype = o;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    // 返回临时类型的一个实例</span><br><span class="hljs-comment">    return new F();</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">let person = &#123;</span><br><span class="hljs-comment">    name: &quot;Nicholas&quot;,</span><br><span class="hljs-comment">    friends: [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">let anotherPerson = object(person);</span><br><span class="hljs-comment">anotherPerson.name = &quot;Greg&quot;;</span><br><span class="hljs-comment">anotherPerson.friends.push(&quot;Rob&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">let yetAnotherPerson = object(person);</span><br><span class="hljs-comment">yetAnotherPerson.name = &quot;Linda&quot;;</span><br><span class="hljs-comment">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">// [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27; ]</span><br><span class="hljs-comment">console.log(person.friends);</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>, <span class="hljs-string">&quot;Van&quot;</span>]<br>&#125;;<br><br><span class="hljs-comment">// ECMASCript 通过 Object.create() 方法将原型式继承的概念规范化</span><br><span class="hljs-keyword">let</span> anotherPerson = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(person);<br>anotherPerson.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Greg&quot;</span>;<br>anotherPerson.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Rob&quot;</span>);<br><br><span class="hljs-keyword">let</span> yetAnotherPerson = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(person);<br>yetAnotherPerson.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Linda&quot;</span>;<br>yetAnotherPerson.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Barbie&quot;</span>);<br><br><span class="hljs-comment">// [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27;, &#x27;Rob&#x27;, &#x27;Barbie&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">friends</span>);<br></code></pre></td></tr></table></figure><h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>寄生式继承类似寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 可将 object() 函数替换为任何返回新对象的函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">object</span>(<span class="hljs-params">o</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;<br><br>    <span class="hljs-comment">// 返回临时类型的一个实例</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br><br><span class="hljs-comment">// 函数参数为新对象的基准对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createAnother</span>(<span class="hljs-params">original</span>) &#123;<br>    <span class="hljs-comment">// 通过调用函数创建一个新对象</span><br>    <span class="hljs-keyword">let</span> clone = <span class="hljs-title function_">object</span>(original);<br><br>    <span class="hljs-comment">// 给 clone 对象添加一个新方法（以某种方式增强对象）</span><br>    clone.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>    &#125;;<br><br>    <span class="hljs-comment">// 返回这个对象</span><br>    <span class="hljs-keyword">return</span> clone;<br>&#125;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>, <span class="hljs-string">&quot;Van&quot;</span>]<br>&#125;;<br><br><span class="hljs-keyword">let</span> anotherPerson = <span class="hljs-title function_">createAnother</span>(person);<br>anotherPerson.<span class="hljs-title function_">sayHi</span>();<br></code></pre></td></tr></table></figure><blockquote><p>寄生式继承适合主要关注对象，不在乎类型和构造函数的场景</p><p>通过寄生式继承给对象添加函数会导致函数难以重用</p></blockquote><h2 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h2><p>寄生式组合继承<mark>通过盗用构造函数继承属性，但使用<strong>混合式原型链</strong>继承方法<mark>（使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型）解决<a href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF">组合继承</a>的<strong>效率问题</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">object</span>(<span class="hljs-params">o</span>) &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">F</span>(<span class="hljs-params"></span>) &#123;&#125;<br>    F.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = o;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>&#125;<br><br><span class="hljs-comment">// 函数接收子类构造函数和父类构造函数作为参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-params">subType, superType</span>) &#123;<br>    <span class="hljs-comment">// 创建父类原型的副本</span><br>    <span class="hljs-keyword">let</span> prototype = <span class="hljs-title function_">object</span>(superType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>    <span class="hljs-comment">// 给返回的 prototype 对象设置 constructor 属性</span><br>    <span class="hljs-comment">// 解决重写原型导致默认 constructor 丢失问题</span><br>    prototype.<span class="hljs-property">constructor</span> = subType;<br>    <span class="hljs-comment">// 将新创建的对象赋值给子类的原型</span><br>    subType.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = prototype;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">colors</span> = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>];<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params">name, age</span>) &#123;<br>    <span class="hljs-comment">// 只调用一次 SuperType 构造函数，避免属性重复</span><br>    <span class="hljs-title class_">SuperType</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, name);<br><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>&#125;<br><br><span class="hljs-title function_">inheritPrototype</span>(<span class="hljs-title class_">SubType</span>, <span class="hljs-title class_">SuperType</span>);<br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayAge</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SubType &#123;</span><br><span class="hljs-comment">      name: &#x27;Nicholas&#x27;,</span><br><span class="hljs-comment">      colors: [ &#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27; ],</span><br><span class="hljs-comment">      age: 29</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    SuperType &#123;</span><br><span class="hljs-comment">      constructor: [Function: SubType],</span><br><span class="hljs-comment">      sayAge: [Function (anonymous)]</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br></code></pre></td></tr></table></figure><blockquote><p>使用寄生式组合继承原型链保持不变，<code>instanceof()</code> 和 <code>isPrototypeOf()</code> 正常有效</p><p>寄生式组合继承是<strong>引用类型继承的最佳模式</strong></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-创建对象</title>
    <link href="/2025/10/22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <url>/2025/10/22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p><code>ECMAScript 6</code> 开始正式支持类和继承</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>按照惯例，构造函数名称的<strong>首字母</strong>都是<strong>大写</strong>的，非构造函数则以小写字母开头</p><p><strong><code>ECMAScript</code> 中的函数是对象</strong>，每次定义函数时，都会初始化一个对象</p><p>使用 <code>new</code> 操作符调用构造函数创建对象实例会执行如下操作：</p><blockquote><p>(1) 在内存中创建一个新对象</p><p>(2) 新对象内部的 <code>[[Protoype]]</code> 特性被赋值为构造函数的 <code>prototype</code> 属性</p><p>(3) 构造函数内部的 <code>this</code> 被赋值为这个新对象(即 <code>this</code> 指向新对象)</p><p>(4) 执行构造函数内部的代码(给新对象添加属性)</p><p>(5) 构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象</p></blockquote><h3 id="instanceof-操作符用于确定对象类型"><a href="#instanceof-操作符用于确定对象类型" class="headerlink" title="instanceof 操作符用于确定对象类型"></a><code>instanceof</code> 操作符用于确定对象类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数（Function）：是一种「可执行的对象」，它除了具备对象的所有特性（可存储属性、有原型等），还额外拥有「可调用性」（可以被执行，有参数和返回值）</span><br><span class="hljs-comment">// 函数是「能执行的对象」，对象是「函数创建的实例或数据集合」</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, job</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">job</span> = job;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Software Engineer&quot;</span>);<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&quot;Doctor&quot;</span>);<br><br><span class="hljs-comment">// Object 是所有对象的基类（原型链的顶端），几乎所有对象都直接或间接继承自 Object.prototype</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="实例化不传参数时，构造函数后面的括号可加可不加。只要有-new-操作符，就可以调用相应的构造函数"><a href="#实例化不传参数时，构造函数后面的括号可加可不加。只要有-new-操作符，就可以调用相应的构造函数" class="headerlink" title="实例化不传参数时，构造函数后面的括号可加可不加。只要有 new 操作符，就可以调用相应的构造函数"></a>实例化不传参数时，构造函数后面的括号可加可不加。只要有 <code>new</code> 操作符，就可以调用相应的构造函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Jake&quot;</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>;<br></code></pre></td></tr></table></figure><h3 id="构造函数也是函数"><a href="#构造函数也是函数" class="headerlink" title="构造函数也是函数"></a>构造函数也是函数</h3><ul><li><p>任何函数只要使用 <code>new</code> 操作符调用就是构造函数，而不使用 <code>new</code> 操作符调用的函数就是普通函数</p></li><li><p>没有使用 <code>new</code> 操作符调用构造函数，结果会将属性和方法添加到 <code>window</code> 对象</p></li><li><p>在调用一个函数没有明确设置 <code>this</code> 值(没有作为对象的方法调用，或没有使用 <code>call()/apply()</code> 调用)，<code>this</code> 始终指向 <code>Global</code> 对象(浏览器中为 <code>window</code> 对象)</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 只有浏览器环境中才有 window 对象</span><br><span class="hljs-comment">// 在 Node.js 环境中执行会报错 ReferenceError: window is not defined</span><br><span class="hljs-variable language_">window</span> = <span class="hljs-variable language_">global</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name, age, job</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> = age;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">job</span> = job;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;;<br>    <span class="hljs-comment">// 与 sayName 逻辑上等价</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">sayName1</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&quot;console.log(this.name)&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Nicholas&quot;</span>, <span class="hljs-number">29</span>, <span class="hljs-string">&quot;Software Engineer&quot;</span>);<br>person.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Nicholas</span><br><br><span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-number">27</span>, <span class="hljs-string">&quot;Doctor&quot;</span>);<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Greg</span><br><br><span class="hljs-keyword">let</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">    call() 是函数对象的一个方法，用于调用函数并指定函数执行时的 this 指向</span><br><span class="hljs-comment">    将对象 o 指定为 Person() 内部的 this 值</span><br><span class="hljs-comment">    所有属性和 sayName() 方法都会添加到对象 o</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-title function_">call</span>(o, <span class="hljs-string">&quot;Kristen&quot;</span>, <span class="hljs-number">25</span>, <span class="hljs-string">&quot;Nurse&quot;</span>);<br>o.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Kristen</span><br></code></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>每个函数都会创建一个 <code>prototype</code> 对象属性，包含应该由特定引用类型的实例共享的属性和方法</p><p>当通过构造函数创建实例时，实例会自动「关联」到该原型对象，从而可以共享原型对象中的属性和方法，避免重复定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-comment">// let Person = function() &#123;&#125;;  // 等价函数表达式</span><br><br><span class="hljs-comment">// 在构造函数中直接赋给对象实例的值，可以直接赋给它们的原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person1.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Nicholas</span><br><br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>person2.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// Nicholas</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">sayName</span> == person2.<span class="hljs-property">sayName</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// [Function: Person]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span>);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">取得对象的原型</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  name: &#x27;Nicholas&#x27;,</span><br><span class="hljs-comment">  age: 29,</span><br><span class="hljs-comment">  job: &#x27;Software Engineer&#x27;,</span><br><span class="hljs-comment">  sayName: [Function (anonymous)]</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person1));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person2));<br></code></pre></td></tr></table></figure><h3 id="概念理解"><a href="#概念理解" class="headerlink" title="概念理解"></a>概念理解</h3><p>只要创建一个函数，就会按照特定的规则为这个函数创建一个 <code>prototype</code> 属性（指向原型对象）。默认情况下，<strong>所有原型对象自动获得一个名为 <code>constructor</code> 的属性，指向与之关联的构造函数</strong></p><p><a href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">前面代码</a>中的 <code>Person.prototype.constructor</code> 指向 <code>Person</code></p><p>自定义构造函数时，原型对象默认只会获得 <code>constructor</code> 属性，其它所有方法都继承自 <code>Object</code></p><p>每次调用构造函数创建一个新实例，该实例的内部 <code>[[Prototype]]</code> 指针就会被赋值为构造函数的原型对象。浏览器会在每个对象上暴露可以访问原型对象的 <code>__proto__</code> 属性</p><p><strong>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有联系</strong></p><p>构造函数通过 <code>prototype</code> 指向原型对象，实例通过 <code>__proto__</code> 关联原型对象</p><p><img src="/2025/10/22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/person.prototype.png" alt="构造函数、原型对象和对象之间的关系"></p><ul><li><p><code>Person.prototype</code> 指向原型对象，而 <code>Person.prototpye.constructor</code> 指向 <code>Person</code> 构造函数</p></li><li><p>原型对象包含 <code>constructor</code> 属性和其他后来添加的属性</p></li><li><p>两个实例都没有属性和方法，但可以正常调用 <code>sayName()</code> 函数<br><br></p></li></ul><blockquote><p>使用 <code>Object.getPrototypeOf()</code> 可以取得一个对象的原型</p><p>为避免使用 <code>Object.setPrototypeOf()</code> 可能造成的性能下降，可以通过 <code>Object.create()</code> 创建一个新对象，同时为其指定原型</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> biped = &#123;<br>    <span class="hljs-attr">numLegs</span>: <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(biped);<br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Matt&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Matt</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">numLegs</span>);  <span class="hljs-comment">// 2</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getPrototypeOf</span>(person) === biped);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="层级"><a href="#层级" class="headerlink" title="层级"></a>层级</h3><p>通过对象访问属性时，如果在对象实例上发现了给定的名称，则返回该名称对应的值。否则，会沿着指针进入原型对象，在原型对象上找到属性，再返回对应的值</p><p>只要给对象实例添加一个属性，这个属性就会<strong>遮蔽</strong>原型对象上的同名属性。使用 <code>delete</code> 操作符可以完全删除实例上的属性，让标识符解析过程能够继续搜索原型对象</p><p><code>hasOwnProperty()</code> 方法会在属性存在于调用它的对象实例上时返回 <code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>person1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Greg&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Greg</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Nicholas</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">delete</span> person1.<span class="hljs-property">name</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">name</span>);  <span class="hljs-comment">// Nicholas</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><br><blockquote><p><code>ECMAScript</code> 的 <code>Object.getOWnPropertyDescriptor()</code> 方法只对实例属性有效</p><p>必须直接在原型对象上调用 <code>Object.getOwnPropertyDescriptor()</code> 获得原型属性的描述符</p></blockquote><h3 id="in-操作符"><a href="#in-操作符" class="headerlink" title="in 操作符"></a><code>in</code> 操作符</h3><p><code>in</code> 操作符会在可以通过对象访问指定属性时返回 <code>true</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-title function_">hasOwnProperty</span>(<span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-keyword">in</span> person1);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>要确定原型上是否存在某个属性，可以同时使用 <code>hasOwnProperty()</code> 和 <code>in</code> 操作符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">hasPrototypeProperty</span>(<span class="hljs-params">object, name</span>) &#123;<br>    <span class="hljs-comment">// 通过对象可以访问时，in 操作符返回 true</span><br>    <span class="hljs-comment">// hasOwnProperty() 只有实例上存在属性时才返回 true</span><br>    <span class="hljs-comment">// in 操作符返回 true 且 hasOwnProperty() 返回 false 为原型属性</span><br>    <span class="hljs-keyword">return</span> !object.<span class="hljs-title function_">hasOwnProperty</span>(name) &amp;&amp; (name <span class="hljs-keyword">in</span> object);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">30</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasPrototypeProperty</span>(person, <span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// true</span><br><br>person.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Greg&quot;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">hasPrototypeProperty</span>(person, <span class="hljs-string">&quot;name&quot;</span>));  <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><code>Object.keys()</code> 可以获得对象上所有可枚举的实例属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Nicholas&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">age</span> = <span class="hljs-number">29</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">job</span> = <span class="hljs-string">&quot;Software Engineer&quot;</span>;<br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>&#125;;<br><br><span class="hljs-keyword">let</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys);  <span class="hljs-comment">// [ &#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;sayName&#x27; ]</span><br><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br>p1.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Rob&quot;</span>;<br>p1.<span class="hljs-property">age</span> = <span class="hljs-number">50</span>;<br><br><span class="hljs-keyword">let</span> p1keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(p1);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p1keys);  <span class="hljs-comment">// [ &#x27;name&#x27;, &#x27;age&#x27; ]</span><br><br><span class="hljs-comment">// 无论是否可以枚举，Object.getOWnPropertyNames() 都可以列出所有实例属性</span><br><span class="hljs-keyword">let</span> keys1 = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br><span class="hljs-comment">// 返回的结果中包含一个不可枚举的属性 constructor</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(keys1);  <span class="hljs-comment">// [ &#x27;constructor&#x27;, &#x27;name&#x27;, &#x27;age&#x27;, &#x27;job&#x27;, &#x27;sayName&#x27; ]</span><br></code></pre></td></tr></table></figure><p><code>Object.geOwnPropertySymbols()</code> 用于获取对象自身所有 <strong><code>Symbol</code> 类型属性</strong>（不包含继承的 <code>Symbol</code> 属性），与 <code>Object.getOwnPropertyNames()</code> 类似，但专门针对 <code>Symbol</code> 类型的属性（普通字符串属性不会被返回）</p><h3 id="属性枚举顺序"><a href="#属性枚举顺序" class="headerlink" title="属性枚举顺序"></a>属性枚举顺序</h3><p><code>for-in</code> 循环和 <code>Object.keys()</code> 的枚举顺序时不确定的，取决于 <code>JavaScript</code> 引擎，可能因浏览器而异</p><p><code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code> 和 <code>Object.assign()</code> <mark>先以升序枚举数值键<mark>，然后<mark>以插入顺序枚举字符串和符号键<mark>。</p><p>在对象字面量中定义的键以它们逗号分割的顺序（<strong>键值对的书写顺序</strong>）插入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> k1 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;k1&#x27;</span>),<br>    k2 = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">&#x27;k2&#x27;</span>);<br><br><span class="hljs-keyword">let</span> o = &#123;<br>    <span class="hljs-number">1</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;first&#x27;</span>,<br>    [k2]: <span class="hljs-string">&#x27;sym2&#x27;</span>,<br>    <span class="hljs-attr">second</span>: <span class="hljs-string">&#x27;second&#x27;</span>,<br>    <span class="hljs-number">0</span>: <span class="hljs-number">0</span><br>&#125;;<br><br>o[k1] = <span class="hljs-string">&#x27;sym2&#x27;</span>;<br>o[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br>o.<span class="hljs-property">third</span> = <span class="hljs-string">&#x27;third&#x27;</span>;<br>o[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">// [ &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;first&#x27;, &#x27;second&#x27;, &#x27;third&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyNames</span>(o));<br><br><span class="hljs-comment">// [ Symbol(k2), Symbol(k1) ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertySymbols</span>(o));<br></code></pre></td></tr></table></figure><h2 id="对象迭代"><a href="#对象迭代" class="headerlink" title="对象迭代"></a>对象迭代</h2><p>静态方法 <code>Object.values()</code> 和 <code>Object.entries()</code> 用于将对象内容转换为可迭代序列化的格式</p><ul><li><p>这两个方法接收一个对象</p></li><li><p><code>Object.values()</code> 返回<strong>对象值的数组</strong></p></li><li><p><code>Object.entries()</code> 返回<strong>键&#x2F;值对的数组</strong></p></li><li><p>非字符串属性会被转换为字符串输出</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sym = <span class="hljs-title class_">Symbol</span>();<br><br><span class="hljs-keyword">const</span> o = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>    <span class="hljs-attr">baz</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">qux</span>: &#123;&#125;,<br>    [sym]: <span class="hljs-string">&#x27;foo&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 符号属性 sym 会被忽略</span><br><span class="hljs-comment">// [ &#x27;bar&#x27;, 1, &#123;&#125; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(o));<br><br><span class="hljs-comment">// [ [ &#x27;foo&#x27;, &#x27;bar&#x27; ], [ &#x27;baz&#x27;, 1 ], [ &#x27;qux&#x27;, &#123;&#125; ] ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(o));<br><br><span class="hljs-comment">// 这两个方法执行对象的浅复制</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">values</span>(o)[<span class="hljs-number">0</span>] === o.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">    Object.entries(o)[0]: [&#x27;foo&#x27;, &#x27;bar&#x27;]</span><br><span class="hljs-comment">    Object.entries(o)[0][1]: &#x27;bar&#x27;</span><br><span class="hljs-comment">    o.foo: &#x27;bar&#x27;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">entries</span>(o)[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] === o.<span class="hljs-property">foo</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="其他原型语法"><a href="#其他原型语法" class="headerlink" title="其他原型语法"></a>其他原型语法</h3><p>为了减少代码冗余，通常直接通过一个包含所有属性和方法的对象字面量来重写原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-comment">// 防止 constructor 属性指向 Object 构造函数</span><br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">29</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> friend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(friend <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(friend <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(friend.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Person</span>);  <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(friend.<span class="hljs-property">constructor</span> == <span class="hljs-title class_">Object</span>);  <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 与 constructor: Person 等价操作</span><br><span class="hljs-comment">// Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</span><br><span class="hljs-comment">//     enumerable: false,</span><br><span class="hljs-comment">//     value: Person</span><br><span class="hljs-comment">// &#125;);</span><br></code></pre></td></tr></table></figure><h3 id="原型动态性"><a href="#原型动态性" class="headerlink" title="原型动态性"></a>原型动态性</h3><p>从原型上搜索值的过程是动态的，即使实例在修改原型之前已经存在，任何时候对原型所作的修改也会在实例上反映出来</p><p>原因：实例和原型之间使用指针链接，而不是保存的副本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-comment">// constructor: Person,</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">29</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> friend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-comment">// 创建 friend 实例后添加 sayHi() 方法</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayHi</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hi&quot;</span>);<br>&#125;;<br><br><span class="hljs-comment">// friend 仍然可以访问 sayHi() 方法</span><br>friend.<span class="hljs-title function_">sayHi</span>();  <span class="hljs-comment">// hi</span><br></code></pre></td></tr></table></figure><p>重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-keyword">let</span> friend = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">29</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// friend 指向的还是最初的原型，并没有 sayName() 属性</span><br>friend.<span class="hljs-title function_">sayName</span>();  <span class="hljs-comment">// TypeError: friend.sayName is not a function</span><br></code></pre></td></tr></table></figure><br><p><img src="/2025/10/22/JavaScript-%E7%AC%94%E8%AE%B0-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/rewrite_prototype.png" alt="重写原型后的对应关系"></p><h3 id="原生对象原型"><a href="#原生对象原型" class="headerlink" title="原生对象原型"></a>原生对象原型</h3><p>所有原生引用类型的构造函数（包括 <code>Object</code>、<code>Array</code>、<code>String</code> 等）都在原型上定义了实例方法</p><p>可以像修改自定义对象原型一样修改原生对象原型，随时可以添加方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 给 String 原始值包装类型的实例添加一个 startsWith() 方法</span><br><span class="hljs-comment">// 当前环境下所有的字符串都可以使用这个方法</span><br><span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">startsWith</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">text</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">indexOf</span>(text) === <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">let</span> msg = <span class="hljs-string">&quot;Hello world!&quot;</span>;<br><span class="hljs-comment">// 读取 msg 的属性时，后台会自动创建 String 的包装实例（JavaScript 临时创建的对应的对象类型实例）</span><br><span class="hljs-comment">// 找到并调用 startsWith() 方法</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&quot;Hello&quot;</span>));<br></code></pre></td></tr></table></figure><blockquote><p>推荐创建一个自定义的类，继承原生类型<br>不推荐修改原生对象原型，直接修改原生对象类型可能引发命名冲突</p></blockquote><h3 id="原型的问题"><a href="#原型的问题" class="headerlink" title="原型的问题"></a>原型的问题</h3><p>原型弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值</p><p>原型最主要问题源自它的<strong>共享特性</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params"></span>) &#123;&#125;<br><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">constructor</span>: <span class="hljs-title class_">Person</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Nicholas&quot;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">29</span>,<br>    <span class="hljs-attr">job</span>: <span class="hljs-string">&quot;Software Engineer&quot;</span>,<br>    <span class="hljs-attr">friends</span>: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>],<br>    <span class="hljs-title function_">sayName</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">let</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><span class="hljs-keyword">let</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();<br><br>person1.<span class="hljs-property">friends</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">&quot;Van&quot;</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">friends</span>);  <span class="hljs-comment">// [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person2.<span class="hljs-property">friends</span>);  <span class="hljs-comment">// [ &#x27;Shelby&#x27;, &#x27;Court&#x27;, &#x27;Van&#x27; ]</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person1.<span class="hljs-property">friends</span> === person2.<span class="hljs-property">friends</span>);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>由于 <code>friends</code> 属性存在于 <code>Person.prototype</code> 而非 <code>person1</code> 上，新加的 “Van” 也会在 <code>person2.friends</code> 上反映出来</p><p>一般不同的实例应该有属于自己的属性副本，所以在实际开发中通常不单独使用原型模式</p>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 笔记-对象基本概念</title>
    <link href="/2025/10/21/JavaScript-%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2025/10/21/JavaScript-%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p><code>ECMA-262</code> 使用两个中括号把特性的名称括起来，将某个特性标识为内部特性，例如 <code>[[Enumerable]]</code></p><h2 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h2><ul><li><p>数据属性包含一个保存数据值的位置，从这个位置读取和写入值</p></li><li><p>调用 <code>Object.defineProperty()</code> 如果不指定 <code>configurable、enumerable 和 writable</code>，默认都为 <code>false</code></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义一个对象，包含伪私有成员 year_ 和公共成员 edition</span><br><span class="hljs-keyword">let</span> book = &#123;<br><span class="hljs-attr">year_</span>: <span class="hljs-number">2017</span>,  <span class="hljs-comment">// year_ 中的下划线表示该属性不希望在对象方法的外部被访问</span><br><span class="hljs-attr">edition</span>: <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h2><ul><li><p>访问器属性不包含数据值，包含一个获取（<code>getter</code>）函数和一个设置（<code>setter</code>）函数</p></li><li><p>只定义 <code>getter</code> 函数意味着属性是只读的，尝试修改属性会被忽略</p></li><li><p>只有一个 <code>setter</code> 函数的属性是不能读取的</p></li></ul><h2 id="Object-defineProperties-方法可以通过多个描述符一次性定义多个属性"><a href="#Object-defineProperties-方法可以通过多个描述符一次性定义多个属性" class="headerlink" title="Object.defineProperties() 方法可以通过多个描述符一次性定义多个属性"></a><code>Object.defineProperties()</code> 方法可以通过多个描述符一次性定义多个属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book = &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(book, &#123;<br><span class="hljs-comment">/* </span><br><span class="hljs-comment">        year_ 和 edition 是数据属性</span><br><span class="hljs-comment">    configurable、enumerable 和 writable 特性值都是 false</span><br><span class="hljs-comment">        </span><br><span class="hljs-comment">        使用 Object.defineProperties 必须使用 Object 定义属性</span><br><span class="hljs-comment">        否则会报错 TypeError: Property description must be an object:</span><br><span class="hljs-comment">    */</span><br><span class="hljs-attr">year_</span>: &#123;<br><span class="hljs-attr">value</span>: <span class="hljs-number">2017</span><br>&#125;,<br><br><span class="hljs-attr">edition</span>: &#123;<br><span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>&#125;,<br><br><span class="hljs-comment">// 访问器属性</span><br><span class="hljs-attr">year</span>: &#123;<br><span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span>;<br>&#125;,<br><br><span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) &#123;<br><span class="hljs-keyword">if</span>(newValue &gt; <span class="hljs-number">2017</span>) &#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span> = newValue;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">edition</span> += newValue - <span class="hljs-number">2017</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="使用-Object-getOwnPropertyDescriptor-方法可以取得指定属性的属性描述符"><a href="#使用-Object-getOwnPropertyDescriptor-方法可以取得指定属性的属性描述符" class="headerlink" title="使用 Object.getOwnPropertyDescriptor() 方法可以取得指定属性的属性描述符"></a>使用 <code>Object.getOwnPropertyDescriptor()</code> 方法可以取得指定属性的属性描述符</h2><p>该方法接收属性所在的对象和要取得其描述符的属性名</p><p><strong>访问器属性</strong>返回包含 <code>configurable、enumerable、get</code> 和 <code>set</code> 属性的对象</p><p><strong>数据属性</strong>返回包含 <code>configurable、enumerable、writable</code> 和 <code>value</code> 属性的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> book = &#123;&#125;;<br><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperties</span>(book, &#123;<br>    <span class="hljs-attr">year_</span>: &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-number">2017</span><br>    &#125;,<br><br>    <span class="hljs-attr">edition</span>: &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-number">1</span><br>    &#125;,<br><br>    <span class="hljs-attr">year</span>: &#123;<br>        <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span>;<br>        &#125;,<br><br>        <span class="hljs-attr">set</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">newValue</span>) &#123;<br>            <span class="hljs-keyword">if</span> (newValue &gt; <span class="hljs-number">2017</span>) &#123;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">year_</span> = newValue;<br>                <span class="hljs-variable language_">this</span>.<span class="hljs-property">edition</span> += newValue - <span class="hljs-number">2017</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;);<br><br><span class="hljs-keyword">let</span> descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(book, <span class="hljs-string">&#x27;year_&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">value</span>);  <span class="hljs-comment">// 2017</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">configurable</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> descriptor.<span class="hljs-property">get</span>);  <span class="hljs-comment">// undefined</span><br><br>descriptor = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptor</span>(book, <span class="hljs-string">&#x27;year&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">value</span>);  <span class="hljs-comment">// undefined</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(descriptor.<span class="hljs-property">enumerable</span>);  <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> descriptor.<span class="hljs-property">get</span>);  <span class="hljs-comment">// function</span><br><br><span class="hljs-comment">// Object.getOwnPropertyDescriptors() 会在每个自有属性上调用 Object.getOwnPropertyDescriptor() 并在一个新对象中返回它们</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">getOwnPropertyDescriptors</span>(book));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">  year_: &#123;</span><br><span class="hljs-comment">    value: 2017,</span><br><span class="hljs-comment">    writable: false,</span><br><span class="hljs-comment">    enumerable: false,</span><br><span class="hljs-comment">    configurable: false</span><br><span class="hljs-comment">  &#125;,</span><br><span class="hljs-comment">  edition: &#123; value: 1, writable: false, enumerable: false, configurable: false &#125;,</span><br><span class="hljs-comment">  year: &#123;</span><br><span class="hljs-comment">    get: [Function: get],</span><br><span class="hljs-comment">    set: [Function: set],</span><br><span class="hljs-comment">    enumerable: false,</span><br><span class="hljs-comment">    configurable: false</span><br><span class="hljs-comment">  &#125;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="Object-assign-方法用于合并对象"><a href="#Object-assign-方法用于合并对象" class="headerlink" title="Object.assign() 方法用于合并对象"></a><code>Object.assign()</code> 方法用于合并对象</h2><p>该方法接收<strong>一个目标对象</strong>和<strong>一个或多个源对象</strong>作为参数，然后将每个源对象中可枚举（<code>Object.propertyIsEnumerable()</code> 返回 <code>true</code>） 和自有（<code>Object.hasOwnProperty()</code> 返回 <code>true</code>）属性复制到目标对象</p><p>该方法会复制以字符串和符号为键的属性</p><p>对每个符合条件的属性，该方法会使用源对象上的 <code>[[Get]]</code> 取得属性的值，然后使用目标对象上的 <code>[[Set]]</code> 设置属性的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">dest = &#123;<br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">val</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Invoked dest setter with param <span class="hljs-subst">$&#123;val&#125;</span>`</span>);<br>    &#125;<br>&#125;;<br><br>src = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">a</span>() &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Invoked src getter&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">调用 src 的获取方法</span><br><span class="hljs-comment">调用 dest 的设置方法并传入参数 &quot;foo&quot;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(dest, src);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Invoked src getter</span><br><span class="hljs-comment">Invoked dest setter with param foo</span><br><span class="hljs-comment">&#123; a: [Setter] &#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dest);<br></code></pre></td></tr></table></figure><hr><p><code>Object.assign()</code> 对每个源对象执行<strong>浅复制</strong>(1.直接复制对象的基本类型值 2.引用类型数据只复制内存地址，<strong>新旧对象共享同一份深层数据</strong>，修改深层数据会相互影响)。如果多个源对象有相同的属性，则使用最后一个复制的值</p><p>如果赋值期间出错，操作会中止并退出，同时抛出错误</p><h2 id="Object-is-判定相等"><a href="#Object-is-判定相等" class="headerlink" title="Object.is() 判定相等"></a><code>Object.is()</code> 判定相等</h2><p><code>Object.is()</code> 与 <code>===</code> 类似，但能正确处理特殊值</p><ul><li><p><code>Object.is(NaN, NaN)</code> 返回 <code>true</code>（而 <code>NaN === NaN</code> 返回 <code>false</code>）</p></li><li><p><code>Object.is(+0, -0)</code> 返回 <code>false</code>（而 <code>+0 === -0</code> 返回 <code>true</code>）</p></li></ul><h2 id="增强的对象语法"><a href="#增强的对象语法" class="headerlink" title="增强的对象语法"></a>增强的对象语法</h2><h3 id="简写属性名"><a href="#简写属性名" class="headerlink" title="简写属性名"></a>简写属性名</h3><p>简写属性名只要使用变量名（不用再写冒号）就会自动被解释为同名的属性键。如果没有找到同名变量，则会抛出 <code>ReferenceError</code></p><p>下面两段代码等价</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>;<br><br><span class="hljs-keyword">let</span> person = &#123;<br><span class="hljs-attr">name</span>: name<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);  <span class="hljs-comment">// &#123; name: &#x27;Matt&#x27; &#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;Matt&#x27;</span>;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>name<br>&#125;;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);  <span class="hljs-comment">// &#123; name: &#x27;Matt&#x27; &#125;</span><br></code></pre></td></tr></table></figure><h3 id="可计算属性"><a href="#可计算属性" class="headerlink" title="可计算属性"></a>可计算属性</h3><p>可计算属性可以在对象字面量中完成动态属性赋值，不用先声明对象，再使用中括号语法来添加属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> nameKey = <span class="hljs-string">&#x27;name&#x27;</span>;<br><span class="hljs-keyword">const</span> ageKey = <span class="hljs-string">&#x27;age&#x27;</span>;<br><span class="hljs-keyword">const</span> jobKey = <span class="hljs-string">&#x27;job&#x27;</span>;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>[nameKey]: <span class="hljs-string">&#x27;Matt&#x27;</span>,<br>[ageKey]: <span class="hljs-number">27</span>,<br>[jobKey]: <span class="hljs-string">&#x27;Software engineer&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#x27;Software engineer&#x27; &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);<br></code></pre></td></tr></table></figure><h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象解构就是使用与对象匹配的结构来实现对象属性赋值，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。</p><p>如果引用的属性不存在，则该变量的值就是 <code>undefined</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Matt&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span><br>&#125;;<br><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">name</span>: personName, <span class="hljs-attr">age</span>: personAge &#125; = person;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personName);  <span class="hljs-comment">// Matt</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personAge);  <span class="hljs-comment">// 27</span><br><br><span class="hljs-comment">// let &#123; name, age &#125; = person;</span><br><br><span class="hljs-comment">// console.log(name);  // Matt</span><br><span class="hljs-comment">// console.log(age);  // 27</span><br><br><span class="hljs-keyword">let</span> &#123; name, job &#125; = person;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name);  <span class="hljs-comment">// Matt</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(job);  <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><ul><li><p>解构在内部使用函数 <code>ToObject()</code> 把数据结构转换为对象</p></li><li><p>在对象解构的上下文中，原始值会被当成对象</p></li><li><p><code>null</code> 和 <code>undefined</code> 不能被解构，否则会抛出错误</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; length &#125; = <span class="hljs-string">&#x27;foobar&#x27;</span>;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(length);  <span class="hljs-comment">// 6</span><br><br><span class="hljs-comment">// 通过对象解构赋值，从数字 4 的「包装对象」中提取 constructor 属性，并将其赋值给变量 c</span><br><span class="hljs-comment">// 对象的 constructor 属性指向创建该对象的构造函数</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">constructor</span>: c &#125; = <span class="hljs-number">4</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c === <span class="hljs-title class_">Number</span>);  <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">let</span> &#123; _ &#125; = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// TypeError</span><br><span class="hljs-keyword">let</span> &#123; _0 &#125; = <span class="hljs-literal">undefined</span>;  <span class="hljs-comment">// TypeError</span><br></code></pre></td></tr></table></figure><p><strong>如果给事先声明的变量赋值，则赋值表达式必须包含在一对括号中</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> personName, personAge;<br><br><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Matt&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span><br>&#125;;<br><br><span class="hljs-comment">// let &#123;name: personName, age: personAge&#125; = person;</span><br>(&#123;<span class="hljs-attr">name</span>: personName, <span class="hljs-attr">age</span>: personAge&#125; = person);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(personName, personAge);  <span class="hljs-comment">// Matt, 27</span><br></code></pre></td></tr></table></figure><p>解构赋值可以使用嵌套解构，以匹配嵌套的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Matt&#x27;</span>,<br>    <span class="hljs-attr">age</span>: <span class="hljs-number">27</span>,<br>    <span class="hljs-attr">job</span>: &#123;<br>        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Software Engineer&#x27;</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 声明 title 变量并将 person.job.title 的值赋给它</span><br><span class="hljs-keyword">let</span> &#123; <span class="hljs-attr">job</span>: &#123; title &#125; &#125; = person;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(title);  <span class="hljs-comment">// Software Engineer</span><br></code></pre></td></tr></table></figure><ul><li><p>在源对象或目标对象外层属性没有定义的情况下不能使用嵌套解构</p></li><li><p>如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaScript笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>popup.html 代码理解</title>
    <link href="/2025/10/21/popup-html-%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <url>/2025/10/21/popup-html-%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 声明文档类型为 HTML5，告诉浏览器以 HTML5 标准解析文档，避免进入 “怪异模式”（兼容旧版本 HTML 的解析方式）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 整个 HTML 文档的根容器，所有其他元素都嵌套在其中 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>  <span class="hljs-comment">&lt;!-- 用于定义文档的元数据、外部资源引用（脚本、样式等），不直接显示在页面上 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">用于响应式设计，适配移动设备（虽然扩展弹出页通常尺寸固定，但仍可能涉及缩放）</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">width=device-width：让页面宽度等于设备宽度</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">initial-scale=1：初始缩放比例为 1（不缩放）</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">defer=&quot;defer&quot;：表示脚本会延迟执行。浏览器会继续解析 HTML，同时下载脚本，直到 HTML 解析完成后再执行脚本</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">../js/popup.js，表示当前目录的上一级目录中的 js 文件夹）</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span>=<span class="hljs-string">&quot;defer&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../js/popup.js&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">引入外部 CSS 样式表 popup.css，用于美化页面样式</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">该路径等价于 ../css/popup.css</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">rel=&quot;stylesheet&quot; 表明这是一个样式表文件</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;../js/../css/popup.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">包含页面的可见内容，是用户实际看到的部分</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">一个空的 &lt;div&gt; 容器，用于通过 JavaScript（popup.js）动态生成弹出页的内容（如按钮、列表、表单等）。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">id=&quot;chrome-extension-popup&quot; 为其指定唯一标识，方便脚本通过 document.getElementById 获取该元素并操作（如添加子元素、修改内容等）</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;chrome-extension-popup&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>HTML</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代码理解</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>manifest.json 代码理解</title>
    <link href="/2025/10/21/manifest-json-%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/"/>
    <url>/2025/10/21/manifest-json-%E4%BB%A3%E7%A0%81%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<!-- 给一个 `Chrome` 扩展程序的 `manifest.json` 文件添加了理解注释 --><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>   <span class="hljs-comment">// 定义扩展在浏览器工具栏中的按钮（即 “动作按钮”）</span><br>   <span class="hljs-attr">&quot;action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;default_icon&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;icons/ic_16.png&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 按钮默认显示的图标（16x16）</span><br>      <span class="hljs-attr">&quot;default_popup&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;html/popup.html&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 点击按钮时弹出的页面（html/popup.html），通常用于展示功能界面（如提取结果）</span><br>      <span class="hljs-attr">&quot;default_title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Turbo Email Extractor&quot;</span>  <span class="hljs-comment">// 鼠标悬停在按钮上时显示的提示文字</span><br>   <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 定义扩展的背景服务</span><br>   <span class="hljs-attr">&quot;background&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// 指定背景服务的脚本文件, 用于处理扩展的后台逻辑（如监听事件、持久化数据等）</span><br>      <span class="hljs-comment">// service worker 是无界面的，生命周期由浏览器管理，不支持 DOM 操作</span><br>      <span class="hljs-comment">// DOM（Document Object Model，文档对象模型）操作指的是通过代码对 HTML 或 XML 文档的结构、内容和样式进行动态修改的过程</span><br>      <span class="hljs-attr">&quot;service_worker&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;js/background.js&quot;</span><br>   <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 定义内容脚本（注入到网页中的脚本，用于操作网页 DOM 或数据）</span><br>   <span class="hljs-attr">&quot;content_scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-comment">// 注入到匹配网页的样式表（css/contentScripts.css），用于修改网页样式</span><br>      <span class="hljs-attr">&quot;css&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;css/contentScripts.css&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// 注入到匹配网页的脚本（js/contentScripts.js），核心逻辑（如提取网页中的邮件地址）通常在这里实现</span><br>      <span class="hljs-attr">&quot;js&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;js/contentScripts.js&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// 匹配的网页 URL 规则，&lt;all_urls&gt; 表示所有 HTTP/HTTPS/FTP 等网页</span><br>      <span class="hljs-attr">&quot;matches&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;\u003Call_urls&gt;&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-comment">// 脚本注入时机，document_start 表示在网页 DOM 开始解析时注入（早于 document_ready）</span><br>      <span class="hljs-comment">// </span><br>      <span class="hljs-comment">// document_start:</span><br>      <span class="hljs-comment">// 浏览器刚刚开始解析 HTML 文档，尚未构建任何 DOM 节点，&lt;html&gt; 标签甚至都未被解析</span><br>      <span class="hljs-comment">// 此时，文档处于最早期的加载阶段，仅完成了资源的初始获取，尚未开始实质性的 DOM 树构建</span><br>      <span class="hljs-comment">// 适合执行不需要依赖 DOM 的初始化操作（如设置全局变量、注册事件监听框架等）</span><br>      <span class="hljs-comment">// </span><br>      <span class="hljs-comment">// document_ready:</span><br>      <span class="hljs-comment">// 对应 DOMContentLoaded 事件触发的时刻，即 HTML 文档完全解析并构建出完整的 DOM 树</span><br>      <span class="hljs-comment">// 此时无需等待样式表、图片、iframe 等外部资源加载完成</span><br>      <span class="hljs-comment">// DOM 树已完整可用，可以安全地操作任何 DOM 元素（如查询、修改、绑定事件等）</span><br>      <span class="hljs-comment">// 若存在阻塞 DOM 解析的脚本（如同步 &lt;script&gt;），会延迟 document_ready 的触发时间</span><br>      <span class="hljs-attr">&quot;run_at&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;document_start&quot;</span><br>   <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Extract emails from all web pages&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// host_permissions 声明扩展需要访问的主机权限，&lt;all_urls&gt; 表示允许访问所有 URL 的网页</span><br>   <span class="hljs-comment">// \u003C 表示 &#x27;&lt;&#x27; 的转义序列</span><br>   <span class="hljs-comment">// \u 后跟四位十六进制数字是 Unicode 转义序列格式，用于表示特定的 Unicode 字符</span><br>   <span class="hljs-comment">// 003C 对应 Unicode 字符集中小于号(&lt;)的代码点</span><br>   <span class="hljs-attr">&quot;host_permissions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;\u003Call_urls&gt;&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 定义扩展在不同场景下显示的图标</span><br>   <span class="hljs-attr">&quot;icons&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;128&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;icons/ic_128.png&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 安装时的提示、应用商店展示等</span><br>      <span class="hljs-attr">&quot;16&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;icons/ic_16.png&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 扩展管理页面、地址栏图标等</span><br>      <span class="hljs-attr">&quot;48&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;icons/ic_48.png&quot;</span>  <span class="hljs-comment">// 扩展详情页</span><br>   <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 扩展的公钥（用于标识扩展的唯一性，通常由浏览器自动生成，发布到应用商店时需要）</span><br>   <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwE/GAGNbengnDoGO4v5onC9CSpzyZm/i33QPKOxVw1OLY2cmqJgcX/t5NnWw7AzQchfwoB35+XqwJcaqkTLNNnM53FsrX938xqONasC17Be+Tih41jAjCkAnQWtokZxFv23vChuCOSlUmKHmwRLtag0/rJTbZvUED29irrZVDX0cedqhNFZlTJ/Sk9WDr26pl56cgMNxaVXB3vhpP7CHNb5C3yAHVJUPOOhxk2LAavb+sjSUXS8Q4DMBz2pAIYOoUAdrweuhU48pFU0RrzqgMtZxpnz15Sd26yk0FeIndKM+FFV5n7lV5C1q3DihHkxBCdnEgEmjdG3Hq4n+1UklGwIDAQAB&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;manifest_version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Turbo Email Extractor&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">/*</span><br><span class="hljs-comment">      声明扩展需要的功能权限</span><br><span class="hljs-comment">      tabs：允许操作浏览器标签页（如获取标签信息）</span><br><span class="hljs-comment">      activeTab：仅允许访问当前激活的标签页（临时权限，提高安全性）</span><br><span class="hljs-comment">      storage：允许使用浏览器的本地存储（chrome.storage）保存数据（如提取的邮件）</span><br><span class="hljs-comment">      background：允许访问背景服务（与 background 配置配合）</span><br><span class="hljs-comment">      webRequest：允许监听和拦截网页请求（可能用于从网络请求中提取邮件）</span><br><span class="hljs-comment">   */</span><br>   <span class="hljs-attr">&quot;permissions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;tabs&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;activeTab&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;storage&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;background&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;webRequest&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 扩展的自动更新地址（Chrome 扩展商店的标准更新接口）</span><br>   <span class="hljs-attr">&quot;update_url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://clients2.google.com/service/update2/crx&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-attr">&quot;version&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1.1&quot;</span><span class="hljs-punctuation">,</span><br>   <span class="hljs-comment">// 声明允许网页（而非扩展自身）访问的扩展资源</span><br>   <span class="hljs-attr">&quot;web_accessible_resources&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;matches&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;\u003Call_urls&gt;&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 允许哪些网页访问这些资源，&lt;all_urls&gt; 表示所有网页均可访问</span><br>      <span class="hljs-attr">&quot;resources&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;images/*&quot;</span> <span class="hljs-punctuation">]</span>  <span class="hljs-comment">// resources: 允许访问的资源路径（images/* 表示 images 目录下的所有文件，如图标、图片等）</span><br>   <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JavaScript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>代码理解</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
